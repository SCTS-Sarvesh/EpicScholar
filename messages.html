<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
    <title>Educational Messages</title>
    <link rel="stylesheet" href="messages.css">
    <style>
        /* Like count badge */
        .like-count {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 12px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 12px;
            min-width: 30px;
            text-align: center;
        }

        /* Comment button */
        .story-comment-btn {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(5px);
        }

        .story-comment-btn:hover {
            transform: scale(1.1);
            background: rgba(0, 114, 255, 0.3);
            border-color: var(--primary-color);
        }

        /* Comment Box Slide-up Panel */
        .story-comment-box {
            position: fixed;
            bottom: -100%;
            left: 35.5%;
            right: 0;
            height: 60vh;
            max-height: 500px;
            max-width: 450px;
            background: linear-gradient(to top, rgba(10, 10, 10, 0.98), rgba(20, 20, 20, 0.95));
            backdrop-filter: blur(20px);
            border-top-left-radius: 30px;
            border-top-right-radius: 30px;
            box-shadow: 0 -10px 50px rgba(0, 0, 0, 0.8);
            z-index: 200;
            transition: bottom 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            flex-direction: column;
        }

        .story-comment-box.active {
            bottom: 0;
        }

        .comment-box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comment-box-header h4 {
            color: white;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
        }

        .comment-box-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .comment-box-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .comment-box-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .no-comments {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: rgba(255, 255, 255, 0.5);
            gap: 15px;
        }

        .no-comments i {
            font-size: 48px;
            opacity: 0.3;
        }

        .comment-item {
            display: flex;
            gap: 12px;
            animation: slideInComment 0.3s ease;
        }

        @keyframes slideInComment {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .comment-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .comment-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .comment-username {
            font-weight: 700;
            font-size: 14px;
            color: white;
        }

        .comment-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }

        .comment-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .comment-box-input-wrapper {
            padding: 20px 25px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .comment-box-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 12px 20px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .comment-box-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 114, 255, 0.2);
        }

        .comment-box-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .comment-box-send-btn {
            background: var(--primary-gradient);
            border: none;
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
        }

        .comment-box-send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 114, 255, 0.6);
        }

        .comment-box-send-btn:active {
            transform: scale(0.95);
        }

        /* Remove old reply container styles - no longer needed */
        .story-reply-container {
            display: none;
        }

        /* Adjust story text position since no reply input at bottom */
        .story-text-content {
            position: absolute;
            bottom: 30px;
            left: 20px;
            right: 80px;
            pointer-events: none;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .story-comment-box {
                height: 70vh;
                max-height: none;
            }
        }

        /* Two-column layout for Add Story Form */
        .add-story-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            padding: 30px;
        }

        /* Left column - Story details */
        .form-left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Right column - YouTube search */
        .form-right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 600px;
            overflow: hidden;
        }

        /* Make form groups stack in left column */
        .add-story-form .form-group:nth-child(1),
        .add-story-form .form-group:nth-child(2),
        .add-story-form .form-group:nth-child(3) {
            grid-column: 1;
        }

        /* YouTube search in right column */
        .add-story-form .form-group:nth-child(4) {
            grid-column: 2;
            grid-row: 1 / -1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Make YouTube results container fill right column */
        .add-story-form .form-group:nth-child(4) .spotify-results {
            flex: 1;
            max-height: none;
            overflow-y: auto;
            margin-top: 15px;
        }

        /* Form actions span both columns at bottom */
        .form-actions {
            grid-column: 1 / -1;
            margin-top: 0;
        }

        /* Adjust modal width for two-column layout */
        .add-story-modal .story-modal-content {
            max-width: 900px;
            width: 95%;
        }

        /* YouTube search label styling */
        .form-group label {
            position: sticky;
            top: 0;
            background: rgba(20, 20, 20, 0.95);
            z-index: 10;
            padding-bottom: 8px;
        }

        /* Enhanced YouTube search container */
        .youtube-search-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        .youtube-search-input-wrapper {
            display: flex;
            gap: 10px;
        }

        .youtube-search-input-wrapper input {
            flex: 1;
        }

        /* Time range selector in right column */
        #timeRangeSelector {
            margin-top: 15px;
            animation: slideInUp 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .add-story-form {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .add-story-form .form-group:nth-child(1),
            .add-story-form .form-group:nth-child(2),
            .add-story-form .form-group:nth-child(3),
            .add-story-form .form-group:nth-child(4) {
                grid-column: 1;
                grid-row: auto;
            }

            .form-right-column {
                max-height: 400px;
            }
        }

        /* Fix z-index layering for story interactions */
        .story-reply-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 90px;
            z-index: 100;
            /* Increased from 50 to be above navigation */
        }

        .story-interactions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
            /* Increased from 50 to be above navigation */
            align-items: center;
        }

        /* Navigation areas should be below interactions */
        .story-nav-area {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 35%;
            z-index: 15;
            /* Keep this lower than interactions */
            cursor: pointer;
            transition: background 0.2s;
        }

        /* Ensure close button stays on top */
        .story-close {
            z-index: 150;
            /* Higher than everything */
        }

        /* Ensure progress bars stay on top */
        .story-progress-container {
            z-index: 120;
        }

        /* Ensure header stays on top */
        .story-header-info {
            z-index: 110;
        }

        /* Make reply input more visible and clickable */
        .story-reply-input-wrapper {
            position: relative;
            width: 100%;
            z-index: 100;
        }

        .story-reply-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 12px 45px 12px 20px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            pointer-events: auto;
            /* Ensure it's clickable */
        }

        .story-reply-input:focus {
            outline: none;
            background: rgba(0, 0, 0, 0.8);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 114, 255, 0.2);
        }

        .story-reply-btn {
            pointer-events: auto;
            /* Ensure button is clickable */
        }

        /* Ensure like button is clickable */
        .story-like-btn {
            pointer-events: auto;
            cursor: pointer;
        }

        /* Hide navigation arrows */
        .story-nav-arrows,
        .story-arrow,
        .arrow-left,
        .arrow-right {
            display: none !important;
        }

        /* Smooth cursor feedback */
        .story-carousel-container {
            cursor: none;
            user-select: none;
        }

        .story-carousel-container:active {
            cursor: none;
        }

        /* Visual hint for navigation */
        .story-navigation-hint {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            z-index: 25;
            display: flex;
            gap: 15px;
            align-items: center;
            animation: fadeInHint 0.5s ease 1s forwards;
            opacity: 0;
        }

        @keyframes fadeInHint {
            to {
                opacity: 1;
            }
        }

        .nav-hint-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .nav-hint-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 10px;
        }

        .story-nav-area,
        .story-nav-left,
        .story-nav-right {
            display: none !important;
            pointer-events: none !important;
        }

        /* Ensure interactive elements are clickable */
        .story-interactions,
        .story-interactions *,
        .story-comment-box,
        .story-comment-box * {
            pointer-events: auto !important;
        }

        /* Prevent clicks on story background from navigating */
        .story-card {
            pointer-events: none;
        }

        .story-card.active {
            pointer-events: none;
        }

        /* Allow clicks on interactive elements */
        .story-like-btn,
        .story-comment-btn,
        .comment-box-input,
        .comment-box-send-btn,
        .comment-box-close,
        .story-close {
            pointer-events: auto !important;
            cursor: pointer;
        }

        /* Add to your <style> section */
        .story-like-btn,
        .story-comment-btn {
            pointer-events: auto !important;
            cursor: pointer;
            z-index: 100;
            position: relative;
        }

        .story-comment-box * {
            pointer-events: auto !important;
        }

        /* Prevent clicks on story background */
        .story-card * {
            pointer-events: none;
        }

        .story-card.active .story-like-btn,
        .story-card.active .story-comment-btn,
        .story-card.active .story-comment-box,
        .story-card.active .story-comment-box * {
            pointer-events: auto !important;
        }

        /* Ensure buttons are above swipe detection */
        .story-like-btn,
        .story-comment-btn {
            pointer-events: auto !important;
            cursor: pointer;
            z-index: 150 !important;
            position: relative;
            touch-action: none;
            /* Prevent touch gestures on buttons */
        }

        /* Prevent swipe gestures on interactive elements */
        .story-interactions,
        .story-comment-box,
        .story-comment-box * {
            touch-action: none !important;
        }

        /* ============================================
   ENHANCED CHAT INPUT LAYOUT
   ============================================ */

        .chat-input-container {
            padding: 20px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-input {
            display: flex;
            align-items: flex-end;
            gap: 12px;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 28px;
            padding: 8px 12px;
            border: 2px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            position: relative;
        }

        .chat-input:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(0, 114, 255, 0.1);
        }

        /* Left side buttons group */
        .input-actions-left {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Right side buttons group */
        .input-actions-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Input wrapper */
        #normalInput {
            flex: 1;
            display: flex;
            align-items: center;
            min-height: 40px;
        }

        #messageInput {
            width: 100%;
            background: transparent;
            border: none;
            color: white;
            font-size: 15px;
            padding: 10px 12px;
            resize: none;
            max-height: 120px;
            overflow-y: auto;
            line-height: 1.5;
        }

        #messageInput:focus {
            outline: none;
        }

        #messageInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Redesigned input buttons */
        .input-btn {
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: rgba(255, 255, 255, 0.7);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            flex-shrink: 0;
        }

        .input-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: scale(1.1);
        }

        .input-btn:active {
            transform: scale(0.95);
        }

        .input-btn.active {
            background: var(--primary-gradient);
            color: white;
        }

        /* Send button special styling */
        .send-btn {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
        }

        .send-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 114, 255, 0.6);
            transform: scale(1.1);
        }

        /* Plus button for attachments */
        .attach-btn {
            position: relative;
        }

        /* Attachment menu */
        .attachment-menu {
            position: absolute;
            bottom: 60px;
            left: 0;
            background: rgba(20, 20, 20, 0.98);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 180px;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .attachment-menu.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .attachment-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s ease;
            font-size: 14px;
            text-align: left;
        }

        .attachment-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .attachment-option i {
            width: 24px;
            font-size: 18px;
            color: var(--primary-color);
        }

        .attachment-option span {
            flex: 1;
        }

        /* File input hidden */
        .file-input-hidden {
            display: none;
        }

        /* ============================================
   ANIMATED VOICE RECORDING VISUALIZER
   ============================================ */

        .recording-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 0 16px;
            flex: 1;
        }

        .voice-visualizer {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 40px;
            flex: 1;
        }

        .voice-bar {
            width: 4px;
            background: var(--primary-gradient);
            border-radius: 4px;
            min-height: 8px;
            height: 8px;
            transition: height 0.1s ease;
            animation: pulse 0.8s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(0, 114, 255, 0.5);
        }

        /* Stagger animation delays for bars */
        .voice-bar:nth-child(1) {
            animation-delay: 0s;
        }

        .voice-bar:nth-child(2) {
            animation-delay: 0.1s;
        }

        .voice-bar:nth-child(3) {
            animation-delay: 0.2s;
        }

        .voice-bar:nth-child(4) {
            animation-delay: 0.3s;
        }

        .voice-bar:nth-child(5) {
            animation-delay: 0.4s;
        }

        .voice-bar:nth-child(6) {
            animation-delay: 0.5s;
        }

        .voice-bar:nth-child(7) {
            animation-delay: 0.4s;
        }

        .voice-bar:nth-child(8) {
            animation-delay: 0.3s;
        }

        .voice-bar:nth-child(9) {
            animation-delay: 0.2s;
        }

        .voice-bar:nth-child(10) {
            animation-delay: 0.1s;
        }

        @keyframes pulse {

            0%,
            100% {
                height: 8px;
                opacity: 0.6;
            }

            50% {
                height: 32px;
                opacity: 1;
            }
        }

        .recording-time {
            color: #ff4444;
            font-weight: 600;
            font-size: 14px;
            min-width: 50px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff4444;
            border-radius: 50%;
            animation: blink 1s infinite;
            flex-shrink: 0;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Recording state styling */
        .chat-input.recording {
            border-color: #ff4444;
            box-shadow: 0 0 0 4px rgba(255, 68, 68, 0.2);
            background: rgba(40, 20, 20, 0.8);
        }

        /* Cancel recording button */
        .cancel-recording-btn {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        .cancel-recording-btn:hover {
            background: rgba(255, 68, 68, 0.3);
            transform: scale(1.1);
        }

        /* ============================================
   FILE PREVIEW IN MESSAGES
   ============================================ */

        .message-attachment {
            margin-top: 8px;
            border-radius: 12px;
            overflow: hidden;
            max-width: 300px;
        }

        .message-attachment img {
            width: 100%;
            height: auto;
            display: block;
        }

        .message-attachment video {
            width: 100%;
            height: auto;
            display: block;
        }

        .message-file {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .file-icon {
            width: 48px;
            height: 48px;
            background: var(--primary-gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 600;
            font-size: 14px;
            color: white;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-size {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .file-download {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-download:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* Voice message in chat */
        .voice-message-player {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            min-width: 200px;
        }

        .voice-play-btn {
            background: var(--primary-gradient);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .voice-play-btn:hover {
            transform: scale(1.1);
        }

        .voice-waveform {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 2px;
            height: 30px;
        }

        .waveform-bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            transition: background 0.3s ease;
        }

        .waveform-bar.active {
            background: var(--primary-color);
        }

        .voice-duration {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            min-width: 40px;
            text-align: right;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .chat-input {
                padding: 6px 10px;
            }

            .input-btn {
                width: 36px;
                height: 36px;
            }

            #messageInput {
                font-size: 14px;
            }
        }

        /* =========================================
   STORY INTERACTION FIXES
   ========================================= */

        /* Base state: Cards capture no pointer events to allow swipe */
        .story-card {
            pointer-events: none !important;
        }

        /* Active card allows interactions ONLY on specific children */
        .story-card.active {
            pointer-events: none !important;
            z-index: 100 !important;
            /* Ensure active card is on top */
        }

        /* Hide interactions on non-active cards to prevent "ghost" clicks */
        .story-card:not(.active) .story-interactions,
        .story-card:not(.active) .story-text-content {
            visibility: hidden;
            opacity: 0;
        }

        /* Make buttons clickable ONLY on the active card */
        .story-card.active .story-interactions,
        .story-card.active .story-like-btn,
        .story-card.active .story-comment-btn,
        .story-card.active .story-reply-input {
            pointer-events: auto !important;
            cursor: pointer;
        }

        /* Ensure Comment Box is always interactive when open */
        .story-comment-box,
        .story-comment-box * {
            pointer-events: auto !important;
            touch-action: pan-y !important;
            /* Allow scrolling inside comments */
        }

        /* Specific z-index layering */
        .story-interactions {
            z-index: 1000 !important;
        }

        .story-close {
            z-index: 2000 !important;
            pointer-events: auto !important;
        }

        /* =========================================
   ENHANCED LIGHTBOX ANIMATIONS
   ========================================= */

        /* 1. Smoother Overlay Opening */
        .lightbox-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none;
            /* Controlled by JS display: flex */
            flex-direction: column;
            opacity: 0;
            backdrop-filter: blur(0px);
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                backdrop-filter 0.4s ease;
        }

        .lightbox-modal.active {
            opacity: 1;
            backdrop-filter: blur(15px);
        }

        /* 2. Smooth Image/Video Transitions */
        #lightboxMediaContainer {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            perspective: 1000px;
        }

        .lightbox-content {
            max-width: 90%;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);

            /* This handles the smoothness when the 'src' changes via JS */
            animation: mediaReveal 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transition: transform 0.3s ease;
        }

        @keyframes mediaReveal {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* 3. Enhanced Navigation Buttons */
        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .lightbox-nav:hover {
            background: var(--primary-gradient);
            /* Uses your primary theme */
            border-color: transparent;
            box-shadow: 0 0 20px rgba(0, 114, 255, 0.4);
            transform: translateY(-50%) scale(1.1);
        }

        .lightbox-nav:active {
            transform: translateY(-50%) scale(0.95);
        }

        .lightbox-prev {
            left: 30px;
        }

        .lightbox-next {
            right: 30px;
        }

        /* 4. Smooth Thumbnail Selection */
        .lightbox-thumb {
            width: 55px;
            height: 55px;
            border-radius: 8px;
            opacity: 0.4;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            flex-shrink: 0;
            object-fit: cover;
        }

        .lightbox-thumb.active {
            opacity: 1;
            border-color: var(--primary-color);
            transform: scale(1.15) translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .lightbox-thumb:hover:not(.active) {
            opacity: 0.7;
            transform: translateY(-2px);
        }

        /* LIGHTBOX CONTENT ANIMATION */
        .lightbox-content {
            max-width: 90%;
            max-height: 80vh;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);

            /* Crucial: JS toggles opacity, CSS handles the smoothness */
            opacity: 0;
            transition: opacity 0.35s ease-in-out, transform 0.35s ease-out;
            transform: scale(0.98);
        }

        /* When active, slight scale up for "pop" effect */
        .lightbox-content[style*="opacity: 1"] {
            transform: scale(1);
        }

        /* Background/Container logic */
        #lightboxMediaContainer {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: transparent;
            /* Prevent black flicker */
        }

        /* --- ENHANCED WAVEFORM STYLING --- */
        .waveform-container {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 30px;
            padding: 0 10px;
        }

        .waveform-bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.3);
            /* Unplayed part */
            border-radius: 2px;
            transition: background 0.1s ease;
        }

        /* The "Active" state colored by the progress */
        .waveform-bar.active-bar {
            background: white;
            /* Matches your blue theme */
            box-shadow: 0 0 5px var(--primary-color);
        }

        .voice-message-player {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 20px;
        }

        /* ============================================
   FIXED COMMENT BOX STYLING
   ============================================ */

        .comment-box-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* Prevent horizontal scroll */
            padding: 20px 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            word-wrap: break-word;
            /* Force word wrapping */
        }

        .comment-item {
            display: flex;
            gap: 12px;
            animation: slideInComment 0.3s ease;
            width: 100%;
            /* Ensure full width usage */
            max-width: 100%;
            /* Prevent overflow */
        }

        .comment-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 0;
            /* Critical for text wrapping in flex */
            overflow-wrap: break-word;
            /* Break long words */
            word-break: break-word;
            /* Backup for word breaking */
        }

        .comment-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
            /* Wrap long text */
            word-break: break-word;
            /* Break long words if needed */
            overflow-wrap: break-word;
            /* Modern browsers */
            white-space: pre-wrap;
            /* Preserve line breaks but wrap */
            max-width: 100%;
            /* Prevent overflow */
            hyphens: auto;
            /* Optional: add hyphens for very long words */
        }

        .comment-username {
            font-weight: 700;
            font-size: 14px;
            color: white;
            word-break: break-word;
            /* Break long usernames if needed */
        }

        /* Ensure comment box itself doesn't scroll horizontally */
        .story-comment-box {
            position: fixed;
            bottom: -100%;
            left: 35.5%;
            right: 0;
            height: 60vh;
            max-height: 500px;
            max-width: 450px;
            background: linear-gradient(to top, rgba(10, 10, 10, 0.98), rgba(20, 20, 20, 0.95));
            backdrop-filter: blur(20px);
            border-top-left-radius: 30px;
            border-top-right-radius: 30px;
            box-shadow: 0 -10px 50px rgba(0, 0, 0, 0.8);
            z-index: 200;
            transition: bottom 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Prevent any overflow from parent */
        }

        /* Input area - ensure it doesn't overflow */
        .comment-box-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 12px 20px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
            word-wrap: break-word;
            /* Wrap input text */
            overflow-wrap: break-word;
            white-space: pre-wrap;
            /* Allow multiline input wrapping */
            max-width: 100%;
        }

        /* ============================================
   ENHANCED VOICE RECORDING VISUALIZER (CSS)
   ============================================ */

        .voice-visualizer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            /* Space between bars */
            height: 40px;
            flex: 1;
            margin: 0 10px;
        }

        .voice-bar {
            width: 4px;
            background: var(--primary-gradient);
            border-radius: 4px;
            min-height: 4px;
            height: 4px;
            /* Default resting height */
            transition: height 0.05s ease;
            /* Fast transition for snappy response */
            opacity: 0.5;

        }

        /* State when actively recording */
        .voice-bar.active-recording {
            opacity: 1;
            box-shadow: 0 0 8px rgba(0, 114, 255, 0.4);
            animation: none !important;
            /* Override any existing pulse animations */
        }
        /* =========================================
   WHATSAPP-STYLE REACTION SYSTEM
   ========================================= */

/* Reaction Menu (Emoji Picker) */
.reaction-menu {
    position: fixed;
    background: rgba(10, 10, 10, 0.95);
    backdrop-filter: blur(40px) saturate(210%);
    -webkit-backdrop-filter: blur(40px) saturate(210%);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 50px;
    padding: 8px 16px;
    display: none;
    gap: 12px;
    z-index: 99999;
    opacity: 0;
    transform: scale(0.9) translateY(15px);
    transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(255, 255, 255, 0.08);
}

.reaction-menu.active {
    opacity: 1;
    transform: scale(1) translateY(0);
    display: flex;
}

.reaction-emoji {
    font-size: 28px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    user-select: none;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.03);
}

.reaction-emoji:hover {
    transform: scale(1.5) translateY(-10px) rotate(5deg);
    background: rgba(255, 255, 255, 0.12);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.5);
}

.reaction-menu.active .reaction-emoji {
    animation: reactionSpringPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

@keyframes reactionSpringPop {
    0% {
        opacity: 0;
        transform: scale(0.4) translateY(20px);
    }
    100% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Reaction Trigger Button */
.reaction-trigger-wrapper {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    transition: all 0.25s ease;
    z-index: 100;
}

.message.sent .reaction-trigger-wrapper {
    left: -40px;
}

.message.received .reaction-trigger-wrapper {
    right: -40px;
}

.message:hover .reaction-trigger-wrapper {
    opacity: 0.8;
    transform: translateY(-50%) scale(1.1);
}

.reaction-trigger-btn {
    width: 30px;
    height: 30px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(5px);
    transition: all 0.3s;
}

.reaction-trigger-btn:hover {
    background: var(--primary-gradient);
    color: white;
    border-color: transparent;
    box-shadow: 0 0 15px rgba(0, 114, 255, 0.4);
}

/* Reaction Badge (Pills under message) */
.message-reaction-badge {
    position: absolute;
    bottom: -12px;
    background: rgba(20, 20, 20, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 30px;
    padding: 3px 10px;
    display: flex;
    gap: 8px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    z-index: 150;
    cursor: pointer;
    transition: transform 0.3s, background 0.3s;
}

.message.sent .message-reaction-badge {
    right: 65px;
}

.message.received .message-reaction-badge {
    left: 52px;
}

.message-reaction-badge:hover {
    transform: translateY(-4px) scale(1.06);
    background: rgba(40, 40, 40, 1);
    border-color: var(--primary-color);
}

.reaction-pill-item {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 14px;
    padding: 2px 6px;
    border-radius: 12px;
    transition: all 0.2s;
}

.reaction-pill-item:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
}

.reaction-pill-item .count {
    font-size: 11px;
    font-weight: 800;
    color: var(--primary-color);
    min-width: 16px;
    text-align: center;
}

/* Add spacing for reaction badges */
.message {
    margin-bottom: 28px;
    position: relative;
}

/* Smooth animations for adding/removing reactions */
@keyframes reactionPop {
    0% {
        transform: scale(0);
        opacity: 0;
    }
    50% {
        transform: scale(1.2);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.reaction-pill-item {
    animation: reactionPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}
/* =========================================
   FIXED REACTION TRIGGER POSITIONING
   ========================================= */

.reaction-trigger-wrapper {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    transition: all 0.25s ease;
    z-index: 100;
    pointer-events: none;
}

/* Sent messages - button on LEFT side of bubble */
.message.sent .reaction-trigger-wrapper {
    left: -45px;
}

/* Received messages - button on RIGHT side of bubble */
.message.received .reaction-trigger-wrapper {
    right: -45px;
}

.message:hover .reaction-trigger-wrapper {
    opacity: 1;
    pointer-events: auto;
}

.reaction-trigger-btn {
    width: 32px;
    height: 32px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(5px);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.reaction-trigger-btn:hover {
    background: var(--primary-gradient);
    color: white;
    border-color: transparent;
    box-shadow: 0 0 15px rgba(0, 114, 255, 0.4);
    transform: scale(1.15);
}

/* =========================================
   MESSAGE OPTIONS MENU (DELETE/CANCEL)
   ========================================= */

.message-options-trigger {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    transition: all 0.25s ease;
    z-index: 100;
    pointer-events: none;
}

/* Sent messages - options button on RIGHT side */
.message.sent .message-options-trigger {
    right: -45px;
}

/* Received messages - options button on LEFT side */
.message.received .message-options-trigger {
    left: -45px;
}

.message:hover .message-options-trigger {
    opacity: 1;
    pointer-events: auto;
}

.message-options-btn {
    width: 32px;
    height: 32px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(5px);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.message-options-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    color: white;
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.15);
}

/* Options Dropdown Menu */
.message-options-menu {
    position: fixed;
    background: rgba(20, 20, 20, 0.98);
    backdrop-filter: blur(40px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 16px;
    min-width: 220px;
    padding: 8px;
    display: none;
    flex-direction: column;
    gap: 4px;
    z-index: 99999;
    opacity: 0;
    transform: scale(0.9) translateY(-10px);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(255, 255, 255, 0.08);
}

.message-options-menu.active {
    opacity: 1;
    transform: scale(1) translateY(0);
    display: flex;
}

.message-option-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: white;
    font-size: 14px;
    font-weight: 500;
    background: transparent;
    border: none;
    text-align: left;
    width: 100%;
}

.message-option-item:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateX(4px);
}

.message-option-item i {
    width: 20px;
    font-size: 16px;
    color: rgba(255, 255, 255, 0.7);
}

/* Delete Options - Different Colors */
.message-option-item.delete-for-me {
    color: #fbbf24;
}

.message-option-item.delete-for-me:hover {
    background: rgba(251, 191, 36, 0.1);
}

.message-option-item.delete-for-me i {
    color: #fbbf24;
}

.message-option-item.delete-for-everyone {
    color: #ef4444;
}

.message-option-item.delete-for-everyone:hover {
    background: rgba(239, 68, 68, 0.1);
}

.message-option-item.delete-for-everyone i {
    color: #ef4444;
}

.message-option-item.cancel {
    color: rgba(255, 255, 255, 0.6);
}

.message-option-item.cancel:hover {
    background: rgba(255, 255, 255, 0.05);
}

/* Divider between options */
.message-options-divider {
    height: 1px;
    background: rgba(255, 255, 255, 0.1);
    margin: 4px 0;
}

/* Animation for menu items */
.message-options-menu.active .message-option-item {
    animation: slideInOption 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    opacity: 0;
}

.message-options-menu.active .message-option-item:nth-child(1) {
    animation-delay: 0.05s;
}

.message-options-menu.active .message-option-item:nth-child(2) {
    animation-delay: 0.1s;
}

.message-options-menu.active .message-option-item:nth-child(3) {
    animation-delay: 0.15s;
}

.message-options-menu.active .message-option-item:nth-child(4) {
    animation-delay: 0.2s;
}

@keyframes slideInOption {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* =========================================
   CONFIRMATION MODAL
   ========================================= */

.delete-confirmation-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    z-index: 100000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.delete-confirmation-modal.active {
    display: flex;
    opacity: 1;
}

.delete-confirmation-content {
    background: rgba(20, 20, 20, 0.98);
    backdrop-filter: blur(40px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 30px;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
    transform: scale(0.9);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.delete-confirmation-modal.active .delete-confirmation-content {
    transform: scale(1);
}

.delete-confirmation-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 20px;
}

.delete-confirmation-icon {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.delete-confirmation-icon.warning {
    background: rgba(251, 191, 36, 0.2);
    color: #fbbf24;
}

.delete-confirmation-icon.danger {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
}

.delete-confirmation-title {
    font-size: 20px;
    font-weight: 700;
    color: white;
    margin: 0;
}

.delete-confirmation-text {
    color: rgba(255, 255, 255, 0.7);
    font-size: 14px;
    line-height: 1.6;
    margin-bottom: 25px;
}

.delete-confirmation-actions {
    display: flex;
    gap: 12px;
}

.delete-confirmation-btn {
    flex: 1;
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.delete-confirmation-btn.cancel {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

.delete-confirmation-btn.cancel:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
}

.delete-confirmation-btn.confirm {
    background: var(--primary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
}

.delete-confirmation-btn.confirm.danger {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
}

.delete-confirmation-btn.confirm:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 114, 255, 0.6);
}

.delete-confirmation-btn.confirm.danger:hover {
    box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
}

/* Adjust message spacing for buttons */
.message-content {
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-width: 70%;
}

/* Ensure buttons don't interfere with message flow */
.message {
    margin-bottom: 28px;
    position: relative;
    padding: 0 50px; /* Space for buttons on both sides */
}
/* =========================================
   DELETE NOTIFICATION
   ========================================= */

.delete-notification {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: rgba(20, 20, 20, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    padding: 12px 24px;
    display: flex;
    align-items: center;
    gap: 10px;
    color: white;
    font-size: 14px;
    font-weight: 500;
    z-index: 100001;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.delete-notification.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

.delete-notification i {
    color: #22c55e;
    font-size: 18px;
}
    </style>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>

<body>
    <div id="liquid-glass-container">
        <div class="glass-blob blob-1"></div>
        <div class="glass-blob blob-2"></div>
        <div class="glass-blob blob-3"></div>
    </div>

    <!-- Sidebar -->
    <!-- Sidebar -->
    <div class="nav-sidebar glass-element" id="navSidebar">
        <div class="nav-wrap" id="navWrap">
            <a class="nav-item" href="home.html" data-icon="">
                <span class="nav-icon-generic"> </span>
                <span class="nav-text"> Home</span>
            </a>
            <a class="nav-item nav-item-active" href="messages.html" data-icon="">
                <span class="nav-icon-generic"> </span>
                <span class="nav-text"> Messages</span>
            </a>
            <a class="nav-item" href="self-study.html" data-icon="">
                <span class="nav-icon-generic"> </span>
                <span class="nav-text"> Self-Study</span>
            </a>
            <a class="nav-item" href="edubot.html" data-icon="">
                <span class="nav-icon-generic"> </span>
                <span class="nav-text"> EduBot</span>
            </a>
            <a class="nav-item" href="mini-games.html" data-icon="">
                <span class="nav-icon-generic"> </span>
                <span class="nav-text"> Mini-Games</span>
            </a>
        </div>

        <div class="settings-wrap">
            <a class="nav-item" href="profile.html" data-icon="">
                <span class="nav-icon-generic"></span>
                <span class="nav-text">Profile</span>
            </a>
        </div>
    </div>

    <!-- Messages Container -->
    <div class="messages-container">
        <!-- Chat List Section -->
        <div class="chat-list-section glass-element">
            <div class="stories-container">
                <div class="stories-header">
                    <h3>Educational Stories</h3>
                    <button class="add-story-btn" onclick="openAddStoryModal()">
                        <i class="fas fa-plus"></i> Add
                    </button>
                </div>
                <div class="stories-list" id="storiesList"></div>
            </div>

            <div class="chat-list">
                <div class="chat-list-header">
                    <h2>Messages</h2>
                </div>
                <div class="conversations" id="conversationsList"></div>
            </div>
        </div>

        <!-- Chat Window Section -->
        <div class="chat-window-section">
            <div class="no-chat-selected glass-element" id="noChatSelected">
                <div class="no-chat-content">
                    <h2>Select a conversation</h2>
                    <p>Choose a chat to start messaging</p>
                </div>
            </div>

            <div class="chat-window glass-element hidden" id="chatWindow">
                <div class="chat-header" id="chatHeader"></div>
                <div class="chat-messages" id="chatMessages"></div>
                <!-- Replace the existing chat-input-container div with this -->
                <div class="chat-input-container">
                    <div class="disappearing-options hidden" id="disappearingOptions">
                        <button class="option-btn" id="readOnceBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                            Read Once
                        </button>
                        <button class="option-btn" id="timedBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            24 Hours
                        </button>
                    </div>

                    <div class="chat-input" id="chatInputBox">
                        <!-- Left side actions -->
                        <div class="input-actions-left">
                            <!-- Attachment button with menu -->
                            <div class="attach-btn">
                                <button class="input-btn" id="attachBtn" title="Attach files">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </button>

                                <!-- Attachment menu -->
                                <div class="attachment-menu" id="attachmentMenu">
                                    <button class="attachment-option" onclick="triggerFileInput('image')">
                                        <i class="fas fa-image"></i>
                                        <span>Photo</span>
                                    </button>
                                    <button class="attachment-option" onclick="triggerFileInput('video')">
                                        <i class="fas fa-video"></i>
                                        <span>Video</span>
                                    </button>
                                    <button class="attachment-option" onclick="triggerFileInput('document')">
                                        <i class="fas fa-file"></i>
                                        <span>Document</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Message input area -->
                        <div id="normalInput">
                            <input type="text" id="messageInput" placeholder="Type a message..." />
                        </div>

                        <!-- Recording indicator with animated visualizer -->
                        <div class="recording-indicator hidden" id="recordingIndicator">
                            <span class="recording-dot"></span>
                            <div class="voice-visualizer" id="voiceVisualizer">
                                <!-- Bars will be generated by JS -->
                            </div>
                            <span class="recording-time" id="recordingTime">0:00</span>
                        </div>

                        <!-- Right side actions -->
                        <div class="input-actions-right">
                            <button class="input-btn" id="disappearingBtn" title="Disappearing messages">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <polyline points="12 6 12 12 16 14"></polyline>
                                </svg>
                            </button>

                            <button class="input-btn" id="micBtn" title="Record voice message">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                    <line x1="12" y1="19" x2="12" y2="23"></line>
                                    <line x1="8" y1="23" x2="16" y2="23"></line>
                                </svg>
                            </button>

                            <button class="input-btn cancel-recording-btn hidden" id="cancelBtn"
                                title="Cancel recording">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>

                            <button class="input-btn hidden" id="stopBtn" title="Send voice message">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <polygon points="10 8 16 12 10 16 10 8" fill="currentColor"></polygon>
                                </svg>
                            </button>

                            <button class="input-btn send-btn hidden" id="sendBtn" title="Send message">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <line x1="22" y1="2" x2="11" y2="13"></line>
                                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <input type="file" id="imageInput" class="file-input-hidden" accept="image/*" multiple
                onchange="handleFileUpload(event, 'image')" />
            <input type="file" id="videoInput" class="file-input-hidden" accept="video/*" multiple
                onchange="handleFileUpload(event, 'video')" />
            <input type="file" id="documentInput" class="file-input-hidden"
                accept=".pdf,.doc,.docx,.txt,.xls,.xlsx,.ppt,.pptx" onchange="handleFileUpload(event, 'document')" />
            <!-- Story Modal -->
            <!-- Story View Modal -->
            <div class="story-modal" id="storyModal">
                <button class="story-close" onclick="closeStory()"></button>
                <div class="story-modal-content">
                    <!-- Carousel Container -->
                    <div class="story-carousel-container" id="storyCarousel">
                        <!-- Dynamic Content -->
                    </div>
                </div>
            </div>

            <!-- Add Story Modal -->
            <div class="story-modal add-story-modal" id="addStoryModal">
                <div class="story-modal-content modal-classic">
                    <div class="story-header-info" style="border:none; padding:20px; padding-bottom:0;">
                        <h4 style="color:white;">Create New Story</h4>
                        <button class="story-close" onclick="closeAddStoryModal()"
                            style="position:absolute; right:20px; top:20px;"></button>
                    </div>
                    <form class="add-story-form" onsubmit="submitStory(event)">
                        <div class="form-group">
                            <label>Story Subject</label>
                            <input type="text" id="storySubject" placeholder="e.g., Math Tips" required />
                        </div>

                        <div class="form-group">
                            <label>Content</label>
                            <textarea id="storyContent" placeholder="Share your knowledge..." rows="4"
                                required></textarea>
                        </div>

                        <!-- Media Upload Section -->
                        <div class="form-group">
                            <label>Add Media (Optional)</label>
                            <div class="media-upload-container">
                                <input type="file" id="mediaUpload" accept="image/*,video/*" style="display:none;"
                                    onchange="handleMediaUpload(event)" />
                                <button type="button" class="media-upload-btn"
                                    onclick="document.getElementById('mediaUpload').click()">
                                    <i class="fas fa-camera"></i> Upload Photo/Video
                                </button>
                                <div id="mediaPreview" class="media-preview hidden"></div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Add YouTube Audio Clip (Optional)</label>
                            <div style="display:flex; gap:10px;">
                                <input type="text" id="spotifySearchQuery"
                                    placeholder="Search for a song or video..." />
                                <button type="button" class="spotify-search-btn"
                                    onclick="setupLiveYouTubeSearch(); performLiveYouTubeSearch(document.getElementById('spotifySearchQuery').value)">
                                    <i class="fab fa-youtube"></i> Search
                                </button>
                            </div>
                            <div class="youtube-audio-note">
                                <i class="fas fa-info-circle"></i> You'll be able to select a specific time range
                                after choosing
                                a video
                            </div>
                        </div>

                        <div id="spotifyResults" class="spotify-results hidden"></div>
                        <input type="hidden" id="selectedTrackData" />
                        <input type="hidden" id="uploadedMediaData" />

                        <div class="form-actions">
                            <button type="button" class="btn-cancel" onclick="closeAddStoryModal()">Cancel</button>
                            <button type="submit" class="btn-submit">Post Story</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Hidden Spotify Config for Demo -->
            <div style="display:none;">
                <input type="hidden" id="spotifyClientId" value="your_client_id_here" />
                <input type="hidden" id="spotifyClientSecret" value="your_client_secret_here" />
            </div>
            <div class="lightbox-modal" id="lightboxModal">
                <div class="lightbox-header">
                    <div class="lightbox-user-info" id="lightboxUser">Sender Name</div>
                    <button class="lightbox-close" onclick="closeLightbox()"></button>
                </div>

                <div class="lightbox-main">
                    <button class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1)"></button>
                    <div id="lightboxMediaContainer">
                    </div>
                    <button class="lightbox-nav lightbox-next" onclick="navigateLightbox(1)"></button>
                </div>

                <div class="lightbox-footer">
                    <div class="lightbox-thumbnails" id="lightboxStrip">
                    </div>
                </div>
            </div>

            <!-- Reaction Menu -->
            <div id="reactionMenu" class="reaction-menu">
                <div class="reaction-emoji" onclick="addReaction('')"></div>
                <div class="reaction-emoji" onclick="addReaction('')"></div>
                <div class="reaction-emoji" onclick="addReaction('')"></div>
                <div class="reaction-emoji" onclick="addReaction('')"></div>
                <div class="reaction-emoji" onclick="addReaction('')"></div>
                <div class="reaction-emoji" onclick="addReaction('')"></div>
            </div>
            <script>
                // Ensure YouTube API is loaded before any initialization
var YT;
var onYouTubeIframeAPIReady;

(function() {
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
})();
                // YouTube API Configuration
                const YOUTUBE_API_KEY = 'AIzaSyBiVCOrKMTbh1gVEpevbbJ_5EDewv7q_dI';
                // Voice visualizer configuration
                const VOICE_VIZ_CONFIG = {
                    minHeight: 8,        // Minimum bar height in pixels
                    maxHeight: 40,       // Maximum bar height in pixels
                    smoothing: 0.3,      // 0 = no smoothing, 1 = maximum smoothing
                    sensitivity: 1.2,    // Multiplier for amplification (1 = normal, >1 = more sensitive)
                    barCount: 12,        // Number of bars
                    fftSize: 256         // FFT size (128, 256, 512, 1024, 2048)
                };
                // Mock Data
                const mockUsers = [
                    { id: 1, name: "Sarah Chen", avatar: "https://i.pravatar.cc/150?img=1", online: true },
                    { id: 2, name: "Mike Johnson", avatar: "https://i.pravatar.cc/150?img=2", online: false },
                    { id: 3, name: "Emily Davis", avatar: "https://i.pravatar.cc/150?img=3", online: true },
                    { id: 4, name: "David Lee", avatar: "https://i.pravatar.cc/150?img=4", online: false },
                    { id: 5, name: "Anna Martinez", avatar: "https://i.pravatar.cc/150?img=5", online: true },
                    { id: 'me', name: "You", avatar: "https://i.pravatar.cc/150?img=11", online: true }
                ];

                const mockConversations = [
                    { id: 1, userId: 1, userName: "Sarah Chen", avatar: "https://i.pravatar.cc/150?img=1", lastMessage: "Hey! Did you finish the math assignment?", timestamp: new Date(Date.now() - 5 * 60000), unread: 2, online: true },
                    { id: 2, userId: 2, userName: "Mike Johnson", avatar: "https://i.pravatar.cc/150?img=2", lastMessage: "Thanks for the study notes!", timestamp: new Date(Date.now() - 30 * 60000), unread: 0, online: false },
                    { id: 3, userId: 3, userName: "Emily Davis", avatar: "https://i.pravatar.cc/150?img=3", lastMessage: "Can you help me with physics?", timestamp: new Date(Date.now() - 2 * 60 * 60000), unread: 1, online: true },
                    { id: 4, userId: 4, userName: "David Lee", avatar: "https://i.pravatar.cc/150?img=4", lastMessage: "See you in class tomorrow!", timestamp: new Date(Date.now() - 24 * 60 * 60000), unread: 0, online: false },
                    { id: 5, userId: 5, userName: "Anna Martinez", avatar: "https://i.pravatar.cc/150?img=5", lastMessage: "The biology project looks great!", timestamp: new Date(Date.now() - 48 * 60 * 60000), unread: 0, online: true }
                ];

                const mockMessages = {
                    1: [{ id: 1, senderId: 1, text: "Hi! How are you doing?", timestamp: new Date(Date.now() - 60 * 60000), type: "text" }, { id: 2, senderId: "me", text: "I'm good! Working on the assignment.", timestamp: new Date(Date.now() - 55 * 60000), type: "text" }, { id: 3, senderId: 1, text: "Which one? The math homework?", timestamp: new Date(Date.now() - 50 * 60000), type: "text" }, { id: 4, senderId: "me", text: "Yes, the calculus problems.", timestamp: new Date(Date.now() - 45 * 60000), type: "text" }, { id: 5, senderId: 1, text: "Hey! Did you finish the math assignment?", timestamp: new Date(Date.now() - 5 * 60000), type: "text" }],
                    2: [{ id: 8, senderId: 2, text: "Hey, do you have the notes from yesterday?", timestamp: new Date(Date.now() - 120 * 60000), type: "text" }, { id: 9, senderId: "me", text: "Sure, let me share them with you.", timestamp: new Date(Date.now() - 110 * 60000), type: "text" }, { id: 10, senderId: "me", text: "Here are the notes ", timestamp: new Date(Date.now() - 100 * 60000), type: "text" }, { id: 11, senderId: 2, text: "Thanks for the study notes!", timestamp: new Date(Date.now() - 30 * 60000), type: "text" }],
                    3: [{ id: 12, senderId: 3, text: "I'm struggling with the physics chapter.", timestamp: new Date(Date.now() - 150 * 60000), type: "text" }, { id: 13, senderId: "me", text: "Which topic specifically?", timestamp: new Date(Date.now() - 140 * 60000), type: "text" }, { id: 14, senderId: 3, text: "Thermodynamics and heat transfer.", timestamp: new Date(Date.now() - 130 * 60000), type: "text" }, { id: 16, senderId: 3, text: "Can you help me with physics?", timestamp: new Date(Date.now() - 2 * 60 * 60000), type: "text" }],
                    4: [{ id: 17, senderId: 4, text: "Want to study together this weekend?", timestamp: new Date(Date.now() - 30 * 60 * 60000), type: "text" }, { id: 18, senderId: "me", text: "Sure! Saturday afternoon?", timestamp: new Date(Date.now() - 29 * 60 * 60000), type: "text" }, { id: 19, senderId: 4, text: "Perfect! Library at 2 PM?", timestamp: new Date(Date.now() - 28 * 60 * 60000), type: "text" }, { id: 20, senderId: "me", text: "Sounds good! See you there.", timestamp: new Date(Date.now() - 27 * 60 * 60000), type: "text" }, { id: 21, senderId: 4, text: "See you in class tomorrow!", timestamp: new Date(Date.now() - 24 * 60 * 60000), type: "text" }],
                    5: [{ id: 22, senderId: 5, text: "I finished my part of the project!", timestamp: new Date(Date.now() - 50 * 60 * 60000), type: "text" }, { id: 23, senderId: "me", text: "Awesome! Let me check it out.", timestamp: new Date(Date.now() - 49 * 60 * 60000), type: "text" }, { id: 24, senderId: "me", text: "The biology project looks great!", timestamp: new Date(Date.now() - 48 * 60 * 60000), type: "text" }, { id: 25, senderId: 5, text: "Thanks! ", timestamp: new Date(Date.now() - 48 * 60 * 60000), type: "text" }]
                };

                const mockStories = [
                    { id: 1, userId: 1, userName: "Sarah Chen", avatar: "https://i.pravatar.cc/150?img=1", content: "Quick tip: Use flashcards for memorizing formulas! ", subject: "Study Tips", image: "https://images.unsplash.com/photo-1434030216411-0b793f4b4173?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 2 * 60 * 60000), viewed: false, youtubeVideo: null },
                    { id: 101, userId: 1, userName: "Sarah Chen", avatar: "https://i.pravatar.cc/150?img=1", content: "Also, drink plenty of water while studying! ", subject: "Health", image: "https://images.unsplash.com/photo-1548839140-29a749e1cf4d?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 1 * 60 * 60000), viewed: false, youtubeVideo: null },
                    { id: 2, userId: 3, userName: "Emily Davis", avatar: "https://i.pravatar.cc/150?img=3", content: "Just learned an amazing physics trick for solving kinematics problems!", subject: "Physics", image: "https://images.unsplash.com/photo-1636466497217-26a8cbeaf0aa?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 5 * 60 * 60000), viewed: false, youtubeVideo: null },
                    { id: 3, userId: 5, userName: "Anna Martinez", avatar: "https://i.pravatar.cc/150?img=5", content: "Biology hack: Use mnemonics to remember the Krebs cycle steps.", subject: "Biology", image: "https://images.unsplash.com/photo-1532094349884-543bc11b234d?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 8 * 60 * 60000), viewed: true, youtubeVideo: null },
                    { id: 301, userId: 5, userName: "Anna Martinez", avatar: "https://i.pravatar.cc/150?img=5", content: "Look at these cells under the microscope! ", subject: "Lab", image: "https://images.unsplash.com/photo-1576086213369-97a306d36557?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 7 * 60 * 60000), viewed: true, youtubeVideo: null },
                    { id: 4, userId: 2, userName: "Mike Johnson", avatar: "https://i.pravatar.cc/150?img=2", content: "Found a great online resource for calculus practice problems!", subject: "Math", image: "https://images.unsplash.com/photo-1635070041078-e363dbe005cb?auto=format&fit=crop&w=400&q=80", timestamp: new Date(Date.now() - 12 * 60 * 60000), viewed: false, youtubeVideo: null }
                ];
                // Enhanced touch/swipe navigation
                let touchStartX = 0;
                let touchEndX = 0;
                let touchStartTime = 0;
                let isDragging = false;

                function handleTouchStart(e) {
                    // Check if touch started on an interactive element
                    const target = e.target;
                    if (target.closest('.story-like-btn') ||
                        target.closest('.story-comment-btn') ||
                        target.closest('.story-comment-box') ||
                        target.closest('.story-interactions')) {
                        return; // Don't initiate swipe on interactive elements
                    }

                    touchStartX = e.changedTouches[0].screenX;
                    touchStartTime = Date.now();
                }

                function handleTouchMove(e) {
                    touchEndX = e.changedTouches[0].screenX;
                }

                function handleTouchEnd() {
                    const touchDiff = touchStartX - touchEndX;
                    const touchDuration = Date.now() - touchStartTime;
                    const velocity = Math.abs(touchDiff) / touchDuration;

                    // Minimum swipe distance (50px) or fast swipe (velocity)
                    if (Math.abs(touchDiff) > 50 || velocity > 0.5) {
                        if (touchDiff > 0) {
                            // Swipe left -> Next story
                            nextStory();
                        } else {
                            // Swipe right -> Previous story
                            prevStory();
                        }
                    }

                    touchStartX = 0;
                    touchEndX = 0;
                }

                function handleMouseDown(e) {
                    // Check if click started on an interactive element
                    const target = e.target;
                    if (target.closest('.story-like-btn') ||
                        target.closest('.story-comment-btn') ||
                        target.closest('.story-comment-box') ||
                        target.closest('.story-interactions')) {
                        return; // Don't initiate drag on interactive elements
                    }

                    isDragging = true;
                    touchStartX = e.screenX;
                    touchStartTime = Date.now();
                    e.currentTarget.style.cursor = 'grabbing';
                }

                function handleMouseMove(e) {
                    if (isDragging) {
                        touchEndX = e.screenX;
                    }
                }

                function handleMouseUp(e) {
                    if (isDragging) {
                        const touchDiff = touchStartX - touchEndX;
                        const touchDuration = Date.now() - touchStartTime;
                        const velocity = Math.abs(touchDiff) / touchDuration;

                        if (Math.abs(touchDiff) > 50 || velocity > 0.5) {
                            if (touchDiff > 0) {
                                nextStory();
                            } else {
                                prevStory();
                            }
                        }

                        isDragging = false;
                        e.currentTarget.style.cursor = 'grab';
                        touchStartX = 0;
                        touchEndX = 0;
                    }
                }

                function handleMouseLeave(e) {
                    if (isDragging) {
                        isDragging = false;
                        e.currentTarget.style.cursor = 'grab';
                    }
                }
                let conversations = [...mockConversations];
                let messages = JSON.parse(JSON.stringify(mockMessages));
                let stories = [...mockStories];
                let selectedChat = null;
                let disappearingMode = null;
                let isRecording = false;
                let mediaRecorder = null;
                let audioChunks = [];
                let storyQueue = [];
                let storyQueueIndex = 0;
                let storyTimer = null;
                let progressAnimationFrame = null;
                let searchTimeout;
                let currentSearchController = null;
                let selectedVideoForTimeRange = null;
                let currentYouTubePlayer = null;
                let audioProgressInterval = null;
                const STORY_DURATION = 30000; // Fixed 30 seconds for story display

                function openAddStoryModal() {
                    const modal = document.getElementById('addStoryModal');
                    modal.classList.remove('closing');
                    modal.style.display = 'flex';
                    setTimeout(() => modal.classList.add('active'), 10);
                }

                function closeAddStoryModal() {
                    const modal = document.getElementById('addStoryModal');
                    modal.classList.remove('active');
                    modal.classList.add('closing');
                    setTimeout(() => {
                        modal.style.display = 'none';
                        modal.classList.remove('closing');
                        document.getElementById('storySubject').value = '';
                        document.getElementById('storyContent').value = '';
                        document.getElementById('spotifySearchQuery').value = '';
                        document.getElementById('selectedTrackData').value = '';
                        document.getElementById('spotifyResults').classList.add('hidden');
                        removeMedia();
                        removeTimeRangeSelector();
                    }, 450);
                }

                function submitStory(e) {
                    e.preventDefault();
                    const newStory = {
                        id: Date.now(),
                        userId: 'me',
                        userName: 'You',
                        avatar: 'https://i.pravatar.cc/150?img=11',
                        content: document.getElementById('storyContent').value,
                        subject: document.getElementById('storySubject').value,
                        timestamp: new Date(),
                        viewed: false,
                        likes: 0,
                        liked: false,
                        youtubeVideo: document.getElementById('selectedTrackData').value ? JSON.parse(document.getElementById('selectedTrackData').value) : null,
                        media: document.getElementById('uploadedMediaData').value ? JSON.parse(document.getElementById('uploadedMediaData').value) : null
                    };
                    stories.unshift(newStory);
                    renderStories();
                    closeAddStoryModal();
                    removeMedia();
                }

                function openStory(userId) {
                    // Convert userId to string for comparison
                    const userIdStr = String(userId);
                    const userStories = stories.filter(s => String(s.userId) === userIdStr);

                    if (!userStories.length) return;

                    let startStory = userStories.find(s => !s.viewed) || userStories[0];
                    storyQueue = [...stories];
                    storyQueueIndex = storyQueue.findIndex(s => s.id === startStory.id);
                    if (storyQueueIndex === -1) storyQueueIndex = 0;

                    const modal = document.getElementById('storyModal');
                    modal.classList.add('active');
                    modal.style.display = 'flex';

                    // Add comment box if not exists
                    addCommentBoxToModal();

                    initCarousel();
                    updateCarousel();
                    startStoryTimer();
                    initStoryNavigation();
                    updateNavigationArrows();
                }

                function renderStoryCard(story) {
                    let mediaHTML = '', audioHTML = '';

// Inside renderStoryCard() function, replace the audioHTML section:
if (story.youtubeVideo) {
    const { id, title } = story.youtubeVideo;
    const uniqueId = `youtube-player-${story.id}`;
    audioHTML = `
        <div class="story-audio-player">
            <div class="audio-track-info">
                <div class="audio-details">
                    <div class="audio-title">${escapeHtml(title)}</div>
                </div>
            </div>
            <div id="${uniqueId}"></div>
        </div>`;
}
                    if (story.media) {
                        mediaHTML = story.media.type === 'image'
                            ? `<div class="story-media-container"><img src="${story.media.data}" alt="Story media" /></div>`
                            : `<div class="story-media-container"><video src="${story.media.data}" controls playsinline></video></div>`;
                    } else if (story.image) {
                        mediaHTML = `<div class="story-media-container"><img src="${story.image}" alt="Story content" /></div>`;
                    }

                    if (story.youtubeVideo) {
                        const { id, title } = story.youtubeVideo;
                        const uniqueId = `Youtubeer-${story.id}`;
                        audioHTML = `
            <div class="story-audio-player">
                <div class="audio-track-info">
                    <div class="audio-details">
                        <div class="audio-title">${escapeHtml(title)}</div>
                    </div>
                </div>
                <div id="${uniqueId}" style="display:none;"></div>
            </div>`;
                    }
                    // ... (End existing media logic) ...

                    const likeBtnClass = story.liked ? 'liked' : '';
                    const likeIcon = story.liked ? 'fas fa-heart' : 'far fa-heart';
                    const likeCount = story.likes || 0;

                    // UPDATED HTML STRUCTURE FOR BUTTONS
                    return `
        <div class="story-content-wrapper">
            <div class="story-header-info">
                <img src="${story.avatar}" alt="${story.userName}">
                <div class="user-info">
                    <h4>${story.userName}</h4>
                    <div class="story-timestamp">${formatTime(story.timestamp)}</div>
                </div>
            </div>
            ${mediaHTML}
            ${audioHTML}

            <div class="story-interactions">
                <div class="story-like-btn ${likeBtnClass}" 
                     onmousedown="stopEvent(event)" 
                     ontouchstart="stopEvent(event)"
                     onclick="safeLike(${story.id}, event)">
                    <i class="${likeIcon}"></i>
                </div>
                ${likeCount > 0 ? `<div class="like-count">${likeCount}</div>` : ''}
                
                <button class="story-comment-btn" 
                        onmousedown="stopEvent(event)" 
                        ontouchstart="stopEvent(event)"
                        onclick="safeComment(${story.id}, event)">
                    <i class="fas fa-comment"></i>
                </button>
            </div>

            <div class="story-text-content">
                <span class="story-subject-badge">${story.subject}</span>
                <div class="story-text" style="font-size: 16px;">${story.content}</div>
            </div>
        </div>
    `;
                }
                // Helper to kill events immediately
                function stopEvent(e) {
                    if (!e) return;
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }

                // Wrapper for Like logic
                function safeLike(storyId, event) {
                    stopEvent(event); // Kill bubbling
                    toggleLike(storyId); // Call logic
                }

                // Wrapper for Comment logic
                function safeComment(storyId, event) {
                    stopEvent(event); // Kill bubbling
                    toggleCommentBox(storyId, event); // Call logic
                }

                function toggleLike(storyId) {
                    // Find story by ID
                    const storyIndex = stories.findIndex(s => s.id === storyId);
                    if (storyIndex === -1) return;

                    const story = stories[storyIndex];
                    story.liked = !story.liked;
                    story.likes = (story.likes || 0) + (story.liked ? 1 : -1);

                    // Update UI ONLY in the specific card to avoid re-rendering entire carousel
                    // This prevents "jumping" issues
                    const storyCard = document.getElementById(`story-card-${storyQueueIndex}`);

                    // Check if the currently active card matches the story ID we just liked
                    // This handles the edge case where ID matching might be off
                    if (storyCard) {
                        const likeBtn = storyCard.querySelector('.story-like-btn');
                        if (likeBtn) {
                            likeBtn.classList.toggle('liked', story.liked);
                            const icon = likeBtn.querySelector('i');
                            if (icon) icon.className = story.liked ? 'fas fa-heart' : 'far fa-heart';
                        }

                        // Update count
                        let likeCountEl = storyCard.querySelector('.like-count');
                        if (story.likes > 0) {
                            if (!likeCountEl) {
                                const interactions = storyCard.querySelector('.story-interactions');
                                const btn = storyCard.querySelector('.story-like-btn');
                                likeCountEl = document.createElement('div');
                                likeCountEl.className = 'like-count';
                                interactions.insertBefore(likeCountEl, btn.nextSibling);
                            }
                            likeCountEl.textContent = story.likes;
                        } else if (likeCountEl) {
                            likeCountEl.remove();
                        }
                    }
                }
                function initCarousel() {
                    const container = document.getElementById('storyCarousel');
                    if (!container) return;
                    container.innerHTML = '';

                    // Progress bars
                    const progressContainer = document.createElement('div');
                    progressContainer.className = 'story-progress-container';
                    progressContainer.innerHTML = storyQueue.map((_, i) =>
                        `<div class="story-progress-bar">
            <div class="story-progress-fill" id="progress-${i}"></div>
        </div>`
                    ).join('');
                    container.appendChild(progressContainer);

                    // Story cards
                    storyQueue.forEach((story, idx) => {
                        const el = document.createElement('div');
                        el.className = 'story-card hidden-right';
                        el.id = `story-card-${idx}`;
                        el.innerHTML = renderStoryCard(story);
                        container.appendChild(el);
                    });
                }

                function nextStory() {
                    // Safely destroy YouTube player
                    if (currentYouTubePlayer) {
                        try {
                            if (typeof currentYouTubePlayer.pauseVideo === 'function') {
                                currentYouTubePlayer.pauseVideo();
                            }
                            if (typeof currentYouTubePlayer.destroy === 'function') {
                                currentYouTubePlayer.destroy();
                            }
                        } catch (e) {
                            console.log('Error destroying player:', e);
                        }
                        currentYouTubePlayer = null;
                    }

                    if (audioProgressInterval) {
                        clearInterval(audioProgressInterval);
                        audioProgressInterval = null;
                    }

                    if (storyQueueIndex < storyQueue.length - 1) {
                        storyQueueIndex++;
                        updateCarousel();
                        startStoryTimer();
                        updateNavigationArrows();
                    } else {
                        closeStory();
                    }
                }

                function prevStory() {
                    // Safely destroy YouTube player
                    if (currentYouTubePlayer) {
                        try {
                            if (typeof currentYouTubePlayer.pauseVideo === 'function') {
                                currentYouTubePlayer.pauseVideo();
                            }
                            if (typeof currentYouTubePlayer.destroy === 'function') {
                                currentYouTubePlayer.destroy();
                            }
                        } catch (e) {
                            console.log('Error destroying player:', e);
                        }
                        currentYouTubePlayer = null;
                    }

                    if (audioProgressInterval) {
                        clearInterval(audioProgressInterval);
                        audioProgressInterval = null;
                    }

                    if (storyQueueIndex > 0) {
                        storyQueueIndex--;
                        updateCarousel();
                        startStoryTimer();
                        updateNavigationArrows();
                    }
                }

                // Update sendStoryReply function
                function sendStoryReply(storyId, text) {
                    if (!text || !text.trim()) return;

                    const story = stories.find(s => s.id === storyId);
                    if (!story) return;

                    // Don't allow replying to your own story
                    if (story.userId === 'me') {
                        alert("You can't reply to your own story!");
                        return;
                    }

                    const userId = story.userId;

                    // Create new message
                    const msg = {
                        id: Date.now(),
                        senderId: 'me',
                        text: `Replied to story: ${text}`,
                        storyRef: storyId,
                        storyTitle: story.subject,
                        type: 'text',
                        timestamp: new Date()
                    };

                    if (!messages[userId]) messages[userId] = [];
                    messages[userId].push(msg);

                    // Update conversation list
                    let conv = conversations.find(c => c.userId == userId);
                    if (conv) {
                        conv.lastMessage = `Replied to story: ${text}`;
                        conv.timestamp = new Date();
                        conv.unread = 0;
                    } else {
                        conversations.unshift({
                            id: userId,
                            userId: userId,
                            userName: story.userName,
                            avatar: story.avatar,
                            lastMessage: `Replied to story: ${text}`,
                            timestamp: new Date(),
                            unread: 0,
                            online: true
                        });
                    }

                    // Clear input
                    const input = document.querySelector('.story-card.active .story-reply-input');
                    if (input) input.value = '';

                    // Show feedback
                    alert('Reply sent!');
                }

                function toggleLike(storyId, event) {
                    // CRITICAL: Prevent ALL event propagation
                    if (event) {
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        event.preventDefault();
                    }

                    const story = stories.find(s => s.id === storyId);
                    if (!story) return;

                    story.liked = !story.liked;
                    story.likes = (story.likes || 0) + (story.liked ? 1 : -1);

                    // Update UI in active card
                    const activeCard = document.querySelector('.story-card.active');
                    if (activeCard) {
                        const likeBtn = activeCard.querySelector('.story-like-btn');
                        if (likeBtn) {
                            likeBtn.classList.toggle('liked', story.liked);
                            const icon = likeBtn.querySelector('i');
                            if (icon) {
                                icon.className = story.liked ? 'fas fa-heart' : 'far fa-heart';
                            }
                        }

                        // Update like count
                        const likeCountEl = activeCard.querySelector('.like-count');
                        if (story.likes > 0) {
                            if (likeCountEl) {
                                likeCountEl.textContent = story.likes;
                            } else {
                                // Create like count if it doesn't exist
                                const interactions = activeCard.querySelector('.story-interactions');
                                const likeBtn = interactions.querySelector('.story-like-btn');
                                const countBadge = document.createElement('div');
                                countBadge.className = 'like-count';
                                countBadge.textContent = story.likes;
                                interactions.insertBefore(countBadge, likeBtn.nextSibling);
                            }
                        } else if (likeCountEl) {
                            likeCountEl.remove();
                        }
                    }
                }

                // Remove the navigation areas from HTML and let JS handle them
                // Update the story modal HTML section to remove navigation divs
                // The initCarousel function now adds them dynamically

                function closeStory() {
                    // Safely destroy YouTube player
                    if (currentYouTubePlayer) {
                        try {
                            if (typeof currentYouTubePlayer.pauseVideo === 'function') {
                                currentYouTubePlayer.pauseVideo();
                            }
                            if (typeof currentYouTubePlayer.destroy === 'function') {
                                currentYouTubePlayer.destroy();
                            }
                        } catch (e) {
                            console.log('Error destroying player:', e);
                        }
                        currentYouTubePlayer = null;
                    }

                    if (audioProgressInterval) {
                        clearInterval(audioProgressInterval);
                        audioProgressInterval = null;
                    }

                    // Close comment box
                    closeCommentBox();

                    document.getElementById('storyModal').classList.remove('active');
                    document.getElementById('storyModal').style.display = 'none';
                    clearTimeout(storyTimer);
                    if (progressAnimationFrame) cancelAnimationFrame(progressAnimationFrame);
                    progressAnimationFrame = null;
                    renderStories();
                }

                function toggleAudioPlayback(storyId) {
                    if (!currentYouTubePlayer) return;

                    try {
                        const btn = document.getElementById(`playPauseBtn-${storyId}`);
                        const icon = btn ? btn.querySelector('i') : null;

                        if (typeof currentYouTubePlayer.getPlayerState !== 'function') return;

                        const state = currentYouTubePlayer.getPlayerState();

                        if (state === 1) { // Playing
                            if (typeof currentYouTubePlayer.pauseVideo === 'function') {
                                currentYouTubePlayer.pauseVideo();
                            }
                            if (icon) icon.className = 'fas fa-play';
                        } else { // Paused or not started
                            if (typeof currentYouTubePlayer.playVideo === 'function') {
                                currentYouTubePlayer.playVideo();
                            }
                            if (icon) icon.className = 'fas fa-pause';
                        }
                    } catch (e) {
                        console.log('Error toggling playback:', e);
                    }
                }

                function setVolume(storyId, volume) {
                    if (!currentYouTubePlayer) return;

                    try {
                        if (typeof currentYouTubePlayer.setVolume === 'function') {
                            currentYouTubePlayer.setVolume(volume);
                        }
                    } catch (e) {
                        console.log('Error setting volume:', e);
                    }
                }

                function updateAudioProgress(storyId, currentTime, duration) {
                    const progressBar = document.getElementById(`audioProgress-${storyId}`);
                    const currentTimeDisplay = document.getElementById(`audioCurrentTime-${storyId}`);

                    if (progressBar && currentTimeDisplay) {
                        const percentage = (currentTime / duration) * 100;
                        progressBar.style.width = `${percentage}%`;
                        currentTimeDisplay.textContent = formatSeconds(Math.floor(currentTime));
                    }
                }

                function initCarousel() {
                    const container = document.getElementById('storyCarousel');
                    if (!container) return;
                    container.innerHTML = '';

                    // Progress bars
                    const progressContainer = document.createElement('div');
                    progressContainer.className = 'story-progress-container';
                    progressContainer.innerHTML = storyQueue.map((_, i) => `<div class="story-progress-bar"><div class="story-progress-fill" id="progress-${i}"></div></div>`).join('');
                    container.appendChild(progressContainer);

                    // Story cards
                    storyQueue.forEach((story, idx) => {
                        const el = document.createElement('div');
                        el.className = 'story-card hidden-right';
                        el.id = `story-card-${idx}`;
                        el.innerHTML = renderStoryCard(story);
                        container.appendChild(el);
                    });

                    // NO navigation areas - only swipe/scroll
                }

                function updateProgressBars() {
                    storyQueue.forEach((_, idx) => {
                        const fill = document.getElementById(`progress-${idx}`);
                        if (!fill) return;
                        fill.classList.remove('active', 'completed');
                        fill.style.width = '0%';
                        if (idx < storyQueueIndex) {
                            fill.classList.add('completed');
                            fill.style.width = '100%';
                        } else if (idx === storyQueueIndex) {
                            fill.classList.add('active');
                            animateProgress(fill, STORY_DURATION);
                        }
                    });
                }

                function animateProgress(el, dur) {
                    let start = null;
                    const animate = (ts) => {
                        if (!start) start = ts;
                        const prog = (ts - start) / dur;
                        el.style.width = `${Math.min(prog * 100, 100)}%`;
                        if (prog < 1 && document.getElementById('storyModal').classList.contains('active')) {
                            progressAnimationFrame = requestAnimationFrame(animate);
                        }
                    };
                    progressAnimationFrame = requestAnimationFrame(animate);
                }

                function updateCarousel() {
                    const story = storyQueue[storyQueueIndex];
                    if (story) {
                        story.viewed = true;
                        stories = stories.map(s => s.id === story.id ? { ...s, viewed: true } : s);
                    }

                    storyQueue.forEach((_, idx) => {
                        const el = document.getElementById(`story-card-${idx}`);
                        if (!el) return;
                        el.className = 'story-card';
                        if (idx === storyQueueIndex) el.classList.add('active');
                        else if (idx === storyQueueIndex - 1) el.classList.add('prev');
                        else if (idx === storyQueueIndex + 1) el.classList.add('next');
                        else if (idx < storyQueueIndex) el.classList.add('hidden-left');
                        else el.classList.add('hidden-right');
                    });

                    updateProgressBars();

                    // Initialize YouTube player if story has video
                    if (story && story.youtubeVideo) {
                        initYouTubePlayer(story);
                    }
                }

function initYouTubePlayer(story) {
    if (!story.youtubeVideo) return;

    const { id, startTime = 0, endTime = 30 } = story.youtubeVideo;
    const playerId = `youtube-player-${story.id}`;
    const clipDuration = endTime - startTime;

    // Wait for YouTube API
    if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
        console.error('YouTube API not ready');
        return;
    }

    // Clean up existing player
    if (currentYouTubePlayer) {
        try {
            currentYouTubePlayer.destroy();
        } catch (e) {
            console.log('Error destroying player:', e);
        }
        currentYouTubePlayer = null;
    }

    // Small delay to ensure DOM is ready
    setTimeout(() => {
        try {
            currentYouTubePlayer = new YT.Player(playerId, {
                height: '0',
                width: '0',
                videoId: id,
                playerVars: {
                    autoplay: 1,
                    controls: 0,
                    start: startTime,
                    end: endTime,
                    modestbranding: 1,
                    rel: 0,
                    enablejsapi: 1
                },
                events: {
                    onReady: (event) => {
                        console.log('Story player ready');
                        event.target.setVolume(80);
                        event.target.playVideo();

                        const btn = document.getElementById(`playPauseBtn-${story.id}`);
                        if (btn) {
                            const icon = btn.querySelector('i');
                            if (icon) icon.className = 'fas fa-pause';
                        }
                    },
                    onStateChange: (event) => {
                        const btn = document.getElementById(`playPauseBtn-${story.id}`);
                        const icon = btn ? btn.querySelector('i') : null;

                        if (event.data === YT.PlayerState.PLAYING) {
                            if (icon) icon.className = 'fas fa-pause';

                            if (audioProgressInterval) clearInterval(audioProgressInterval);
                            audioProgressInterval = setInterval(() => {
                                try {
                                    if (currentYouTubePlayer && typeof currentYouTubePlayer.getCurrentTime === 'function') {
                                        const currentTime = currentYouTubePlayer.getCurrentTime() - startTime;
                                        updateAudioProgress(story.id, currentTime, clipDuration);
                                    }
                                } catch (e) {
                                    console.log('Progress update error:', e);
                                }
                            }, 100);
                        } else if (event.data === YT.PlayerState.PAUSED) {
                            if (icon) icon.className = 'fas fa-play';
                            if (audioProgressInterval) clearInterval(audioProgressInterval);
                        } else if (event.data === YT.PlayerState.ENDED) {
                            if (icon) icon.className = 'fas fa-play';
                            if (audioProgressInterval) clearInterval(audioProgressInterval);
                            event.target.seekTo(startTime);
                            updateAudioProgress(story.id, 0, clipDuration);
                        }
                    },
                    onError: (event) => {
                        console.error('YouTube player error:', event.data);
                        // Error codes: 2=invalid ID, 5=HTML5 error, 100=not found, 101/150=embed disabled
                        const errorMessages = {
                            2: 'Invalid video ID',
                            5: 'Playback error',
                            100: 'Video not found',
                            101: 'Video owner disabled embedding',
                            150: 'Video owner disabled embedding'
                        };
                        console.error('Error message:', errorMessages[event.data] || 'Unknown error');
                    }
                }
            });
        } catch (e) {
            console.error('Error creating YouTube player:', e);
            currentYouTubePlayer = null;
        }
    }, 200);
}

                function startStoryTimer() {
                    clearTimeout(storyTimer);
                    if (progressAnimationFrame) cancelAnimationFrame(progressAnimationFrame);
                    storyTimer = setTimeout(nextStory, STORY_DURATION);
                }
                let isInteracting = false; // New flag to track if we are clicking a button

                function initStoryNavigation() {
                    const carousel = document.getElementById('storyCarousel');
                    if (!carousel) return;

                    // Clean up old listeners to prevent duplicates
                    const clone = carousel.cloneNode(true);
                    carousel.parentNode.replaceChild(clone, carousel);
                    const newCarousel = document.getElementById('storyCarousel');

                    // Attach fresh listeners
                    newCarousel.addEventListener('touchstart', handleTouchStart, { passive: false });
                    newCarousel.addEventListener('touchmove', handleTouchMove, { passive: false });
                    newCarousel.addEventListener('touchend', handleTouchEnd);

                    newCarousel.addEventListener('mousedown', handleMouseDown);
                    newCarousel.addEventListener('mousemove', handleMouseMove);
                    newCarousel.addEventListener('mouseup', handleMouseUp);
                    newCarousel.addEventListener('mouseleave', handleMouseLeave);
                }

                function isInteractiveElement(target) {
                    // Check if the target or its parents are interactive buttons/inputs
                    return target.closest('.story-like-btn') ||
                        target.closest('.story-comment-btn') ||
                        target.closest('.story-comment-box') ||
                        target.closest('.story-reply-input') ||
                        target.closest('.video-control-btn') ||
                        target.tagName === 'INPUT' ||
                        target.tagName === 'BUTTON';
                }

                // --- TOUCH HANDLERS ---

                function handleTouchStart(e) {
                    if (isInteractiveElement(e.target)) {
                        isInteracting = true;
                        return; // Don't start swipe logic
                    }
                    isInteracting = false;
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartTime = Date.now();
                }

                function handleTouchMove(e) {
                    if (isInteracting) return;
                    touchEndX = e.changedTouches[0].screenX;
                    // Optional: Prevent page scroll while swiping story
                    // e.preventDefault(); 
                }

                function handleTouchEnd(e) {
                    if (isInteracting) {
                        isInteracting = false;
                        return;
                    }

                    const touchDiff = touchStartX - touchEndX;
                    const touchDuration = Date.now() - touchStartTime;
                    const velocity = Math.abs(touchDiff) / touchDuration;

                    // Threshold: Move at least 50px OR flick fast
                    if (Math.abs(touchDiff) > 50 || (Math.abs(touchDiff) > 20 && velocity > 0.5)) {
                        if (touchDiff > 0) {
                            nextStory();
                        } else {
                            prevStory();
                        }
                    }

                    // Reset
                    touchStartX = 0;
                    touchEndX = 0;
                }

                // --- MOUSE HANDLERS ---

                function handleMouseDown(e) {
                    if (isInteractiveElement(e.target)) {
                        isInteracting = true;
                        return;
                    }
                    isInteracting = false;
                    isDragging = true;
                    touchStartX = e.screenX;
                    touchStartTime = Date.now();
                    e.currentTarget.style.cursor = 'grabbing';
                }

                function handleMouseMove(e) {
                    if (!isDragging || isInteracting) return;
                    e.preventDefault();
                    touchEndX = e.screenX;
                }

                function handleMouseUp(e) {
                    if (isInteracting) {
                        isInteracting = false;
                        isDragging = false;
                        return;
                    }

                    if (isDragging) {
                        const touchDiff = touchStartX - touchEndX;
                        // Only navigate if actually dragged
                        if (touchStartX !== 0 && Math.abs(touchDiff) > 50) {
                            if (touchDiff > 0) {
                                nextStory();
                            } else {
                                prevStory();
                            }
                        }

                        isDragging = false;
                        e.currentTarget.style.cursor = 'default'; // Reset cursor
                        touchStartX = 0;
                        touchEndX = 0;
                    }
                }

                function handleMouseLeave(e) {
                    isDragging = false;
                    isInteracting = false;
                    e.currentTarget.style.cursor = 'default';
                }
                function handleTouchStart(e) { touchStartX = e.changedTouches[0].screenX; }
                function handleTouchMove(e) { touchEndX = e.changedTouches[0].screenX; }
                function handleTouchEnd() { handleSwipe(); }
                function handleMouseDown(e) { isDragging = true; touchStartX = e.screenX; e.currentTarget.style.cursor = 'grabbing'; e.currentTarget.style.pointerEvents = 'none'; }
                function handleMouseMove(e) { if (isDragging) touchEndX = e.screenX; }
                function handleMouseUp(e) { if (isDragging) { isDragging = false; e.currentTarget.style.cursor = 'grab'; handleSwipe(); } }
                function handleMouseLeave(e) { if (isDragging) { isDragging = false; e.currentTarget.style.cursor = 'grab'; } }
                function handleSwipe() {
                    const diff = touchStartX - touchEndX;
                    if (Math.abs(diff) > 50) diff > 0 ? nextStory() : prevStory();
                    touchStartX = 0; touchEndX = 0;
                }
                // Enhanced keyboard navigation with smooth transitions
                function handleKeyPress(e) {
                    const modal = document.getElementById('storyModal');
                    if (!modal || modal.style.display !== 'flex') return;

                    // Prevent default arrow key scrolling
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                        e.preventDefault();
                    }

                    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                        prevStory();
                    } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                        nextStory();
                    } else if (e.key === 'Escape') {
                        closeStory();
                    }
                }
                // Trackpad/Mouse Wheel Navigation
                let wheelTimeout;
                let isWheeling = false;

                function handleWheelNavigation(e) {
                    const modal = document.getElementById('storyModal');
                    if (!modal || modal.style.display !== 'flex') return;

                    // Prevent default scrolling
                    e.preventDefault();

                    // Debounce to prevent too many rapid changes
                    if (isWheeling) return;

                    const deltaX = e.deltaX;
                    const deltaY = e.deltaY;

                    // Determine if it's horizontal or vertical scroll
                    const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);
                    const scrollAmount = isHorizontal ? deltaX : deltaY;

                    // Threshold to trigger navigation (adjust sensitivity here)
                    const threshold = 30;

                    if (Math.abs(scrollAmount) > threshold) {
                        isWheeling = true;

                        if (scrollAmount > 0) {
                            // Scroll right/down -> Next story
                            nextStory();
                        } else {
                            // Scroll left/up -> Previous story
                            prevStory();
                        }

                        // Reset wheeling flag after delay
                        clearTimeout(wheelTimeout);
                        wheelTimeout = setTimeout(() => {
                            isWheeling = false;
                        }, 600); // Adjust delay between transitions
                    }
                }

                // Add wheel listener to story modal
                function initWheelNavigation() {
                    const modal = document.getElementById('storyModal');
                    if (modal) {
                        modal.addEventListener('wheel', handleWheelNavigation, { passive: false });
                    }
                }

                // Initialize when DOM is ready
                document.addEventListener('DOMContentLoaded', () => {
                    initWheelNavigation();
                    // ... your existing DOMContentLoaded code
                });
                // Register keyboard listener
                document.addEventListener('keydown', handleKeyPress);

                function updateNavigationArrows() {
                    const left = document.querySelector('.arrow-left');
                    const right = document.querySelector('.arrow-right');
                    if (left && right) {
                        storyQueueIndex === 0 ? left.classList.add('disabled') : left.classList.remove('disabled');
                        storyQueueIndex === storyQueue.length - 1 ? right.classList.add('disabled') : right.classList.remove('disabled');
                    }
                }

                function setupLiveYouTubeSearch() {
                    document.getElementById('spotifySearchQuery').addEventListener('input', function (e) {
                        const query = e.target.value.trim();
                        clearTimeout(searchTimeout);
                        if (currentSearchController) currentSearchController.abort();
                        if (query.length < 2) {
                            document.getElementById('spotifyResults').classList.add('hidden');
                            return;
                        }
                        searchTimeout = setTimeout(() => performLiveYouTubeSearch(query), 500);
                    });
                }

                async function performLiveYouTubeSearch(query) {
                    const results = document.getElementById('spotifyResults');
                    results.classList.remove('hidden');
                    results.innerHTML = '<div style="padding:20px;text-align:center;"><div style="width:40px;height:40px;border:4px solid rgba(255,255,255,0.1);border-top-color:#FF0000;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto;"></div></div>';
                    currentSearchController = new AbortController();

                    try {
                        const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&videoCategoryId=10&maxResults=8&key=${YOUTUBE_API_KEY}`, { signal: currentSearchController.signal });
                        if (!res.ok) throw new Error('API error');
                        const data = await res.json();
                        const ids = data.items.map(i => i.id.videoId).join(',');
                        const durRes = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails&id=${ids}&key=${YOUTUBE_API_KEY}`, { signal: currentSearchController.signal });
                        const durData = await durRes.json();
                        const durs = {};
                        durData.items.forEach(i => durs[i.id] = formatDuration(i.contentDetails.duration));

                        results.innerHTML = '';
                        if (data.items?.length) {
                            data.items.forEach(v => {
                                const el = document.createElement('div');
                                el.className = 'spotify-track-item';
                                el.onclick = () => selectYouTubeVideoEnhanced(v, el, durs[v.id.videoId]);
                                const dur = durs[v.id.videoId] || '...';
                                el.innerHTML = `<div class="track-icon"><i class="fab fa-youtube"></i></div><div class="track-info"><div class="track-title">${escapeHtml(v.snippet.title)}</div><div class="track-artist"><i class="fas fa-user" style="font-size:10px;"></i> ${escapeHtml(v.snippet.channelTitle)}${dur !== '...' ? ` <span class="track-duration"> ${dur}</span>` : ''}</div></div><div class="track-check"><i class="fas fa-check"></i></div>`;
                                results.appendChild(el);
                            });
                        } else {
                            results.innerHTML = '<div style="padding:40px 20px;text-align:center;color:rgba(255,255,255,0.5);"><i class="fas fa-search" style="font-size:48px;margin-bottom:15px;opacity:0.3;"></i><div>No videos found</div><div style="font-size:12px;margin-top:5px;">Try different keywords</div></div>';
                        }
                    } catch (err) {
                        if (err.name === 'AbortError') return;
                        results.innerHTML = '<div style="padding:40px 20px;text-align:center;"><i class="fas fa-exclamation-triangle" style="font-size:48px;color:#ff6b6b;margin-bottom:15px;"></i><div style="color:#ff6b6b;">Search failed</div></div>';
                    }
                }

                function selectYouTubeVideoEnhanced(video, el, duration) {
                    document.querySelectorAll('.spotify-track-item').forEach(i => i.classList.remove('selected'));
                    el.classList.add('selected');

                    selectedVideoForTimeRange = {
                        id: video.id.videoId,
                        title: video.snippet.title,
                        channel: video.snippet.channelTitle,
                        thumbnail: video.snippet.thumbnails.medium.url,
                        duration: duration
                    };

                    showTimeRangeSelector(selectedVideoForTimeRange);
                }

                function showTimeRangeSelector(video) {
                    removeTimeRangeSelector();

                    const totalSeconds = parseDurationToSeconds(video.duration);

                    const selector = document.createElement('div');
                    selector.className = 'time-range-selector';
                    selector.id = 'timeRangeSelector';
                    selector.innerHTML = `
        <div class="time-range-header">
            <h4><i class="fas fa-scissors"></i> Select Audio Clip</h4>
            <p>Choose up to 30 seconds from "${escapeHtml(video.title)}"</p>
        </div>
        
        <div class="time-inputs">
            <div class="time-input-group">
                <label>Start Time</label>
                <input type="number" id="startTimeInput" min="0" max="${totalSeconds - 1}" value="0" step="1" />
                <span class="time-unit">seconds</span>
            </div>
            <div class="time-input-group">
                <label>End Time</label>
                <input type="number" id="endTimeInput" min="1" max="${totalSeconds}" value="${Math.min(30, totalSeconds)}" step="1" />
                <span class="time-unit">seconds</span>
            </div>
        </div>
        
        <div class="time-presets">
            <button type="button" class="preset-btn" onclick="setPresetTime(0, 15)">First 15s</button>
            <button type="button" class="preset-btn" onclick="setPresetTime(0, 30)">First 30s</button>
            <button type="button" class="preset-btn" onclick="setPresetTime(${Math.max(0, totalSeconds - 30)}, ${totalSeconds})">Last 30s</button>
        </div>
        
        <div class="time-range-preview">
            <div class="preview-bar" id="timelinePreviewBar">
                <div class="preview-selection" id="previewSelection"></div>
            </div>
            <div class="preview-labels">
                <span>0:00</span>
                <span id="selectionLabel">0:00 - 0:30</span>
                <span>${video.duration}</span>
            </div>
        </div>

        <div class="preview-controls">
            <button type="button" class="btn-preview-audio" id="previewBtn" onclick="togglePreview()">
                <i class="fas fa-play"></i> Play Preview
            </button>
        </div>
        <div id="preview-player-container" style="display:none;"></div>
        
        <button type="button" class="btn-confirm-time" onclick="confirmTimeRange()">
            <i class="fas fa-check"></i> Confirm Selection
        </button>
    `;

                    const form = document.querySelector('.add-story-form');
                    const resultsDiv = document.getElementById('spotifyResults');
                    form.insertBefore(selector, resultsDiv);

                    const startInput = document.getElementById('startTimeInput');
                    const endInput = document.getElementById('endTimeInput');

                    startInput.addEventListener('input', updatePreview);
                    endInput.addEventListener('input', updatePreview);

                    updatePreview();

                    // Add interactive timeline listeners
                    const previewBar = document.getElementById('timelinePreviewBar');
                    if (previewBar) {
                        previewBar.addEventListener('mousedown', handleTimelineInteractionStart);
                        document.addEventListener('mousemove', handleTimelineInteractionMove);
                        document.addEventListener('mouseup', handleTimelineInteractionEnd);

                        // Touch support
                        previewBar.addEventListener('touchstart', handleTimelineInteractionStart, { passive: false });
                        document.addEventListener('touchmove', handleTimelineInteractionMove, { passive: false });
                        document.addEventListener('touchend', handleTimelineInteractionEnd);
                    }
                }

                let isDraggingTimeline = false;
                let timelineDragMode = 'move'; // 'move' or 'resize' - simplified to just move/set for now

                function handleTimelineInteractionStart(e) {
                    e.preventDefault(); // Prevent text selection
                    isDraggingTimeline = true;
                    handleTimelineInteractionMove(e);
                }

                function handleTimelineInteractionMove(e) {
                    if (!isDraggingTimeline) return;

                    // Handle both mouse and touch events
                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;

                    const previewBar = document.getElementById('timelinePreviewBar');
                    if (!previewBar) return;

                    const rect = previewBar.getBoundingClientRect();
                    const totalSeconds = parseDurationToSeconds(selectedVideoForTimeRange.duration);

                    // Calculate seconds based on position
                    let clickPosition = (clientX - rect.left) / rect.width;
                    clickPosition = Math.max(0, Math.min(1, clickPosition));

                    let clickedSeconds = Math.round(clickPosition * totalSeconds);

                    // Logic: Center the 30s selection around the clicked point, or move start to clicked point
                    // For simplicity: Set start time to clicked point, ensuring we don't go out of bounds

                    let start = clickedSeconds;
                    let end = start + 30;

                    // If end exceeds total, shift back
                    if (end > totalSeconds) {
                        end = totalSeconds;
                        start = Math.max(0, end - 30);
                    }

                    document.getElementById('startTimeInput').value = start;
                    document.getElementById('endTimeInput').value = end;
                    updatePreview();
                }

                function handleTimelineInteractionEnd(e) {
                    isDraggingTimeline = false;
                }

                function setPresetTime(start, end) {
                    document.getElementById('startTimeInput').value = start;
                    document.getElementById('endTimeInput').value = end;
                    updatePreview();
                }

                function updatePreview() {
                    const startInput = document.getElementById('startTimeInput');
                    const endInput = document.getElementById('endTimeInput');
                    const selection = document.getElementById('previewSelection');
                    const label = document.getElementById('selectionLabel');

                    if (!startInput || !endInput || !selection || !label) return;

                    let start = parseInt(startInput.value) || 0;
                    let end = parseInt(endInput.value) || 30;

                    // Ensure end is after start
                    if (end <= start) {
                        end = start + 1;
                        endInput.value = end;
                    }

                    // Ensure duration doesn't exceed 30 seconds
                    if (end - start > 30) {
                        end = start + 30;
                        endInput.value = end;
                    }

                    const totalSeconds = parseDurationToSeconds(selectedVideoForTimeRange.duration);
                    const startPercent = (start / totalSeconds) * 100;
                    const endPercent = (end / totalSeconds) * 100;

                    selection.style.left = `${startPercent}%`;
                    selection.style.width = `${endPercent - startPercent}%`;

                    label.textContent = `${formatSeconds(start)} - ${formatSeconds(end)} (${end - start}s)`;
                }

                function confirmTimeRange() {
                    const start = parseInt(document.getElementById('startTimeInput').value) || 0;
                    const end = parseInt(document.getElementById('endTimeInput').value) || 30;

                    if (end - start > 30) {
                        alert('Duration cannot exceed 30 seconds!');
                        return;
                    }

                    if (end <= start) {
                        alert('End time must be after start time!');
                        return;
                    }

                    const trackData = {
                        ...selectedVideoForTimeRange,
                        startTime: start,
                        endTime: end
                    };

                    document.getElementById('selectedTrackData').value = JSON.stringify(trackData);
                    document.getElementById('spotifySearchQuery').value = selectedVideoForTimeRange.title;
                    document.getElementById('spotifyResults').classList.add('hidden');
                    removeTimeRangeSelector();
                }

                function removeTimeRangeSelector() {
                    const selector = document.getElementById('timeRangeSelector');
                    if (selector) selector.remove();

                    document.removeEventListener('mousemove', handleTimelineInteractionMove);
                    document.removeEventListener('mouseup', handleTimelineInteractionEnd);
                    document.removeEventListener('touchmove', handleTimelineInteractionMove);
                    document.removeEventListener('touchend', handleTimelineInteractionEnd);
                }

                function parseDurationToSeconds(duration) {
                    if (!duration) return 0;
                    const match = duration.match(/(\d+):(\d+)/);
                    if (!match) return 0;
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    return minutes * 60 + seconds;
                }

                function formatSeconds(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                function formatDuration(iso) {
                    const m = iso.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
                    const h = (m[1] || '').replace('H', ''), min = (m[2] || '').replace('M', ''), s = (m[3] || '').replace('S', '');
                    return h ? `${h}:${min.padStart(2, '0')}:${s.padStart(2, '0')}` : `${min || '0'}:${s.padStart(2, '0')}`;
                }

                function escapeHtml(t) {
                    const d = document.createElement('div');
                    d.textContent = t;
                    return d.innerHTML;
                }

                let uploadedMediaFile = null, uploadedMediaType = null;

                function handleMediaUpload(e) {
                    const file = e.target.files[0];
                    if (!file || file.size > 50 * 1024 * 1024) {
                        if (file) alert('File too large!');
                        return;
                    }
                    uploadedMediaFile = file;
                    uploadedMediaType = file.type.startsWith('image/') ? 'image' : 'video';
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const preview = document.getElementById('mediaPreview');
                        preview.classList.remove('hidden');
                        preview.innerHTML = uploadedMediaType === 'image'
                            ? `<img src="${ev.target.result}" /><button type="button" class="media-remove-btn" onclick="removeMedia()"></button><div class="media-info"><i class="fas fa-image"></i> Image</div>`
                            : `<video src="${ev.target.result}" controls></video><button type="button" class="media-remove-btn" onclick="removeMedia()"></button><div class="media-info"><i class="fas fa-video"></i> Video</div>`;
                        document.getElementById('uploadedMediaData').value = JSON.stringify({
                            type: uploadedMediaType,
                            data: ev.target.result,
                            name: file.name,
                            size: file.size
                        });
                    };
                    reader.readAsDataURL(file);
                }

                function removeMedia() {
                    uploadedMediaFile = null;
                    uploadedMediaType = null;
                    document.getElementById('mediaPreview').classList.add('hidden');
                    document.getElementById('mediaPreview').innerHTML = '';
                    document.getElementById('uploadedMediaData').value = '';
                    document.getElementById('mediaUpload').value = '';
                }

                function formatTime(ts) {
                    const diff = Date.now() - new Date(ts), m = Math.floor(diff / 60000), h = Math.floor(diff / 3600000), d = Math.floor(diff / 86400000);
                    if (m < 1) return 'Just now';
                    if (m < 60) return `${m}m ago`;
                    if (h < 24) return `${h}h ago`;
                    if (d === 1) return 'Yesterday';
                    if (d < 7) return `${d}d ago`;
                    return new Date(ts).toLocaleDateString();
                }

                function formatMessageTime(ts) {
                    return new Date(ts).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                }

                function renderStories() {
                    const storiesByUser = {};
                    stories.forEach(s => {
                        if (!storiesByUser[s.userId]) storiesByUser[s.userId] = {
                            user: { id: s.userId, name: s.userName, avatar: s.avatar },
                            stories: [],
                            allViewed: true
                        };
                        storiesByUser[s.userId].stories.push(s);
                        if (!s.viewed) storiesByUser[s.userId].allViewed = false;
                    });
                    document.getElementById('storiesList').innerHTML = Object.values(storiesByUser).map(g => `
        <div class="story-item ${g.allViewed ? 'viewed' : ''}" onclick="openStory('${g.user.id}')">
            <div class="story-ring">
                <img src="${g.user.avatar}" />
                ${g.stories.length > 1 ? `<div class="story-count-badge">${g.stories.length}</div>` : ''}
            </div>
            <span class="story-username">${g.user.name.split(' ')[0]}</span>
        </div>
    `).join('');
                }

                function renderConversations() {
                    document.getElementById('conversationsList').innerHTML = conversations.map(c => `
        <div class="conversation-item ${selectedChat === c.id ? 'active' : ''}" onclick="selectChat(${c.id})">
            <div class="conversation-avatar">
                <img src="${c.avatar}" />
                ${c.online ? '<div class="online-indicator"></div>' : ''}
            </div>
            <div class="conversation-content">
                <div class="conversation-header">
                    <span class="conversation-name">${c.userName}</span>
                    <span class="conversation-time">${formatTime(c.timestamp)}</span>
                </div>
                <div class="conversation-preview">
                    <span class="last-message">${c.lastMessage}</span>
                    ${c.unread > 0 ? `<span class="unread-badge">${c.unread}</span>` : ''}
                </div>
            </div>
        </div>
    `).join('');
                }

                function renderChatHeader() {
                    const c = conversations.find(x => x.id === selectedChat);
                    if (!c) return;
                    document.getElementById('chatHeader').innerHTML = `
        <div class="chat-header-user">
            <img src="${c.avatar}" />
            <div class="chat-header-info">
                <h3>${c.userName}</h3>
                <span class="status ${c.online ? 'online' : 'offline'}">${c.online ? 'Online' : 'Offline'}</span>
            </div>
        </div>
    `;
                }


                function selectChat(id) {
                    selectedChat = id;
                    conversations = conversations.map(c => c.id === id ? { ...c, unread: 0 } : c);
                    document.getElementById('noChatSelected').classList.add('hidden');
                    document.getElementById('chatWindow').classList.remove('hidden');
                    renderConversations();
                    renderChatHeader();
                    renderMessages();
                }

                function sendMessage() {
                    const input = document.getElementById('messageInput');
                    const text = input.value.trim();
                    if (!text || !selectedChat) return;
                    const msg = {
                        id: Date.now(),
                        senderId: 'me',
                        text: text,
                        type: 'text',
                        timestamp: new Date()
                    };
                    if (!messages[selectedChat]) messages[selectedChat] = [];
                    messages[selectedChat].push(msg);
                    conversations = conversations.map(c => c.id === selectedChat ? { ...c, lastMessage: text, timestamp: new Date() } : c);
                    input.value = '';
                    disappearingMode = null;
                    updateDisappearingButtons();
                    renderConversations();
                    renderMessages();
                }

                function deleteMessage(id) {
                    if (!selectedChat) return;
                    messages[selectedChat] = messages[selectedChat].filter(m => m.id !== id);
                    renderMessages();
                }

                function toggleDisappearingOptions() {
                    document.getElementById('disappearingOptions').classList.toggle('hidden');
                }

                function setDisappearingMode(mode) {
                    disappearingMode = disappearingMode === mode ? null : mode;
                    updateDisappearingButtons();
                }

                function updateDisappearingButtons() {
                    document.getElementById('readOnceBtn').classList.toggle('active', disappearingMode === 'read-once');
                    document.getElementById('timedBtn').classList.toggle('active', disappearingMode === 'timed');
                }

                function stopRecording() {
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                        isRecording = false;

                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }

                        if (animationId) {
                            cancelAnimationFrame(animationId);
                            animationId = null;
                        }

                        // Reset bars to default state
                        const bars = document.querySelectorAll('.voice-bar');
                        bars.forEach(bar => {
                            bar.style.height = '8px';
                            bar.classList.remove('active-recording', 'high-intensity');
                        });

                        updateRecordingUI();
                    }
                }

                function updateRecordingUI() {
                    document.getElementById('normalInput').classList.toggle('hidden', isRecording);
                    document.getElementById('recordingIndicator').classList.toggle('hidden', !isRecording);
                    document.getElementById('micBtn').classList.toggle('hidden', isRecording);
                    document.getElementById('stopBtn').classList.toggle('hidden', !isRecording);
                }

                // Story Interactions Helpers
                function toggleLike(storyId) {
                    const story = stories.find(s => s.id === storyId);
                    if (story) {
                        story.liked = !story.liked;
                        story.likes = (story.likes || 0) + (story.liked ? 1 : -1);

                        // Update UI
                        const activeCard = document.querySelector(`.story-card.active`);
                        if (activeCard) {
                            const likeBtn = activeCard.querySelector('.story-like-btn');
                            if (likeBtn) {
                                likeBtn.classList.toggle('liked', story.liked);
                                likeBtn.querySelector('i').className = story.liked ? 'fas fa-heart' : 'far fa-heart';
                            }
                        }
                    }
                }

                function sendStoryReply(storyId, text) {
                    if (!text.trim()) return;

                    const story = stories.find(s => s.id === storyId);
                    if (!story) return;

                    const userId = story.userId;

                    // Create new message
                    const msg = {
                        id: Date.now(),
                        senderId: 'me',
                        text: `Replied to story: ${text}`,
                        storyRef: storyId,
                        storyTitle: story.subject,
                        type: 'text',
                        timestamp: new Date()
                    };

                    if (!messages[userId]) messages[userId] = [];
                    messages[userId].push(msg);

                    // Update conversation list
                    let conv = conversations.find(c => c.userId == userId);
                    if (conv) {
                        conv.lastMessage = `Replied to story: ${text}`;
                        conv.timestamp = new Date();
                        conv.unread = 0;
                    } else {
                        conversations.unshift({
                            id: userId,
                            userId: userId,
                            userName: story.userName,
                            avatar: story.avatar,
                            lastMessage: `Replied to story: ${text}`,
                            timestamp: new Date(),
                            unread: 0,
                            online: true
                        });
                    }

                    closeStory();
                    selectChat(userId);
                }

let previewPlayer = null;
let isPreviewPlaying = false;

function togglePreview() {
    const btn = document.getElementById('previewBtn');
    if (!btn) return;

    if (isPreviewPlaying) {
        stopPreview();
        return;
    }

    const start = parseInt(document.getElementById('startTimeInput').value) || 0;
    const end = parseInt(document.getElementById('endTimeInput').value) || 30;

    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
    btn.classList.add('playing');

    // Wait for YouTube API to be ready
    if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
        console.error('YouTube API not loaded yet');
        setTimeout(() => {
            btn.innerHTML = '<i class="fas fa-play"></i> Play Preview';
            btn.classList.remove('playing');
            alert('YouTube player is still loading. Please try again in a moment.');
        }, 500);
        return;
    }

    // Destroy existing player
    if (previewPlayer) {
        try {
            previewPlayer.destroy();
        } catch (e) {
            console.log('Error destroying preview player:', e);
        }
        previewPlayer = null;
    }

    // Create container if it doesn't exist
    let container = document.getElementById('preview-player-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'preview-player-container';
        container.style.display = 'none';
        document.querySelector('.time-range-selector').appendChild(container);
    }

    try {
        previewPlayer = new YT.Player('preview-player-container', {
            height: '0',
            width: '0',
            videoId: selectedVideoForTimeRange.id,
            playerVars: {
                autoplay: 1,
                controls: 0,
                start: start,
                end: end,
                modestbranding: 1,
                rel: 0
            },
            events: {
                onReady: (event) => {
                    console.log('Preview player ready');
                    event.target.playVideo();
                    btn.innerHTML = '<i class="fas fa-stop"></i> Stop Preview';
                    isPreviewPlaying = true;
                },
                onStateChange: (event) => {
                    if (event.data === YT.PlayerState.ENDED) {
                        stopPreview();
                    } else if (event.data === YT.PlayerState.PLAYING) {
                        btn.innerHTML = '<i class="fas fa-stop"></i> Stop Preview';
                        isPreviewPlaying = true;
                    }
                },
                onError: (event) => {
                    console.error('Preview player error:', event.data);
                    stopPreview();
                    alert('Error playing preview. Please try another video.');
                }
            }
        });
    } catch (error) {
        console.error('Error creating preview player:', error);
        btn.innerHTML = '<i class="fas fa-play"></i> Play Preview';
        btn.classList.remove('playing');
    }
}

function stopPreview() {
    isPreviewPlaying = false;
    const btn = document.getElementById('previewBtn');
    if (btn) {
        btn.innerHTML = '<i class="fas fa-play"></i> Play Preview';
        btn.classList.remove('playing');
    }

    if (previewPlayer) {
        try {
            previewPlayer.stopVideo();
            previewPlayer.destroy();
        } catch (e) {
            console.log('Error stopping preview:', e);
        }
        previewPlayer = null;
    }
}

                function stopPreview() {
                    isPreviewPlaying = false;
                    const btn = document.getElementById('previewBtn');
                    if (btn) {
                        btn.innerHTML = '<i class="fas fa-play"></i> Play Preview';
                        btn.classList.remove('playing');
                    }

                    if (previewPlayer) {
                        previewPlayer.destroy();
                        previewPlayer = null;
                        const container = document.createElement('div');
                        container.id = 'preview-player-container';
                        container.style.display = 'none';
                        const modalContent = document.querySelector('.time-range-selector');
                        if (modalContent) modalContent.appendChild(container); // Re-append if context exists
                    }
                }

                // Event Listeners
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });

                document.getElementById('messageInput').addEventListener('input', (e) => {
                    document.getElementById('sendBtn').classList.toggle('hidden', !e.target.value.trim());
                });

                document.getElementById('sendBtn').addEventListener('click', sendMessage);
                document.getElementById('disappearingBtn').addEventListener('click', toggleDisappearingOptions);
                document.getElementById('readOnceBtn').addEventListener('click', () => setDisappearingMode('read-once'));
                document.getElementById('timedBtn').addEventListener('click', () => setDisappearingMode('timed'));
                document.getElementById('micBtn').addEventListener('click', startRecording);
                document.getElementById('stopBtn').addEventListener('click', stopRecording);

                document.getElementById('addStoryModal').addEventListener('click', (e) => {
                    if (e.target.id === 'addStoryModal') closeAddStoryModal();
                });

                document.getElementById('storyModal').addEventListener('click', (e) => {
                    if (e.target.id === 'storyModal') closeStory();
                });

                document.addEventListener('keydown', handleKeyPress);

                document.addEventListener('DOMContentLoaded', () => {
                    setupLiveYouTubeSearch();
                    renderStories();
                    renderConversations();
                });
                // Add this function to initialize comment box in the modal

                function addCommentBoxToModal() {
                    const modal = document.getElementById('storyModal');
                    if (modal && !document.getElementById('commentBox')) {
                        const commentBox = document.createElement('div');
                        commentBox.id = 'commentBox';
                        commentBox.className = 'story-comment-box';

                        // Add click handler to prevent propagation on the box itself
                        commentBox.addEventListener('click', function (e) {
                            e.stopPropagation();
                        });

                        commentBox.innerHTML = `
            <div class="comment-box-header">
                <h4><i class="fas fa-comments"></i> Comments</h4>
                <button class="comment-box-close" onclick="closeCommentBox(event)">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
            <div class="comment-box-content" id="commentBoxContent">
                <!-- Comments will be loaded here -->
            </div>
            <div class="comment-box-input-wrapper">
                <input type="text" class="comment-box-input" id="commentBoxInput" 
                       placeholder="Add a comment..." 
                       onkeydown="if(event.key === 'Enter') { event.stopPropagation(); submitComment(event); }"
                       onclick="event.stopPropagation()">
                <button class="comment-box-send-btn" onclick="submitComment(event)">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        `;
                        modal.appendChild(commentBox);
                    }
                }
                let currentCommentStoryId = null;

                function toggleCommentBox(storyId, event) {
                    // CRITICAL: Prevent ALL event propagation
                    if (event) {
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        event.preventDefault();
                    }

                    const commentBox = document.getElementById('commentBox');
                    if (!commentBox) {
                        addCommentBoxToModal();
                    }

                    const box = document.getElementById('commentBox');

                    // If clicking the same story's comment button, toggle
                    if (box.classList.contains('active') && currentCommentStoryId === storyId) {
                        closeCommentBox(event);
                    } else {
                        // Open comment box for this story
                        currentCommentStoryId = storyId;
                        loadComments(storyId);
                        box.classList.add('active');
                    }
                }

                function closeCommentBox(event) {
                    // Prevent event propagation
                    if (event) {
                        event.stopPropagation();
                        event.preventDefault();
                    }

                    const commentBox = document.getElementById('commentBox');
                    if (commentBox) {
                        commentBox.classList.remove('active');
                    }
                    currentCommentStoryId = null;
                }

                function loadComments(storyId) {
                    const story = stories.find(s => s.id === storyId);
                    if (!story) return;

                    if (!story.comments) story.comments = [];

                    const content = document.getElementById('commentBoxContent');
                    if (!content) return;

                    if (story.comments.length === 0) {
                        content.innerHTML = '<div class="no-comments"><i class="fas fa-comment-slash"></i><p>No comments yet. Be the first!</p></div>';
                    } else {
                        content.innerHTML = story.comments.map(comment => {
                            // Sanitize and ensure text wraps properly
                            const sanitizedText = escapeHtml(comment.text);

                            return `
            <div class="comment-item">
                <img src="${comment.avatar}" class="comment-avatar" alt="${escapeHtml(comment.userName)}">
                <div class="comment-content">
                    <div class="comment-header">
                        <span class="comment-username">${escapeHtml(comment.userName)}</span>
                        <span class="comment-time">${formatTime(comment.timestamp)}</span>
                    </div>
                    <div class="comment-text">${sanitizedText}</div>
                </div>
            </div>
        `;
                        }).join('');
                    }

                    // Scroll to bottom smoothly
                    setTimeout(() => {
                        content.scrollTop = content.scrollHeight;
                    }, 100);
                }

                // ============================================
                // 6. UPDATE submitComment FUNCTION
                // ============================================
                function submitComment(event) {
                    // Prevent event propagation
                    if (event) {
                        event.stopPropagation();
                        event.preventDefault();
                    }

                    const input = document.getElementById('commentBoxInput');
                    if (!input) return;

                    const text = input.value.trim();
                    if (!text || !currentCommentStoryId) return;

                    const story = stories.find(s => s.id === currentCommentStoryId);
                    if (!story) return;

                    if (!story.comments) story.comments = [];

                    const comment = {
                        id: Date.now(),
                        userId: 'me',
                        userName: 'You',
                        avatar: 'https://i.pravatar.cc/150?img=11',
                        text: text, // Keep original text with line breaks
                        timestamp: new Date()
                    };

                    story.comments.push(comment);
                    stories = stories.map(s => s.id === currentCommentStoryId ? story : s);

                    input.value = ''; // Clear input
                    loadComments(currentCommentStoryId); // Reload comments
                }
                // ============================================
                // ATTACHMENT MENU FUNCTIONALITY
                // ============================================

                let attachmentMenuOpen = false;

                document.getElementById('attachBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleAttachmentMenu();
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    const menu = document.getElementById('attachmentMenu');
                    const btn = document.getElementById('attachBtn');
                    if (attachmentMenuOpen && !menu.contains(e.target) && !btn.contains(e.target)) {
                        closeAttachmentMenu();
                    }
                });

                function toggleAttachmentMenu() {
                    const menu = document.getElementById('attachmentMenu');
                    attachmentMenuOpen = !attachmentMenuOpen;
                    menu.classList.toggle('active', attachmentMenuOpen);
                }

                function closeAttachmentMenu() {
                    const menu = document.getElementById('attachmentMenu');
                    attachmentMenuOpen = false;
                    menu.classList.remove('active');
                }

                function triggerFileInput(type) {
                    const inputId = type + 'Input';
                    document.getElementById(inputId).click();
                    closeAttachmentMenu();
                }

                // ============================================
                // FILE UPLOAD HANDLING
                // ============================================

                function handleFileUpload(event, type) {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;

                    // Create array to hold processed media
                    const attachments = [];
                    const fileReaders = [];

                    // Process all selected files
                    Array.from(files).forEach(file => {
                        if (file.size > 50 * 1024 * 1024) {
                            alert(`File ${file.name} too large! Skipping.`);
                            return;
                        }

                        const reader = new FileReader();
                        const promise = new Promise((resolve) => {
                            reader.onload = (e) => {
                                resolve({
                                    type: type, // 'image' or 'video'
                                    url: e.target.result,
                                    name: file.name
                                });
                            };
                        });
                        reader.readAsDataURL(file);
                        fileReaders.push(promise);
                    });

                    // Wait for all files to be read
                    Promise.all(fileReaders).then(results => {
                        if (results.length === 0) return;

                        const msg = {
                            id: Date.now(),
                            senderId: 'me',
                            type: 'media_group', // New type for grouped media
                            text: '',
                            attachments: results,
                            timestamp: new Date()
                        };

                        if (!messages[selectedChat]) messages[selectedChat] = [];
                        messages[selectedChat].push(msg);

                        // Update conversation preview
                        conversations = conversations.map(c =>
                            c.id === selectedChat
                                ? { ...c, lastMessage: ` ${results.length} media file(s)`, timestamp: new Date() }
                                : c
                        );

                        renderConversations();
                        renderMessages();
                    });

                    event.target.value = ''; // Reset input
                }

                function formatFileSize(bytes) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
                }

                // ============================================
                // ENHANCED VOICE RECORDING WITH VISUALIZATION
                // ============================================
                let audioContext = null;
                let analyser = null;
                let microphone = null;
                let dataArray = null;
                let animationId = null;

                async function startRecording() {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                        // Setup MediaRecorder
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];

                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) audioChunks.push(e.data);
                        };

                        mediaRecorder.onstop = () => {
                            handleRecordingStop(stream);
                        };

                        mediaRecorder.start();
                        isRecording = true;
                        recordingStartTime = Date.now();

                        // --- START VISUALIZATION ---
                        // We pass the stream directly. 
                        setupRealtimeAudioVisualization(stream);

                        // Start timer
                        updateRecordingTimer();
                        recordingTimerInterval = setInterval(updateRecordingTimer, 1000);

                        updateRecordingUI();

                    } catch (err) {
                        console.error('Microphone error:', err);
                        alert('Please allow microphone access to record voice messages.');
                    }
                }
                function setupRealtimeAudioVisualization(stream) {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    if (audioContext.state === 'suspended') audioContext.resume();

                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    // Smoothing 0.8 makes transitions look like a fluid wave rather than jittery lines
                    analyser.smoothingTimeConstant = 0.8;

                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    dataArray = new Uint8Array(analyser.frequencyBinCount);

                    const visualizer = document.getElementById('voiceVisualizer');
                    if (!visualizer) return;

                    visualizer.innerHTML = '';
                    for (let i = 0; i < 20; i++) { // Using 20 bars for better resolution
                        const bar = document.createElement('div');
                        bar.className = 'voice-bar active-recording';
                        visualizer.appendChild(bar);
                    }

                    animateRealtimeVoiceVisualizer();
                }
                function setupAudioVisualization(stream) {
                    // Create audio context and analyser
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    const source = audioContext.createMediaStreamSource(stream);

                    source.connect(analyser);
                    analyser.fftSize = 64;

                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    // Create visualizer bars
                    const visualizer = document.getElementById('voiceVisualizer');
                    visualizer.innerHTML = '';

                    for (let i = 0; i < 10; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'voice-bar';
                        visualizer.appendChild(bar);
                    }

                    // Start animation
                    animateVoiceVisualizer();
                }

                function animateRealtimeVoiceVisualizer() {
                    if (!isRecording || !analyser) return;

                    animationId = requestAnimationFrame(animateRealtimeVoiceVisualizer);
                    analyser.getByteFrequencyData(dataArray);

                    const bars = document.querySelectorAll('#voiceVisualizer .voice-bar');
                    if (!bars.length) return;

                    // Use only the first 50% of the data (vocal range)
                    const step = Math.floor((dataArray.length * 0.5) / bars.length);

                    bars.forEach((bar, i) => {
                        let sum = 0;
                        for (let j = 0; j < step; j++) {
                            sum += dataArray[(i * step) + j];
                        }
                        let average = sum / step;

                        // --- THE FIX: NOISE GATE ---
                        // If volume is below 15 (background hum), force it to 0
                        if (average < 15) {
                            average = 0;
                        }

                        // --- THE FIX: LOGARITHMIC SCALING ---
                        // We use Math.pow to make it harder to hit the 'max' height.
                        // This ensures the full waveform is only used for genuinely loud noises.
                        let normalized = average / 255;
                        let scaledHeight = Math.pow(normalized, 1.2) * 50; // 50 is the multiplier for max height

                        // Clamp values
                        const minHeight = 4;
                        const maxHeight = 38;
                        const finalHeight = Math.max(minHeight, Math.min(maxHeight, scaledHeight + minHeight));

                        bar.style.height = `${finalHeight}px`;

                        // Intensity styling: only trigger for top 10% of volume
                        if (finalHeight > 34) {
                            bar.classList.add('high-intensity');
                        } else {
                            bar.classList.remove('high-intensity');
                        }
                    });
                }
                function updateRecordingTimer() {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('recordingTime').textContent =
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }

                function stopRecording() {
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                        isRecording = false;

                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }

                        if (animationId) {
                            cancelAnimationFrame(animationId);
                            animationId = null;
                        }

                        updateRecordingUI();
                    }
                }

                function cancelRecording() {
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        // Stop without saving
                        const stream = mediaRecorder.stream;
                        mediaRecorder.stop();

                        // Clear chunks so nothing is saved
                        audioChunks = [];

                        if (stream) {
                            stream.getTracks().forEach(t => t.stop());
                        }

                        isRecording = false;

                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }

                        if (animationId) {
                            cancelAnimationFrame(animationId);
                            animationId = null;
                        }

                        if (audioContext) {
                            audioContext.close();
                            audioContext = null;
                        }

                        // Reset bars to default state
                        const bars = document.querySelectorAll('.voice-bar');
                        bars.forEach(bar => {
                            bar.style.height = '8px';
                            bar.classList.remove('active-recording', 'high-intensity');
                        });

                        updateRecordingUI();
                    }
                }

                function updateRecordingUI() {
                    const chatInput = document.getElementById('chatInputBox');
                    const normalInput = document.getElementById('normalInput');
                    const recordingIndicator = document.getElementById('recordingIndicator');
                    const micBtn = document.getElementById('micBtn');
                    const stopBtn = document.getElementById('stopBtn');
                    const cancelBtn = document.getElementById('cancelBtn');
                    const attachBtn = document.getElementById('attachBtn');
                    const disappearingBtn = document.getElementById('disappearingBtn');

                    if (isRecording) {
                        chatInput.classList.add('recording');
                        normalInput.classList.add('hidden');
                        recordingIndicator.classList.remove('hidden');
                        micBtn.classList.add('hidden');
                        stopBtn.classList.remove('hidden');
                        cancelBtn.classList.remove('hidden');
                        attachBtn.parentElement.classList.add('hidden');
                        disappearingBtn.classList.add('hidden');
                    } else {
                        chatInput.classList.remove('recording');
                        normalInput.classList.remove('hidden');
                        recordingIndicator.classList.add('hidden');
                        micBtn.classList.remove('hidden');
                        stopBtn.classList.add('hidden');
                        cancelBtn.classList.add('hidden');
                        attachBtn.parentElement.classList.remove('hidden');
                        disappearingBtn.classList.remove('hidden');
                    }
                }

                // ============================================
                // REACTION FEATURE LOGIC
                // ============================================
                let currentExpandingMessageId = null;

                function showReactionMenu(messageId, event) {
                    event.stopPropagation();

                    currentExpandingMessageId = messageId;
                    const menu = document.getElementById('reactionMenu');
                    const triggerBtn = event.currentTarget;
                    const bubble = triggerBtn.closest('.message').querySelector('.message-bubble');
                    const rect = bubble.getBoundingClientRect();

                    // Reset any previous styles
                    menu.style.display = 'flex';
                    menu.classList.add('active');

                    // Calculate center position relative to the bubble
                    const menuWidth = 320; // Approx width of menu
                    const left = rect.left + (rect.width / 2) - (menuWidth / 2);
                    const top = rect.top - 70; // Position above bubble

                    menu.style.left = `${Math.max(10, Math.min(window.innerWidth - menuWidth - 10, left))}px`;
                    menu.style.top = `${top}px`;

                    // Close menu on next click elsewhere
                    setTimeout(() => {
                        document.addEventListener('click', closeReactionMenu, { once: true });
                    }, 10);
                }

                function closeReactionMenu() {
                    const menu = document.getElementById('reactionMenu');
                    menu.classList.remove('active');
                }

                function addReaction(emoji) {
                    if (!selectedChat || !currentExpandingMessageId) return;

                    const msgIndex = messages[selectedChat].findIndex(m => m.id === currentExpandingMessageId);
                    if (msgIndex === -1) return;

                    const msg = messages[selectedChat][msgIndex];
                    if (!msg.reactions) msg.reactions = {};

                    // If already has this reaction from 'me', remove it. Otherwise add it.
                    if (msg.reactions[emoji] && msg.reactions[emoji].includes('me')) {
                        msg.reactions[emoji] = msg.reactions[emoji].filter(u => u !== 'me');
                        if (msg.reactions[emoji].length === 0) delete msg.reactions[emoji];
                    } else {
                        if (!msg.reactions[emoji]) msg.reactions[emoji] = [];
                        msg.reactions[emoji].push('me');
                    }

                    renderMessages();
                    closeReactionMenu();
                }

                function removeReaction(messageId, emoji) {
                    const msgIndex = messages[selectedChat].findIndex(m => m.id === messageId);
                    if (msgIndex === -1) return;

                    const msg = messages[selectedChat][msgIndex];
                    if (msg.reactions && msg.reactions[emoji]) {
                        msg.reactions[emoji] = msg.reactions[emoji].filter(u => u !== 'me');
                        if (msg.reactions[emoji].length === 0) delete msg.reactions[emoji];
                        renderMessages();
                    }
                }

function renderMessages() {
    const chat = conversations.find(c => c.id == selectedChat);
    if (!chat) return;

    const msgs = messages[selectedChat] || [];
    const chatBox = document.getElementById('chatMessages');

    chatBox.innerHTML = msgs.map(m => {
        let contentHtml = '';

        // Handle different message types (keep your existing content logic)
        if (m.attachments && m.attachments.length > 0) {
            const mediaOnly = m.attachments.filter(a => a.type === 'image' || a.type === 'video');
            const docsOnly = m.attachments.filter(a => a.type === 'document');

            if (mediaOnly.length > 0) {
                contentHtml += `<div class="media-grid" data-count="${Math.min(mediaOnly.length, 4)}">`;
                mediaOnly.slice(0, 4).forEach((att, idx) => {
                    const isLast = idx === 3 && mediaOnly.length > 4;
                    const mediaTag = att.type === 'video'
                        ? `<video src="${att.url}" muted></video>`
                        : `<img src="${att.url}" alt="media" />`;

                    contentHtml += `
                        <div class="media-item" onclick="openLightbox(${m.id}, ${idx})">
                            ${mediaTag}
                            ${isLast ? `<div class="media-overlay">+${mediaOnly.length - 4}</div>` : ''}
                        </div>`;
                });
                contentHtml += `</div>`;
            }

            if (docsOnly.length > 0) {
                docsOnly.forEach(doc => {
                    contentHtml += `
                        <div class="document-card" onclick="downloadFile('${doc.url}', '${doc.name}')">
                            <div class="doc-icon"><i class="fas fa-file-lines"></i></div>
                            <div class="doc-info">
                                <div class="doc-name">${doc.name}</div>
                                <div class="doc-size">Download Document</div>
                            </div>
                            <div class="doc-download-btn"><i class="fas fa-download"></i></div>
                        </div>`;
                });
            }

            if (m.text && !m.text.includes('sent') && !m.text.includes('files')) {
                contentHtml += `<p class="message-text-adj">${m.text}</p>`;
            }
        } else if (m.type === 'voice') {
            contentHtml = `
                <div class="voice-message-player">
                    <button class="voice-play-btn" onclick="playVoiceWithWaveform('${m.audioUrl}', this)">
                        <i class="fas fa-play"></i>
                    </button>
                    <div class="waveform-container">
                        ${generateWaveform()} 
                    </div>
                    <span class="voice-duration">${m.duration || '0:00'}</span>
                </div>`;
        } else {
            contentHtml = `<p>${m.text}</p>`;
        }

        // Build reactions HTML
        let reactionsHtml = '';
        if (m.reactions && Object.keys(m.reactions).length > 0) {
            reactionsHtml = '<div class="message-reaction-badge" onclick="event.stopPropagation(); showReactionDetails(' + m.id + ')">';
            Object.entries(m.reactions).forEach(([emoji, users]) => {
                const isMyReaction = users.includes('me');
                reactionsHtml += `
                    <div class="reaction-pill-item ${isMyReaction ? 'my-reaction' : ''}" 
                         onclick="event.stopPropagation(); toggleReaction(${m.id}, '${emoji}')">
                        <span>${emoji}</span>
                        <span class="count">${users.length}</span>
                    </div>`;
            });
            reactionsHtml += '</div>';
        }

        // Reaction trigger button (LEFT for sent, RIGHT for received)
        const reactionTriggerHtml = `
            <div class="reaction-trigger-wrapper">
                <div class="reaction-trigger-btn" onclick="showReactionMenu(${m.id}, event)">
                    <i class="far fa-smile"></i>
                </div>
            </div>
        `;

        // Options button (RIGHT for sent, LEFT for received)
        const optionsTriggerHtml = `
            <div class="message-options-trigger">
                <div class="message-options-btn" onclick="showMessageOptions(${m.id}, event)">
                    <i class="fas fa-ellipsis-vertical"></i>
                </div>
            </div>
        `;

        return `
            <div class="message ${m.senderId === 'me' ? 'sent' : 'received'}" data-message-id="${m.id}">
                ${m.senderId !== 'me' ? `<img src="${chat.avatar}" class="message-avatar" />` : ''}
                <div class="message-content">
                    ${reactionTriggerHtml}
                    ${optionsTriggerHtml}
                    <div class="message-bubble">
                        ${contentHtml}
                    </div>
                    ${reactionsHtml}
                    <div class="message-meta">
                        <span class="message-time">${formatMessageTime(m.timestamp)}</span>
                        ${m.senderId === 'me' ? '<i class="fas fa-check-double status-icon"></i>' : ''}
                    </div>
                </div>
            </div>
        `;
    }).join('');

    chatBox.scrollTop = chatBox.scrollHeight;
    chatBox.onscroll = () => {
        closeReactionMenu();
        closeMessageOptions();
    };
}
                function getFileIcon(fileName) {
                    const ext = fileName.split('.').pop().toLowerCase();
                    const icons = {
                        pdf: '',
                        doc: '',
                        docx: '',
                        txt: '',
                        xls: '',
                        xlsx: '',
                        ppt: '',
                        pptx: ''
                    };
                    return icons[ext] || '';
                }

                function downloadFile(url, fileName) {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                }

                function generateWaveform() {
                    let html = '';
                    for (let i = 0; i < 20; i++) {
                        const height = Math.random() * 20 + 10;
                        html += `<div class="waveform-bar" style="height: ${height}px;"></div>`;
                    }
                    return html;
                }

                function formatVoiceDuration(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                let currentAudio = null;

                function playVoiceMessage(audioUrl, button) {
                    const icon = button.querySelector('i');

                    if (currentAudio && currentAudio.src === audioUrl && !currentAudio.paused) {
                        // Pause if already playing
                        currentAudio.pause();
                        icon.className = 'fas fa-play';
                    } else {
                        // Stop any currently playing audio
                        if (currentAudio) {
                            currentAudio.pause();
                            const allButtons = document.querySelectorAll('.voice-play-btn i');
                            allButtons.forEach(i => i.className = 'fas fa-play');
                        }

                        // Play new audio
                        currentAudio = new Audio(audioUrl);
                        currentAudio.play();
                        icon.className = 'fas fa-pause';

                        currentAudio.onended = () => {
                            icon.className = 'fas fa-play';
                        };
                    }
                }
                /* =========================================
                   ENHANCED LIGHTBOX ENGINE
                   ========================================= */

                /* =========================================
                   CORE LIGHTBOX & DOCUMENT LOGIC
                   ========================================= */
                /* =========================================
                   ROBUST LIGHTBOX ENGINE (FIXED)
                   ========================================= */

                let currentLightboxMedia = [];
                let currentLightboxIndex = 0;

                /**
                 * Main Entry Point: Opens the lightbox 
                 */
                function openLightbox(messageId, clickedIndexInMessage) {
                    if (!selectedChat || !messages[selectedChat]) return;

                    // 1. Gather ONLY Images and Videos (Properly handle attachments)
                    currentLightboxMedia = [];
                    messages[selectedChat].forEach(msg => {
                        const attachments = msg.attachments || [];
                        attachments.forEach((att) => {
                            // Filter out documents
                            if (att.type === 'image' || att.type === 'video') {
                                currentLightboxMedia.push({
                                    ...att,
                                    messageId: msg.id,
                                    senderId: msg.senderId,
                                    timestamp: msg.timestamp
                                });
                            }
                        });

                        // Backward compatibility for single-media messages
                        if (!msg.attachments) {
                            if (msg.type === 'image') {
                                currentLightboxMedia.push({ url: msg.imageUrl, type: 'image', messageId: msg.id, senderId: msg.senderId, timestamp: msg.timestamp });
                            } else if (msg.type === 'video') {
                                currentLightboxMedia.push({ url: msg.videoUrl, type: 'video', messageId: msg.id, senderId: msg.senderId, timestamp: msg.timestamp });
                            }
                        }
                    });

                    if (currentLightboxMedia.length === 0) return;

                    // 2. Find the index of the exact item clicked
                    currentLightboxIndex = currentLightboxMedia.findIndex(item => item.messageId === messageId) + clickedIndexInMessage;
                    if (currentLightboxIndex < 0) currentLightboxIndex = 0;

                    // 3. Setup Modal
                    const modal = document.getElementById('lightboxModal');
                    modal.style.display = 'flex';

                    // Force a reflow for CSS transition
                    void modal.offsetWidth;
                    modal.classList.add('active');

                    // 4. Attach Background Click Closer
                    modal.onclick = (e) => {
                        const isBackdrop = e.target.id === 'lightboxModal' || e.target.id === 'lightboxMediaContainer';
                        if (isBackdrop) closeLightbox();
                    };

                    renderLightboxStrip();
                    updateLightboxView();
                }

                /**
                 * Updates the view without flickering/blackouts
                 */
                function updateLightboxView() {
                    const item = currentLightboxMedia[currentLightboxIndex];
                    const container = document.getElementById('lightboxMediaContainer');
                    const userLabel = document.getElementById('lightboxUser');

                    // 1. Update Header Info
                    const chat = conversations.find(c => c.id == selectedChat);
                    const sender = item.senderId === 'me' ? 'You' : (chat ? chat.userName : 'User');
                    userLabel.innerHTML = `${sender} <span style="font-size:12px; opacity:0.6; margin-left:8px">${formatMessageTime(item.timestamp)}</span>`;

                    // 2. Create New Media Element (Pre-load)
                    const newMedia = item.type === 'video' ? document.createElement('video') : document.createElement('img');
                    newMedia.src = item.url;
                    newMedia.className = 'lightbox-content';
                    newMedia.style.opacity = '0'; // Start invisible

                    if (item.type === 'video') {
                        newMedia.controls = true;
                        newMedia.autoplay = true;
                    }

                    // 3. Switch logic: Wait for load to prevent "blackout"
                    const handleLoad = () => {
                        container.innerHTML = ''; // Only clear old content once new is ready
                        container.appendChild(newMedia);
                        // Trigger smooth fade in
                        setTimeout(() => { newMedia.style.opacity = '1'; }, 10);
                    };

                    if (item.type === 'video') {
                        newMedia.onloadeddata = handleLoad;
                    } else {
                        newMedia.onload = handleLoad;
                    }

                    syncThumbnailStrip();
                }

                /**
                 * Renders the bottom thumbnail navigation
                 */
                function renderLightboxStrip() {
                    const strip = document.getElementById('lightboxStrip');
                    if (!strip) return;

                    strip.innerHTML = currentLightboxMedia.map((item, idx) => {
                        const isActive = idx === currentLightboxIndex ? 'active' : '';
                        if (item.type === 'video') {
                            return `<div class="lightbox-thumb ${isActive}" onclick="jumpToMedia(${idx})">
                        <video src="${item.url}" muted></video>
                        <i class="fas fa-play" style="position:absolute; font-size:10px; color:white; opacity:0.8;"></i>
                    </div>`;
                        }
                        return `<img src="${item.url}" class="lightbox-thumb ${isActive}" onclick="jumpToMedia(${idx})" />`;
                    }).join('');
                }

                function syncThumbnailStrip() {
                    const thumbs = document.querySelectorAll('.lightbox-thumb');
                    thumbs.forEach((t, i) => {
                        if (i === currentLightboxIndex) {
                            t.classList.add('active');
                            t.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                        } else {
                            t.classList.remove('active');
                        }
                    });
                }

                function navigateLightbox(direction) {
                    const newIdx = currentLightboxIndex + direction;
                    if (newIdx >= 0 && newIdx < currentLightboxMedia.length) {
                        currentLightboxIndex = newIdx;
                        updateLightboxView();
                    }
                }

                function jumpToMedia(index) {
                    if (index === currentLightboxIndex) return;
                    currentLightboxIndex = index;
                    updateLightboxView();
                }

                function closeLightbox() {
                    const modal = document.getElementById('lightboxModal');
                    modal.classList.remove('active');

                    // Cleanup after animation
                    setTimeout(() => {
                        modal.style.display = 'none';
                        document.getElementById('lightboxMediaContainer').innerHTML = '';
                    }, 400);
                }

                /**
                 * Helper: Formats time specifically for lightbox
                 */
                function formatMessageTime(date) {
                    if (!date) return "";
                    const d = new Date(date);
                    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }

                // Global Keyboard Navigation
                document.addEventListener('keydown', (e) => {
                    const modal = document.getElementById('lightboxModal');
                    if (modal && modal.classList.contains('active')) {
                        if (e.key === 'ArrowRight') navigateLightbox(1);
                        if (e.key === 'ArrowLeft') navigateLightbox(-1);
                        if (e.key === 'Escape') closeLightbox();
                    }
                });
                /* --- SYNCED VOICE WAVEFORM LOGIC --- */
                function playVoiceWithWaveform(audioUrl, button) {
                    const icon = button.querySelector('i');
                    const container = button.parentElement.querySelector('.waveform-container');
                    const bars = container.querySelectorAll('.waveform-bar');

                    if (currentAudio && currentAudio.src === audioUrl && !currentAudio.paused) {
                        currentAudio.pause();
                        icon.className = 'fas fa-play';
                    } else {
                        if (currentAudio) {
                            currentAudio.pause();
                            document.querySelectorAll('.voice-play-btn i').forEach(i => i.className = 'fas fa-play');
                            document.querySelectorAll('.waveform-bar').forEach(b => b.classList.remove('playing'));
                        }

                        currentAudio = new Audio(audioUrl);
                        currentAudio.play();
                        icon.className = 'fas fa-pause';

                        // Update waveform bars as audio plays
                        currentAudio.ontimeupdate = () => {
                            const progress = (currentAudio.currentTime / currentAudio.duration) * bars.length;
                            bars.forEach((bar, index) => {
                                if (index < progress) {
                                    bar.classList.add('active-bar');
                                } else {
                                    bar.classList.remove('active-bar');
                                }
                            });
                        };

                        currentAudio.onended = () => {
                            icon.className = 'fas fa-play';
                            bars.forEach(b => b.classList.remove('active-bar'));
                        };
                    }
                }

                // Update the waveform generator to ensure bars are distinct
                function generateWaveform() {
                    let html = '';
                    for (let i = 0; i < 25; i++) {
                        const height = Math.random() * 15 + 5; // Randomize heights for realistic look
                        html += `<div class="waveform-bar" style="height: ${height}px;"></div>`;
                    }
                    return html;
                }
                function handleRecordingStop(stream) {
                    // 1. Process the Audio Data
                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    const duration = Math.floor((Date.now() - recordingStartTime) / 1000);

                    // Only send if valid duration
                    if (duration > 0) {
                        const msg = {
                            id: Date.now(),
                            senderId: 'me',
                            text: 'Voice message',
                            type: 'voice',
                            audioUrl: url,
                            duration: duration,
                            timestamp: new Date()
                        };

                        if (!messages[selectedChat]) messages[selectedChat] = [];
                        messages[selectedChat].push(msg);

                        // Update conversation preview
                        conversations = conversations.map(c =>
                            c.id === selectedChat
                                ? { ...c, lastMessage: ' Voice message', timestamp: new Date() }
                                : c
                        );

                        renderConversations();
                        renderMessages();
                    }

                    // 2. Stop Microphone Tracks
                    if (stream) {
                        stream.getTracks().forEach(t => t.stop());
                    }

                    // 3. Cleanup Visualization Context
                    if (animationId) cancelAnimationFrame(animationId);
                    if (microphone) microphone.disconnect();
                    if (analyser) analyser.disconnect();

                    // Suspend context instead of closing to avoid errors on subsequent recordings
                    if (audioContext && audioContext.state !== 'closed') {
                        audioContext.suspend();
                    }

                    // 4. Reset UI Bars to flat state
                    const bars = document.querySelectorAll('.voice-visualizer .voice-bar');
                    bars.forEach(bar => {
                        bar.style.height = '4px';
                        bar.classList.remove('active-recording', 'high-intensity');
                    });
                }
                // ============================================
// WHATSAPP-STYLE REACTION SYSTEM
// ============================================

let currentReactionMessageId = null;

// Show reaction menu
function showReactionMenu(messageId, event) {
    event.stopPropagation();
    
    currentReactionMessageId = messageId;
    const menu = document.getElementById('reactionMenu');
    const triggerBtn = event.currentTarget;
    const bubble = triggerBtn.closest('.message').querySelector('.message-bubble');
    const rect = bubble.getBoundingClientRect();

    // Reset menu
    menu.classList.remove('active');
    menu.style.display = 'flex';

    // Calculate position
    const menuWidth = 320;
    const left = rect.left + (rect.width / 2) - (menuWidth / 2);
    const top = rect.top - 70;

    menu.style.left = `${Math.max(10, Math.min(window.innerWidth - menuWidth - 10, left))}px`;
    menu.style.top = `${top}px`;

    // Show menu with animation
    setTimeout(() => menu.classList.add('active'), 10);

    // Close on outside click
    setTimeout(() => {
        document.addEventListener('click', closeReactionMenu, { once: true });
    }, 10);
}

// Close reaction menu
function closeReactionMenu() {
    const menu = document.getElementById('reactionMenu');
    menu.classList.remove('active');
    setTimeout(() => {
        menu.style.display = 'none';
    }, 350);
}

// Add or remove reaction
function addReaction(emoji) {
    if (!selectedChat || !currentReactionMessageId) return;

    toggleReaction(currentReactionMessageId, emoji);
    closeReactionMenu();
}

// Toggle reaction (add/remove)
function toggleReaction(messageId, emoji) {
    const msgIndex = messages[selectedChat].findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const msg = messages[selectedChat][msgIndex];
    if (!msg.reactions) msg.reactions = {};

    // Check if user already reacted with this emoji
    if (msg.reactions[emoji] && msg.reactions[emoji].includes('me')) {
        // Remove reaction
        msg.reactions[emoji] = msg.reactions[emoji].filter(u => u !== 'me');
        if (msg.reactions[emoji].length === 0) {
            delete msg.reactions[emoji];
        }
    } else {
        // Add reaction
        if (!msg.reactions[emoji]) {
            msg.reactions[emoji] = [];
        }
        msg.reactions[emoji].push('me');
    }

    renderMessages();
}

// Show reaction details (who reacted)
function showReactionDetails(messageId) {
    const msgIndex = messages[selectedChat].findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const msg = messages[selectedChat][msgIndex];
    if (!msg.reactions || Object.keys(msg.reactions).length === 0) return;

    // Build details string
    let details = 'Reactions:\n\n';
    Object.entries(msg.reactions).forEach(([emoji, users]) => {
        const userNames = users.map(u => u === 'me' ? 'You' : getUserName(u)).join(', ');
        details += `${emoji} ${userNames}\n`;
    });

    // Show in a simple alert (you can replace with a custom modal)
    alert(details);
}

// Helper function to get user name
function getUserName(userId) {
    if (userId === 'me') return 'You';
    const user = mockUsers.find(u => u.id === userId);
    return user ? user.name : 'Unknown';
}

// Initialize reaction menu on page load
document.addEventListener('DOMContentLoaded', () => {
    // Create reaction menu if it doesn't exist
    if (!document.getElementById('reactionMenu')) {
        const reactionMenu = document.createElement('div');
        reactionMenu.id = 'reactionMenu';
        reactionMenu.className = 'reaction-menu';
        reactionMenu.innerHTML = `
            <div class="reaction-emoji" onclick="addReaction('')"></div>
            <div class="reaction-emoji" onclick="addReaction('')"></div>
            <div class="reaction-emoji" onclick="addReaction('')"></div>
            <div class="reaction-emoji" onclick="addReaction('')"></div>
            <div class="reaction-emoji" onclick="addReaction('')"></div>
            <div class="reaction-emoji" onclick="addReaction('')"></div>
        `;
        document.body.appendChild(reactionMenu);
    }
});
// ============================================
// MESSAGE OPTIONS MENU (DELETE/CANCEL)
// ============================================

let currentOptionsMessageId = null;
let currentDeleteAction = null;
let currentDeleteMessageId = null;

// Show message options menu
function showMessageOptions(messageId, event) {
    event.stopPropagation();
    
    currentOptionsMessageId = messageId;
    const menu = document.getElementById('messageOptionsMenu');
    const triggerBtn = event.currentTarget;
    const message = triggerBtn.closest('.message');
    const bubble = message.querySelector('.message-bubble');
    const rect = bubble.getBoundingClientRect();

    // Get message to check if it's sent by user
    const msg = messages[selectedChat].find(m => m.id === messageId);
    const isSentByMe = msg && msg.senderId === 'me';

    // Reset menu
    menu.classList.remove('active');
    menu.style.display = 'flex';

    // Update menu content based on message sender
    if (isSentByMe) {
        // User's own message - show both delete options
        menu.innerHTML = `
            <button class="message-option-item delete-for-me" onclick="confirmDelete(${messageId}, 'me')">
                <i class="fas fa-trash"></i>
                <span>Delete for me</span>
            </button>
            <button class="message-option-item delete-for-everyone" onclick="confirmDelete(${messageId}, 'everyone')">
                <i class="fas fa-trash-can"></i>
                <span>Delete for everyone</span>
            </button>
            <div class="message-options-divider"></div>
            <button class="message-option-item cancel" onclick="closeMessageOptions()">
                <i class="fas fa-xmark"></i>
                <span>Cancel</span>
            </button>
        `;
    } else {
        // Other person's message - only delete for me
        menu.innerHTML = `
            <button class="message-option-item delete-for-me" onclick="confirmDelete(${messageId}, 'me')">
                <i class="fas fa-trash"></i>
                <span>Delete for me</span>
            </button>
            <div class="message-options-divider"></div>
            <button class="message-option-item cancel" onclick="closeMessageOptions()">
                <i class="fas fa-xmark"></i>
                <span>Cancel</span>
            </button>
        `;
    }

    // Calculate position
    const menuHeight = isSentByMe ? 180 : 130;
    const left = message.classList.contains('sent') 
        ? rect.right - 220 
        : rect.left;
    const top = rect.top - menuHeight - 10;

    menu.style.left = `${Math.max(10, Math.min(window.innerWidth - 230, left))}px`;
    menu.style.top = `${Math.max(10, top)}px`;

    // Show menu with animation
    setTimeout(() => menu.classList.add('active'), 10);

    // Close on outside click
    setTimeout(() => {
        document.addEventListener('click', closeMessageOptions, { once: true });
    }, 10);
}

// Close message options menu
function closeMessageOptions() {
    const menu = document.getElementById('messageOptionsMenu');
    menu.classList.remove('active');
    setTimeout(() => {
        menu.style.display = 'none';
    }, 300);
}

// Show delete confirmation modal
function confirmDelete(messageId, action) {
    closeMessageOptions();
    
    currentDeleteMessageId = messageId;
    currentDeleteAction = action;
    
    const modal = document.getElementById('deleteConfirmationModal');
    const title = modal.querySelector('.delete-confirmation-title');
    const text = modal.querySelector('.delete-confirmation-text');
    const icon = modal.querySelector('.delete-confirmation-icon');
    const confirmBtn = modal.querySelector('.delete-confirmation-btn.confirm');
    
    if (action === 'everyone') {
        title.textContent = 'Delete for everyone?';
        text.textContent = 'This message will be deleted for everyone in the chat. This action cannot be undone.';
        icon.classList.remove('warning');
        icon.classList.add('danger');
        icon.innerHTML = '<i class="fas fa-trash-can"></i>';
        confirmBtn.classList.add('danger');
        confirmBtn.textContent = 'Delete for Everyone';
    } else {
        title.textContent = 'Delete for me?';
        text.textContent = 'This message will be deleted for you. Other chat members will still be able to see it.';
        icon.classList.remove('danger');
        icon.classList.add('warning');
        icon.innerHTML = '<i class="fas fa-trash"></i>';
        confirmBtn.classList.remove('danger');
        confirmBtn.textContent = 'Delete for Me';
    }
    
    modal.classList.add('active');
}

// Close delete confirmation modal
function closeDeleteConfirmation() {
    const modal = document.getElementById('deleteConfirmationModal');
    modal.classList.remove('active');
    currentDeleteMessageId = null;
    currentDeleteAction = null;
}

// Execute delete action
function executeDelete() {
    if (!currentDeleteMessageId || !currentDeleteAction) return;
    
    const msgIndex = messages[selectedChat].findIndex(m => m.id === currentDeleteMessageId);
    if (msgIndex === -1) return;
    
    if (currentDeleteAction === 'everyone') {
        // Delete for everyone - remove from messages completely
        messages[selectedChat].splice(msgIndex, 1);
        
        // Show notification
        showDeleteNotification('Message deleted for everyone');
    } else {
        // Delete for me - mark as deleted but keep in array
        messages[selectedChat][msgIndex].deletedForMe = true;
        
        // Actually remove it from display
        messages[selectedChat].splice(msgIndex, 1);
        
        // Show notification
        showDeleteNotification('Message deleted');
    }
    
    // Update UI
    renderMessages();
    closeDeleteConfirmation();
}

// Show delete notification
function showDeleteNotification(text) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = 'delete-notification';
    notification.innerHTML = `
        <i class="fas fa-check-circle"></i>
        <span>${text}</span>
    `;
    
    // Add to body
    document.body.appendChild(notification);
    
    // Trigger animation
    setTimeout(() => notification.classList.add('show'), 10);
    
    // Remove after 3 seconds
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Initialize menus on page load
document.addEventListener('DOMContentLoaded', () => {
    // Create message options menu if it doesn't exist
    if (!document.getElementById('messageOptionsMenu')) {
        const optionsMenu = document.createElement('div');
        optionsMenu.id = 'messageOptionsMenu';
        optionsMenu.className = 'message-options-menu';
        document.body.appendChild(optionsMenu);
    }
    
    // Create delete confirmation modal if it doesn't exist
    if (!document.getElementById('deleteConfirmationModal')) {
        const modal = document.createElement('div');
        modal.id = 'deleteConfirmationModal';
        modal.className = 'delete-confirmation-modal';
        modal.innerHTML = `
            <div class="delete-confirmation-content">
                <div class="delete-confirmation-header">
                    <div class="delete-confirmation-icon warning">
                        <i class="fas fa-trash"></i>
                    </div>
                    <h3 class="delete-confirmation-title">Delete message?</h3>
                </div>
                <p class="delete-confirmation-text">
                    This message will be deleted. This action cannot be undone.
                </p>
                <div class="delete-confirmation-actions">
                    <button class="delete-confirmation-btn cancel" onclick="closeDeleteConfirmation()">
                        Cancel
                    </button>
                    <button class="delete-confirmation-btn confirm" onclick="executeDelete()">
                        Delete
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Close on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeDeleteConfirmation();
            }
        });
    }
});
            </script>
</body>

</html>
