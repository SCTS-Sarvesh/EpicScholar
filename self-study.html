<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EpicScholar Dashboard | AI-Powered Study Platform</title>
    <link rel="stylesheet" href="self-study.css" />
    <style>
        /* =================================================================
 * CIRCULAR PROGRESS FIXES - COMPLETE REPLACEMENT
 * =================================================================
 */

        /* Fix for Overall Performance Circle */
        #overall-performance-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            position: relative;
        }

        #overall-performance-box .circular-progress-container {
            position: relative;
            width: 180px;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px auto;
        }

        #overall-performance-box .circular-progress {
            width: 180px;
            height: 180px;
            position: absolute;
            top: 0;
            left: 0;
        }

        #overall-performance-box .circular-progress svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            overflow: visible;
        }

        #overall-performance-box .progress-circle-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 12;
            cx: 90;
            cy: 90;
            r: 80;
            transform-box: fill-box;
        }

        .light-mode #overall-performance-box .progress-circle-bg {
            stroke: rgba(0, 0, 0, 0.1);
        }

        #overall-performance-box .progress-circle {
            fill: none;
            stroke-width: 12;
            stroke-linecap: round;
            cx: 90;
            cy: 90;
            r: 80;
            stroke-dasharray: 502.65;
            stroke-dashoffset: 502.65;
            transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Live Gradient Fill for Progress Circles */
        #overall-performance-box .progress-circle.excellent {
            stroke: url(#gradient-excellent);
            animation: progressGlow 2s ease-in-out infinite alternate;
        }

        #overall-performance-box .progress-circle.good {
            stroke: url(#gradient-good);
            animation: progressGlow 2s ease-in-out infinite alternate;
        }

        #overall-performance-box .progress-circle.average {
            stroke: url(#gradient-average);
            animation: progressGlow 2s ease-in-out infinite alternate;
        }

        #overall-performance-box .progress-circle.poor {
            stroke: url(#gradient-poor);
            animation: progressGlow 2s ease-in-out infinite alternate;
        }

        @keyframes progressGlow {
            0% {
                filter: drop-shadow(0 0 8px rgba(0, 114, 255, 0.5));
            }

            100% {
                filter: drop-shadow(0 0 16px rgba(0, 114, 255, 0.8));
            }
        }

        #overall-performance-box .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #overall-performance-box .progress-percentage {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #0072ff 0%, #ff416c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            display: block;
        }

        #overall-performance-box .progress-label {
            font-size: 0.85em;
            color: var(--subtext-dark);
            margin-top: 5px;
            font-weight: 600;
        }

        .light-mode #overall-performance-box .progress-label {
            color: var(--subtext-light);
        }

        /* Ensure the gradient is defined in the SVG */
        .session-sidebar .circular-progress svg defs {
            position: absolute;
        }

        /* Fix for Quiz Results Score Circle */
        .quiz-score-circle {
            width: 200px;
            height: 200px;
            margin: 2rem auto;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0072ff 0%, #ff416c 100%);
            box-shadow:
                0 20px 60px rgba(0, 114, 255, 0.4),
                inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            animation: scorePulse 2s ease-in-out infinite;
            position: relative;
        }

        .score-circle {
            width: 220px;
            height: 220px;
            margin: 2rem auto;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0072ff 0%, #ff416c 100%);
            box-shadow:
                0 20px 60px rgba(0, 114, 255, 0.4),
                inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            animation: scorePulse 2s ease-in-out infinite;
            position: relative;
        }

        @keyframes scorePulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow:
                    0 20px 60px rgba(0, 114, 255, 0.4),
                    inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            }

            50% {
                transform: scale(1.05);
                box-shadow:
                    0 25px 70px rgba(0, 114, 255, 0.6),
                    inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            }
        }

        .score-circle::before,
        .quiz-score-circle::before {
            content: '';
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0072ff 0%, #ff416c 100%);
            opacity: 0.3;
            filter: blur(20px);
            z-index: -1;
            animation: glowPulse 2s ease-in-out infinite;
        }

        @keyframes glowPulse {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .score-number,
        .quiz-score-number {
            font-size: 4.5rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            line-height: 1;
        }

        .score-label,
        .quiz-score-label {
            font-size: 1.3rem;
            opacity: 0.95;
            color: white;
            font-weight: 600;
            margin-top: 5px;
        }

        /* Enhanced SVG Gradients with Animation */
        svg defs linearGradient stop {
            transition: stop-color 0.5s ease;
        }

        /* Ensure proper SVG rendering */
        .circular-progress svg,
        svg {
            overflow: visible;
        }

        circle {
            vector-effect: non-scaling-stroke;
        }

        /* Additional polish for all progress circles */
        .progress-circle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Smooth transitions for all progress elements */
        .progress-circle,
        #ai-progress-circle {
            transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {

            #overall-performance-box .circular-progress-container,
            #overall-performance-box .circular-progress {
                width: 150px;
                height: 150px;
            }

            #overall-performance-box .progress-circle-bg,
            #overall-performance-box .progress-circle {
                cx: 75;
                cy: 75;
                r: 65;
            }

            #overall-performance-box .progress-percentage {
                font-size: 2em;
            }

            .score-circle,
            .quiz-score-circle {
                width: 180px;
                height: 180px;
            }

            .score-number,
            .quiz-score-number {
                font-size: 3.5rem;
            }
        }

        /* =================================================================
 * SESSION SIDEBAR PROGRESS CIRCLE FIX - Straight from top
 * =================================================================
 */




        /* Responsive adjustments */
        @media (max-width: 768px) {
            .session-sidebar .progress-circle-container {
                width: 100px;
                height: 100px;
            }

            .session-sidebar .circular-progress {
                width: 100px;
                height: 100px;
            }

            .session-sidebar .progress-text #ai-progress-percentage {
                font-size: 1.5em;
            }
        }

        /* Add to your <style> section */

        /* Disabled button styling */
        #quiz-prev-btn:disabled,
        #fs-prev-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Button hover states */
        #quiz-prev-btn:not(:disabled):hover,
        #quiz-next-btn:hover,
        #fs-prev-btn:not(:disabled):hover,
        #fs-next-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 114, 255, 0.3);
        }

        /* Submit button emphasis */
        #quiz-submit-btn,
        #fs-submit-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        #quiz-submit-btn:hover,
        #fs-submit-btn:hover {
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.6);
            transform: translateY(-3px) scale(1.02);
        }

        /* Add to your <style> section */

        /* Test completion card removal animation */
        @keyframes cardFadeOutScale {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.95) translateY(-10px);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-30px);
                max-height: 0;
                margin: 0;
                padding: 0;
            }
        }

        .session-card.test-completed {
            animation: cardFadeOutScale 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            pointer-events: none;
        }

        /* Success toast styling */
        .toast.test-complete {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.95) 0%, rgba(5, 150, 105, 0.95) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .toast.test-complete i {
            color: white;
        }

        .toast.test-complete span {
            color: white;
        }

        /* Add to your <style> section */

        /* =================================================================
 * ERROR DISPLAY STYLING
 * =================================================================
 */

        .error-display-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 3rem 2rem;
            text-align: center;
            animation: errorSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes errorSlideIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .error-icon {
            margin: 0 auto 2rem;
            animation: errorPulse 2s ease-in-out infinite;
        }

        @keyframes errorPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }

        .error-title {
            font-size: 1.8rem;
            color: var(--secondary-color);
            margin: 0 0 1.5rem 0;
            font-weight: 700;
        }

        .error-message {
            background: rgba(255, 65, 108, 0.1);
            border: 2px solid rgba(255, 65, 108, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            text-align: left;
        }

        .light-mode .error-message {
            background: rgba(255, 65, 108, 0.05);
        }

        .error-message p {
            margin: 0;
            color: var(--text-dark);
            line-height: 1.6;
        }

        .light-mode .error-message p {
            color: var(--text-light);
        }

        .error-suggestions {
            text-align: left;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .light-mode .error-suggestions {
            background: rgba(0, 0, 0, 0.02);
        }

        .error-suggestions h4 {
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        .error-suggestions ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .error-suggestions li {
            margin: 0.8rem 0;
            color: var(--text-dark);
            line-height: 1.5;
        }

        .light-mode .error-suggestions li {
            color: var(--text-light);
        }

        .error-suggestions strong {
            color: var(--primary-color);
        }

        .error-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
        }

        .error-actions button {
            min-width: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .error-help {
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-mode .error-help {
            border-top-color: rgba(0, 0, 0, 0.1);
        }

        .error-help p {
            color: var(--subtext-dark);
        }

        .light-mode .error-help p {
            color: var(--subtext-light);
        }
    </style>
</head>

<body class="dark-mode">
    <div id="liquid-glass-container">
        <div class="glass-blob blob-1"></div>
        <div class="glass-blob blob-2"></div>
        <div class="glass-blob blob-3"></div>
    </div>
    <!-- Page Loader -->
    <div id="page-loader">
        <div class="loader-spinner"></div>
        <div class="loader-text">Loading Self-study...</div>
    </div>
    <div id="sidebar-placeholder">
        <div class="sidebar glass-element fixed-top-layer">
            <div class="nav-wrap" id="navWrap">
                <a class="nav-item" href="home.html" data-icon="üè†">üè† Home </a>
                <a class="nav-item" href="messages.html" data-icon="‚úâÔ∏è">‚úâÔ∏è Messages</a>
                <a class="nav-item-active" href="self-study.html" data-icon="üìñ">üìñ Self-Study</a>
                <a class="nav-item" href="edubot.html" data-icon="ü§ñ">ü§ñ EduBot</a>
                <a class="nav-item" href="mini-games.html" data-icon="üéÆ">üéÆ Mini-Games</a>
            </div>

            <div class="settings-wrap">
                <a class="nav-item" href="profile.html" data-icon="üë§">üë§ Profile</a>
            </div>
        </div>
    </div>

    <main id="self-study-main">
        <header>
            <h1 class="gradient-text">EpicScholar Dashboard</h1>
            <div id="controls">
                <label class="toggle-switch">
                    <input type="checkbox" id="mode-toggle-checkbox">
                    <span class="toggle-slider"></span>
                </label>
                <button id="add-session-btn" class="action-btn">üìÖ Add Session</button>
                <button id="add-test-btn" class="action-btn">üìù Add Test</button>
            </div>
        </header>

        <section id="performance-dashboard">
            <h2 class="gradient-text">üìä Performance Dashboard</h2>
            <div class="dashboard-grid">
                <div id="overall-performance-box" class="floating-card glass-effect">
                    <div class="circular-progress-container">
                        <svg class="circular-progress" width="180" height="180">
                            <defs>
                                <linearGradient id="gradient-excellent" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#8BC34A;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="gradient-good" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#0072ff;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#00d4ff;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="gradient-average" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FFC107;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#FF9800;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="gradient-poor" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#ff416c;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#FF5252;stop-opacity:1" />
                                </linearGradient>
                            </defs>

                            <circle class="progress-circle-bg" cx="90" cy="90" r="80"></circle>

                            <circle class="progress-circle excellent" cx="90" cy="90" r="80" id="progress-circle"
                                stroke-dasharray="502" stroke-dashoffset="502">
                            </circle>
                        </svg>

                        <div class="progress-text">
                            <span class="progress-percentage" id="overall-percentage">88.5%</span>
                            <span class="progress-label">Overall</span>
                        </div>
                    </div>
                    <p>Overall Average Score</p>
                </div>

                <div id="subject-breakdown-box" class="floating-card glass-effect">
                    <h3 class="gradient-text">Subject Breakdown</h3>
                    <div class="subject-grid" id="subject-grid-container">
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="Math">
                            <span class="score gradient-text">92%</span>
                            <span class="subject-name">Math</span>
                        </div>
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="Science">
                            <span class="score gradient-text">85%</span>
                            <span class="subject-name">Science</span>
                        </div>
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="History">
                            <span class="score gradient-text">90%</span>
                            <span class="subject-name">History</span>
                        </div>
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="Physics">
                            <span class="score gradient-text">88%</span>
                            <span class="subject-name">Physics</span>
                        </div>
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="English">
                            <span class="score gradient-text">95%</span>
                            <span class="subject-name">English</span>
                        </div>
                        <div class="subject-score-box" data-action="toggle-marks" data-subject="Chemistry">
                            <span class="score gradient-text">83%</span>
                            <span class="subject-name">Chemistry</span>
                        </div>
                    </div>
                </div>

                <div class="floating-card glass-effect">
                    <h3 class="gradient-text">Weekly Study Time</h3>
                    <p style="font-size: 2.5em; font-weight: 700;">14h 30m</p>
                    <p style="font-size: 0.9em; color: var(--info-color);">+1.5h from last week</p>
                </div>
            </div>
        </section>

        <hr style="border-color: rgba(255,255,255,0.1);">

        <section id="sessions-tests">
            <div class="section-header">
                <h2 class="gradient-text">‚è≥ Upcoming Sessions & Tests</h2>
            </div>
            <div id="sessions-container">
            </div>
        </section>

        <hr style="border-color: rgba(255,255,255,0.1);">

        <section id="exam-timetable">
            <div class="section-header">
                <h2 class="gradient-text">üóìÔ∏è Exam Timetable</h2>
            </div>
            <div class="floating-card glass-effect timetable-container">
                <table>
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>Subject</th>
                            <th>Date</th>
                            <th>Time</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="timetable-body"></tbody>
                </table>
            </div>
        </section>

        <hr style="border-color: rgba(255,255,255,0.1);">

        <section id="resources">
            <div class="section-header">
                <h2 class="gradient-text">üìö Shared Resources</h2>
            </div>
            <div id="resources-container">
            </div>
        </section>
    </main>

    <!-- Session Form Modal -->
    <div id="session-form-modal" class="modal hidden">
        <div class="modal-content floating-card glass-effect">
            <button class="modal-close-btn" data-modal-id="session-form-modal">&times;</button>
            <h3 id="session-form-title" class="gradient-text">Add New Session</h3>
            <form id="session-form">
                <div class="form-group">
                    <label for="session-title">Topic Name</label>
                    <input type="text" id="session-title" name="title" required
                        placeholder="e.g., The French Revolution">
                </div>
                <div class="form-group">
                    <label for="session-subject">Subject</label>
                    <input type="text" id="session-subject" name="subject" required placeholder="e.g., History">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="session-date">Date</label>
                        <input type="date" id="session-date" name="date" required>
                    </div>
                    <div class="form-group">
                        <label for="session-time">Time</label>
                        <input type="time" id="session-time" name="time" required>
                    </div>
                </div>
                <div class="form-group">
                    <label for="session-duration">Duration</label>
                    <select id="session-duration" name="duration" required>
                        <option value="30">30 Minutes</option>
                        <option value="45">45 Minutes</option>
                        <option value="60" selected>1 Hour</option>
                        <option value="90">1 Hour 30 Minutes</option>
                        <option value="120">2 Hours</option>
                    </select>
                </div>
                <button type="submit" class="gradient-button">Save Session</button>
            </form>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-content floating-card glass-effect">
            <button class="modal-close-btn" data-modal-id="confirm-modal">&times;</button>
            <h3 class="gradient-text">Are you sure?</h3>
            <p id="confirm-modal-message">Do you really want to cancel this item?</p>
            <div id="confirm-buttons">
                <button id="confirm-btn-yes" class="gradient-button">Yes, Confirm</button>
                <button id="confirm-btn-no" class="secondary-button">No</button>
            </div>
        </div>
    </div>

    <!-- ‚≠ê NEW: Custom End Session Modal with Liquid Glass iOS26 Design -->
    <div id="end-session-modal" class="modal hidden" style="z-index: 99999;">
        <div class="end-session-modal-content">
            <div class="end-session-icon">
                <svg width="80" height="80" viewBox="0 0 80 80" fill="none">
                    <circle cx="40" cy="40" r="36" stroke="url(#endGradient)" stroke-width="4" opacity="0.3" />
                    <circle cx="40" cy="40" r="30" fill="url(#endGradient)" opacity="0.2" />
                    <path d="M35 25 L35 55 M45 25 L45 55" stroke="url(#endGradient)" stroke-width="6"
                        stroke-linecap="round" />
                    <defs>
                        <linearGradient id="endGradient" x1="0" y1="0" x2="80" y2="80">
                            <stop offset="0%" stop-color="#FF6B6B" />
                            <stop offset="100%" stop-color="#FF416C" />
                        </linearGradient>
                    </defs>
                </svg>
            </div>
            <h2 class="end-session-title">End Session?</h2>
            <p class="end-session-message" id="end-session-message-text">
                Are you sure you want to end this session? This will permanently remove it from your sessions list.
            </p>
            <div class="end-session-details" id="end-session-details">
                <div class="detail-item">
                    <span class="detail-label">Session:</span>
                    <span class="detail-value" id="end-session-name">-</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Duration:</span>
                    <span class="detail-value" id="end-session-duration">-</span>
                </div>
            </div>
            <div class="end-session-buttons">
                <button id="end-session-cancel-btn" class="end-session-btn cancel-btn">
                    <span>Cancel</span>
                </button>
                <button id="end-session-confirm-btn" class="end-session-btn confirm-btn">
                    <span>End Session</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Video Player Modal -->
    <div id="video-player-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-btn" data-modal-id="video-player-modal">&times;</button>
            <h3 id="video-title" class="gradient-text"></h3>
            <div class="video-wrapper">
                <iframe id="youtube-iframe" src="" allow="encrypted-media; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    </div>

    <!-- Marks Modal Popup - Enhanced with Better Styling -->
    <div id="marks-modal" class="marks-modal-overlay hidden">
        <div class="marks-modal-content floating-card glass-effect">
            <button class="modal-close-btn" onclick="closeMarksModal()">&times;</button>
            <h3 id="marks-modal-title" class="gradient-text">Subject Test History</h3>
            <div id="marks-modal-content">
                <!-- Test history items will be populated here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Live Session Page -->
    <div id="live-session-page" class="hidden">
        <div class="live-session-header-bar glass-effect">
            <h1 id="live-session-title" class="gradient-text"></h1>
            <div class="live-session-header-controls">
                <span id="live-session-timer">00:00</span>
                <button id="pause-session-btn" class="secondary-button">Pause Session</button>
                <button id="end-session-btn" class="action-btn">End Session</button>
            </div>
        </div>

        <div class="live-session-content-area">
            <h2 class="gradient-text">üìπ Video Resources & Edubot</h2>

            <div class="search-bar-live floating-card glass-effect">
                <input type="text" id="liveSearchInput" placeholder="Search YouTube for videos on this topic..." />
                <button id="liveSearchBtn" class="gradient-button">Refresh Videos</button>
            </div>

            <div class="loader" id="liveLoader">
                <div class="theme-loader"></div>
            </div>
            <section class="videos-section" id="videosSection"></section>
        </div>
    </div>

    <!-- Floating Icons -->
    <div id="pdf-icon" class="floating-action-icon">üìÑ</div>
    <div id="chatbot-icon" class="floating-action-icon">üí¨</div>

    <!-- Chatbot Container -->
    <div id="chatbot-container" class="floating-window">
        <div id="chatbot-header">
            <span>Edubot</span>
            <button id="close-btn">&times;</button>
        </div>
        <div id="chatbot-body">
            <div id="chatbot-messages"></div>
        </div>
        <div id="chatbot-input-container">
            <input type="text" id="chatbot-input" placeholder="Type a message..." />
            <button id="send-btn">Send</button>
        </div>
    </div>

    <!-- PDF Container -->
    <div id="pdf-container" class="floating-window">
        <div id="pdf-header">
            <span>Notes & PDFs</span>
            <button id="pdf-close-btn">&times;</button>
        </div>
        <div id="pdf-body">
            <div class="pdf-item">
                <h4>Chapter 5 - Thermodynamics.pdf</h4>
                <p>Uploaded 3 days ago</p>
            </div>
            <div class="pdf-item">
                <h4>WW1 Key Dates.pdf</h4>
                <p>Uploaded 1 week ago</p>
            </div>
        </div>
    </div>
    <!-- Quiz Modal - Add this before closing </body> tag -->
    <div id="quiz-modal" class="modal hidden">
        <div class="modal-content"
            style="width: 90%; max-width: 900px; max-height: 75vh; overflow-y: auto; display: flex; flex-direction: column;">
            <button class="modal-close-btn" data-modal-id="quiz-modal">&times;</button>

            <div id="quiz-loading" style="text-align: center; padding: 3rem;">
                <div class="theme-loader" style="margin: 0 auto;"></div>
                <p style="margin-top: 1rem; color: var(--text-dark);">Generating quiz questions...</p>
            </div>

            <div id="quiz-content" class="hidden">
                <div class="quiz-header" style="position: relative; margin-bottom: 2rem;">
                    <h2 id="quiz-topic-title" class="gradient-text" style="font-size: 1.8rem;">Quiz</h2>
                </div>

                <div class="question-nav" id="quiz-question-nav"
                    style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 2rem; flex-wrap: wrap;">
                </div>

                <div id="quiz-questions-wrapper"
                    style="position: relative; min-height: 300px; flex: 1; overflow-y: auto;"></div>

                <div id="quiz-nav-buttons" style="display: flex; gap: 1rem; margin-top: 2rem; flex-shrink: 0;">
                    <button class="secondary-button" id="quiz-prev-btn" onclick="quizPrevQuestion()">‚Üê Previous</button>
                    <button class="secondary-button" id="quiz-next-btn" onclick="quizNextQuestion()">Next ‚Üí</button>
                    <button class="gradient-button" id="quiz-submit-btn" onclick="submitQuizAnswers()"
                        style="display: none;">
                        Submit Quiz
                    </button>
                </div>

                <div id="quiz-results-container" style="display: none;"></div>
            </div>
        </div>
    </div>
    <!-- Toast Container for Notifications -->
    <!-- Full Screen Test Modal (Matches quiz.html style) -->
    <div id="full-screen-test-modal" class="full-screen-modal hidden">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
        <div class="blob blob-3"></div>

        <div class="fs-container">
            <!-- Loading State -->
            <div id="fs-loading" class="fs-card" style="text-align: center;">
                <div class="theme-loader" style="width: 60px; height: 60px; margin: 0 auto;"></div>
                <h2 class="gradient-text" style="margin-top: 20px;">Generating Full-Screen Test...</h2>
                <p style="opacity: 0.7;">Analyzing topic and crafting questions</p>
            </div>

            <!-- Quiz Content -->
            <div id="fs-quiz-section" class="fs-card hidden" style="width: 100%; max-width: 900px;">
                <div class="fs-header">
                    <h2 id="fs-quiz-title" class="gradient-text">Test Title</h2>
                    <button onclick="closeFullScreenTest()" class="icon-btn"
                        style="color: white; background: transparent; border: none; font-size: 1.5em; cursor: pointer;">‚úï</button>
                </div>

                <div class="fs-question-nav" id="fs-question-nav"></div>
                <div class="fs-questions-wrapper" id="fs-questions-wrapper"></div>

                <div class="fs-nav-buttons" id="fs-nav-buttons">
                    <button class="nav-btn" id="fs-prev-btn" onclick="fsPrevQuestion()">‚Üê Previous</button>
                    <button class="nav-btn" id="fs-next-btn" onclick="fsNextQuestion()">Next ‚Üí</button>
                    <button class="gradient-button" id="fs-submit-btn" onclick="fsSubmitQuiz()"
                        style="display: none; padding: 1rem;">Submit Test</button>
                </div>
            </div>

            <!-- Results -->
            <div id="fs-results-container" class="fs-card hidden" style="text-align: center;"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script> <!-- Added YouTube IFrame API -->
    <script>
        /* ============================================
        * ADD TO EXISTING <script> SECTION
        * Paste after the updateProgress() function (around line 1450)
        * ============================================ */

        // Ensure SVG viewBox is properly set for session progress circle
        document.addEventListener('DOMContentLoaded', function () {
            const sessionProgressSVG = document.querySelector('.session-sidebar .circular-progress svg');
            if (sessionProgressSVG) {
                // Set viewBox to match circle dimensions for proper scaling
                sessionProgressSVG.setAttribute('viewBox', '0 0 120 120');
                sessionProgressSVG.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            }
        });
        // Add these global variables at the beginning of your script
        let sessionQuizzes = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let currentSessionIndex = 0;
        // Global variable to store the origin position
        let marksModalOrigin = { x: 0, y: 0 };
        // =================================================================
        // DATA STORE & GLOBAL CONFIG
        // =================================================================

        // ‚ö†Ô∏è IMPORTANT: Replace these with your actual keys
        const YOUTUBE_API_KEY = "AIzaSyB60v4uvMzU0uHNE3lYCEdFxkWJPzkdafA";
        const GEMINI_API_KEY = "AIzaSyBQ5zThdglOxxu45SyBTAaWSY5OUhvr_e4";

        const DEFAULT_GRADE = "Grade 9";
        const DEFAULT_CURRICULUM = "NCERT";

        // Default Data - Using timestamp-based IDs for consistency
        const defaultSessions = [
            { id: Date.now() - 10000, title: "Quick Geometry Recap", type: "Session", subject: "Math", duration: 45, datetime: new Date(new Date().getTime() - 3600000).toISOString() },
            { id: Date.now() - 5000, title: "The French Revolution", type: "Test", subject: "History", duration: 60, datetime: new Date(new Date().getTime() + 120000).toISOString() },
            { id: Date.now(), title: "Laws of Motion (Revision)", type: "Session", subject: "Physics", duration: 90, datetime: new Date(new Date().getTime() + 86400000).toISOString() }
        ];
        const defaultTimetable = [
            { title: "Midterm Exam", subject: "Calculus", date: "2026-01-10", time: "09:00 AM", status: "Upcoming" },
            { title: "Final Project Due", subject: "Computer Science", date: "2026-01-25", time: "11:59 PM", status: "Drafting" }
        ];
        const defaultResources = [
            { type: "pdf", title: "Thermodynamics Chapter 5 Notes", subject: "Physics" },
            { type: "video", title: "Calculus Integration Tutorial", subject: "Math" },
            { type: "photo", title: "WWI Key Dates Infographic", subject: "History" }
        ];

        // ‚ú® NEW: Placeholder data for previous marks/test history
        const previousMarksData = {
            "Math": [
                { name: "Test 1: Algebra", score: "95%" },
                { name: "Test 2: Geometry", score: "89%" },
                { name: "Quiz 1: Trigonometry", score: "93%" }
            ],
            "Science": [
                { name: "Test 1: Biology", score: "88%" },
                { name: "Test 2: Physics", score: "82%" }
            ],
            "History": [
                { name: "Test 1: WW1", score: "90%" },
                { name: "Test 2: Ancient Civilizations", score: "91%" }
            ],
            "Physics": [
                { name: "Test 1: Motion", score: "90%" },
                { name: "Test 2: Optics", score: "86%" }
            ],
            "English": [
                { name: "Essay 1", score: "94%" },
                { name: "Grammar Test", score: "96%" }
            ],
            "Chemistry": [
                { name: "Test 1: Moles", score: "80%" },
                { name: "Test 2: Bonds", score: "86%" }
            ]
        };

        // Main Data Arrays
        let sessions = [];
        let examTimetableData = [];
        let resourcesData = [];

        let sessionToCancel = null;
        let sessionToEdit = null;
        let currentSessionId = null;
        let currentNextPageToken = null;
        let sessionTimerInterval = null;
        let sessionStartTime = 0;
        let sessionActualStartTime = 0; // NEW: Track the real first start time for display
        let sessionElapsedSeconds = 0;
        let sessionTotalDuration = 0;
        let sessionPaused = false;
        let pausedSessionData = null; // NEW: Store paused session data
        // ============================================
        // QUIZ NAVIGATION FUNCTIONS - Add after line 2450
        // ============================================

        /**
         * Navigate to previous question in quiz modal
         */
        function quizPrevQuestion() {
            if (quizCurrentQuestion > 0) {
                quizCurrentQuestion--;
                renderQuizQuestions();
                renderQuizNavDots();
                updateQuizNavigationButtons();
            }
        }

        /**
         * Navigate to next question in quiz modal
         */
        function quizNextQuestion() {
            if (quizCurrentQuestion < quizQuestions.length - 1) {
                quizCurrentQuestion++;
                renderQuizQuestions();
                renderQuizNavDots();
                updateQuizNavigationButtons();
            }
        }

        /**
         * Navigate to previous question in full-screen test
         */
        function fsPrevQuestion() {
            if (fsCurrent > 0) {
                fsCurrent--;
                renderFsQuestion();
                renderFsNav();
            }
        }

        /**
         * Navigate to next question in full-screen test
         */
        function fsNextQuestion() {
            if (fsCurrent < fsQuestions.length - 1) {
                fsCurrent++;
                renderFsQuestion();
                renderFsNav();
            }
        }

        /**
         * Select an answer in quiz modal
         */
        function selectQuizAnswer(questionIndex, answer) {
            if (!quizShowResults) {
                quizSelectedAnswers[questionIndex] = answer;
                renderQuizNavDots();
                renderQuizQuestions();
                updateQuizNavigationButtons();
            }
        }

        /**
         * Go to specific question in quiz modal
         */
        function goToQuizQuestion(idx) {
            quizCurrentQuestion = idx;
            renderQuizQuestions();
            renderQuizNavDots();
            updateQuizNavigationButtons();
        }

        /**
         * Select an answer in full-screen test
         */
        function selectFsAnswer(ans) {
            fsSelected[fsCurrent] = ans;
            renderFsQuestion();
            renderFsNav();
        }

        /**
         * Go to specific question in full-screen test
         */
        function goToFsQuestion(idx) {
            fsCurrent = idx;
            renderFsQuestion();
            renderFsNav();
        }

        /**
         * Update navigation button states in quiz modal
         */
        function updateQuizNavigationButtons() {
            const prevBtn = document.getElementById('quiz-prev-btn');
            const nextBtn = document.getElementById('quiz-next-btn');
            const submitBtn = document.getElementById('quiz-submit-btn');

            if (prevBtn) prevBtn.disabled = quizCurrentQuestion === 0;

            const isLastQuestion = quizCurrentQuestion === quizQuestions.length - 1;
            const allAnswered = Object.keys(quizSelectedAnswers).length === quizQuestions.length;

            if (nextBtn) nextBtn.style.display = isLastQuestion ? 'none' : 'block';
            if (submitBtn) submitBtn.style.display = (isLastQuestion && allAnswered) ? 'block' : 'none';
        }
        // =================================================================
        // AI SESSION STATE & DATA (NEW)
        // =================================================================

        let aiSessionState = {
            active: false,
            topic: "",
            subject: "",
            concepts: [],
            currentConceptIndex: 0,
            videoWatched: false,
            quizAnswered: false,
            scores: {},
            overallProgress: 0
        };

        // =================================================================
        // GEMINI API CONFIGURATION
        // =================================================================

        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;

        async function generateAIQuiz(topic, subject, numQuestions = 5) {
            const prompt = `Generate ${numQuestions} multiple-choice quiz questions about "${topic}" in ${subject} for ${DEFAULT_GRADE} students following ${DEFAULT_CURRICULUM} curriculum.

For each question, provide:
1. Clear question text that tests understanding
2. Four distinct answer options (A, B, C, D)
3. The correct answer letter
4. Brief explanation (2-3 sentences)

Respond ONLY with valid JSON (no markdown, no backticks):
{
  "questions": [
    {
      "question": "Question text?",
      "options": {
        "A": "First option",
        "B": "Second option",
        "C": "Third option",
        "D": "Fourth option"
      },
      "correct": "A",
      "explanation": "Explanation text"
    }
  ]
}`;

            try {
                console.log(`ü§ñ AI Generating ${numQuestions} quiz questions for: ${topic}`);

                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 16384,
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('‚ùå AI Quiz API Error:', errorData);

                    // ‚≠ê NEW: Throw detailed error instead of fallback
                    let errorMessage = 'Failed to generate quiz';

                    if (response.status === 403) {
                        errorMessage = 'Invalid API Key - Please check your Gemini API key';
                    } else if (response.status === 429) {
                        errorMessage = 'API Rate Limit Exceeded - Please wait a moment and try again';
                    } else if (response.status === 500) {
                        errorMessage = 'Gemini API Server Error - Please try again later';
                    } else if (errorData.error?.message) {
                        errorMessage = errorData.error.message;
                    }

                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]) {
                    throw new Error('Invalid API response - No candidates returned');
                }

                let text = data.candidates[0].content.parts[0].text;
                console.log('üìù Raw AI Quiz Response:', text);

                // Clean response
                text = text.trim()
                    .replace(/```json\n?/g, '')
                    .replace(/```\n?/g, '')
                    .trim();

                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (!jsonMatch) throw new Error('Could not parse JSON from AI response');

                const quizData = JSON.parse(jsonMatch[0]);

                if (!quizData.questions || !Array.isArray(quizData.questions)) {
                    throw new Error('Invalid quiz data structure from AI');
                }

                console.log('‚úÖ AI Quiz Generated:', quizData.questions.length, 'questions');
                return quizData.questions;

            } catch (error) {
                console.error('‚ùå AI Quiz Generation Error:', error);

                // ‚≠ê NEW: Re-throw the error instead of using fallback
                throw error; // This will propagate to the calling function
            }
        }
        async function generateTopicBreakdown(topic, subject) {
            const prompt = `Generate a structured learning plan for the topic: "${topic}" in the subject: "${subject}" for ${DEFAULT_GRADE} students following ${DEFAULT_CURRICULUM} curriculum.

Break it down into 3-5 key concepts that should be learned in sequence, from basic to advanced.
For each concept, provide:
1. A clear concept name (2-5 words)
2. A YouTube search query to find relevant educational videos

Respond ONLY with valid JSON in this exact format (no markdown, no backticks):
[
  {
    "name": "Concept Name",
    "videoQuery": "search query for YouTube educational video"
  }
]`;

            try {
                console.log(`ü§ñ AI GENERATING TOPIC BREAKDOWN: ${topic} in ${subject}`);

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 2048,
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('‚ùå Topic API Error:', errorData);

                    // ‚≠ê NEW: Detailed error
                    let errorMessage = 'Failed to generate topic breakdown';

                    if (response.status === 403) {
                        errorMessage = 'Invalid API Key';
                    } else if (response.status === 429) {
                        errorMessage = 'API Rate Limit Exceeded';
                    } else if (errorData.error?.message) {
                        errorMessage = errorData.error.message;
                    }

                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]) {
                    throw new Error('Invalid response from API');
                }

                let generatedText = data.candidates[0].content.parts[0].text;
                console.log('üìù Raw Topic Breakdown:', generatedText);

                generatedText = generatedText.trim()
                    .replace(/```json\n?/g, '')
                    .replace(/```\n?/g, '')
                    .trim();

                const jsonMatch = generatedText.match(/\[[\s\S]*\]/);
                if (!jsonMatch) throw new Error('Invalid JSON response from AI');

                const concepts = JSON.parse(jsonMatch[0]);

                if (!Array.isArray(concepts) || concepts.length === 0) {
                    throw new Error('Invalid concepts array');
                }

                const formattedConcepts = concepts.map((concept, index) => ({
                    id: index + 1,
                    title: concept.name,
                    videoQuery: concept.videoQuery,
                    quiz: null
                }));

                console.log('‚úÖ Topic Breakdown Generated:', formattedConcepts);
                return formattedConcepts;

            } catch (error) {
                console.error('‚ùå Topic Breakdown Error:', error);

                // ‚≠ê NEW: Re-throw error instead of fallback
                throw error;
            }
        }
        async function generateQuizQuestion(conceptTitle, subject) {
            const prompt = `Create ONE multiple-choice quiz question to test understanding of: "${conceptTitle}" in ${subject} for ${DEFAULT_GRADE} students following ${DEFAULT_CURRICULUM} curriculum.

Requirements:
- 1 clear, specific question that tests understanding (not just memorization)
- 4 distinct and plausible answer options
- Indicate which option index (0-3) is correct
- Include a helpful explanation (2-3 sentences) that teaches the concept

Respond ONLY with valid JSON in this exact format (no markdown, no backticks, no extra text):
{
  "question": "Question text?",
  "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
  "correctIndex": 0,
  "explanation": "Clear explanation text"
}`;

            try {
                console.log(`ü§ñ AI GENERATING QUIZ: ${conceptTitle} in ${subject}`);

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }],
                        generationConfig: {
                            temperature: 0.8,
                            maxOutputTokens: 1024,
                            topP: 0.95,
                            topK: 40
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('‚ùå API Error:', errorData);

                    // ‚≠ê NEW: Detailed error messages
                    let errorMessage = 'Failed to generate quiz question';

                    if (response.status === 403) {
                        errorMessage = 'Invalid API Key';
                    } else if (response.status === 429) {
                        errorMessage = 'API Rate Limit Exceeded';
                    } else if (errorData.error?.message) {
                        errorMessage = errorData.error.message;
                    }

                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                    throw new Error('Invalid response structure from Gemini API');
                }

                let generatedText = data.candidates[0].content.parts[0].text;
                console.log('üìù Raw AI Response:', generatedText);

                generatedText = generatedText.trim()
                    .replace(/```json\n?/g, '')
                    .replace(/```\n?/g, '')
                    .replace(/^json\n?/gi, '')
                    .trim();

                const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Could not parse JSON from AI response');
                }

                const quizData = JSON.parse(jsonMatch[0]);

                if (!quizData.question || !Array.isArray(quizData.options) ||
                    quizData.options.length !== 4 ||
                    typeof quizData.correctIndex !== 'number' ||
                    quizData.correctIndex < 0 || quizData.correctIndex > 3 ||
                    !quizData.explanation) {
                    throw new Error('Quiz data structure is invalid');
                }

                console.log('‚úÖ AI Quiz Generated Successfully:', quizData);
                return quizData;

            } catch (error) {
                console.error('‚ùå Quiz Generation Error:', error);

                // ‚≠ê NEW: Re-throw error instead of fallback
                throw error;
            }
        }
        function generateFallbackConcepts(topic, subject) {
            return [
                { id: 1, title: `Intro to ${topic}`, videoQuery: `${topic} ${subject} introduction`, quiz: null },
                { id: 2, title: `Key Concepts: ${topic}`, videoQuery: `${topic} ${subject} key concepts`, quiz: null },
                { id: 3, title: `Applications of ${topic}`, videoQuery: `${topic} ${subject} applications`, quiz: null }
            ];
        }

        // Replaces old breakdownTopicIntoConcepts
        async function breakdownTopicIntoConcepts(topic, subject) {
            // Show loading indicator
            const loadingMsg = document.createElement('div');
            loadingMsg.id = 'ai-loading-indicator';
            loadingMsg.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; color: white; flex-direction: column;">
                    <div class="theme-loader" style="width: 50px; height: 50px; border-width: 4px;"></div>
                    <h2 style="margin-top: 20px; font-weight: 300;">Generating AI Session Plan...</h2>
                    <p style="opacity: 0.7; margin-top: 10px;">Analyzing ${topic} using Gemini AI</p>
                </div>
            `;
            document.body.appendChild(loadingMsg);

            try {
                return await generateTopicBreakdown(topic, subject);
            } finally {
                const indicator = document.getElementById('ai-loading-indicator');
                if (indicator) indicator.remove();
            }
        }
        // ============================================
        // ERROR DISPLAY FUNCTIONS - Add after line 1500
        // ============================================

        /**
         * Display error message with retry option
         */
        function showQuizError(container, errorMessage, retryCallback) {
            container.innerHTML = `
        <div class="error-display-container">
            <div class="error-icon">
                <svg width="80" height="80" viewBox="0 0 80 80" fill="none">
                    <circle cx="40" cy="40" r="36" stroke="#ff416c" stroke-width="3" opacity="0.3"/>
                    <path d="M40 25 L40 45 M40 55 L40 57" stroke="#ff416c" stroke-width="6" stroke-linecap="round"/>
                </svg>
            </div>
            <h3 class="error-title">‚ö†Ô∏è Quiz Generation Failed</h3>
            <div class="error-message">
                <p><strong>Error:</strong> ${errorMessage}</p>
            </div>
            <div class="error-actions">
                <button class="gradient-button" onclick="${retryCallback}">
                    <i class="fa-solid fa-rotate-right"></i> Try Again
                </button>
                <button class="secondary-button" onclick="closeErrorModal()">
                    Cancel
                </button>
            </div>
            <div class="error-help">
                <p style="font-size: 0.9em; opacity: 0.7; margin-top: 20px;">
                    Need help? Check the browser console (F12) for detailed error logs.
                </p>
            </div>
        </div>
    `;
        }

        /**
         * Close error modal
         */
        function closeErrorModal() {
            const modal = document.getElementById('full-screen-test-modal');
            const quizModal = document.getElementById('quiz-modal');

            if (modal && !modal.classList.contains('hidden')) {
                closeFullScreenTest();
            }

            if (quizModal && !quizModal.classList.contains('hidden')) {
                closeQuizModal();
            }
        }
        // ============================================
        // UPDATED INIT AI SESSION
        // Replace your existing initAISession function
        // ============================================
        async function initAISession(topic, subject, duration = 60, originalSessionId = null) {
            aiSessionState.active = true;
            aiSessionState.topic = topic;
            aiSessionState.subject = subject;
            aiSessionState.currentConceptIndex = 0;
            aiSessionState.videoWatched = false;
            aiSessionState.quizAnswered = false;
            aiSessionState.scores = {};
            aiSessionState.concepts = [];

            // Create a temporary session object
            const tempSession = {
                id: Date.now(),
                title: topic,
                subject: subject,
                type: 'Session',
                datetime: new Date().toISOString(),
                duration: duration,
                originalSessionId: originalSessionId,
                isTemporary: true  // ‚≠ê Mark as temporary
            };

            // ‚≠ê Add temp session to sessions array (so pause/end can find it)
            sessions.push(tempSession);
            console.log('‚úÖ Temporary AI session added:', tempSession.id);

            // Open the live session page
            openLiveSession(tempSession);

            // Fetch concepts asynchronously
            try {
                const concepts = await breakdownTopicIntoConcepts(topic, subject);
                aiSessionState.concepts = concepts;

                // Render AI session layout and load first concept
                renderAISessionLayout();
                loadConcept(0);
            } catch (error) {
                console.error("Failed to init AI session:", error);
                alert("Failed to generate session plan. Please check your API key.");
            }
        }

        // Find your loadConcept function (around line 1850) and update it:

        async function loadConcept(index) {
            if (index < 0 || index >= aiSessionState.concepts.length) {
                showAISessionCompletion();
                return;
            }

            // ‚≠ê FIX: Update current index FIRST
            aiSessionState.currentConceptIndex = index;

            // ‚≠ê FIX: Don't reset video/quiz state when resuming
            const isResuming = pausedSessionData && pausedSessionData.isAISession;

            if (!isResuming) {
                aiSessionState.videoWatched = false;
                aiSessionState.quizAnswered = false;
            }

            const concept = aiSessionState.concepts[index];

            console.log(`üìö Loading concept ${index + 1}/${aiSessionState.concepts.length}: ${concept.title}`);

            // Update sidebar to show current concept
            renderConceptsSidebar();

            // Hide quiz initially (unless resuming after quiz completion)
            const quizContainer = document.getElementById('ai-quiz-container');
            if (quizContainer && !isResuming) {
                quizContainer.style.display = 'none';
            }

            // Load video
            try {
                await searchAndPlayVideo(concept.videoQuery, concept.title);
            } catch (error) {
                console.error('Error loading video:', error);
                const videoContainer = document.getElementById('ai-video-container');
                if (videoContainer) {
                    const titleElement = videoContainer.querySelector('h3');
                    if (titleElement) titleElement.textContent = `Current Topic: ${concept.title}`;

                    const wrapper = videoContainer.querySelector('.ai-video-wrapper');
                    if (wrapper) {
                        wrapper.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: var(--warning-color);">
                        <i class="fa-solid fa-exclamation-triangle" style="font-size: 3em; margin-bottom: 20px;"></i>
                        <p>Could not load video. You can skip to the quiz.</p>
                    </div>
                `;
                    }
                }
            }
        }
        function renderAISessionLayout() {
            // The live session page is already open via openLiveSession
            // We just need to replace the content with the AI layout

            const liveSessionContent = document.querySelector('.live-session-content-area');
            if (!liveSessionContent) {
                console.error('Live session content area not found');
                return;
            }

            // Inject the AI session layout (replacing YouTube search interface)
            liveSessionContent.innerHTML = `
                <div class="ai-session-container">
                    <div class="session-main-content">
                        <h2 class="gradient-text">üìö ${aiSessionState.topic}</h2>
                        
                        <!-- Video Container -->
                        <div class="ai-video-container" id="ai-video-container">
                            <h3 style="margin-top: 0;">Current Topic: Loading...</h3>
                            <div class="ai-video-wrapper" id="ai-video-wrapper">
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                                    <div class="theme-loader"></div>
                                    <p style="margin-top: 20px; color: var(--subtext-dark);">Searching for educational video...</p>
                                </div>
                            </div>
                        </div>

                        <!-- Quiz Container (Hidden Initially) -->
                        <div class="ai-quiz-container" id="ai-quiz-container" style="display: none;">
                            <div class="quiz-header">
                                <h3 class="gradient-text">üìù Quiz Time!</h3>
                                <p style="margin: 0; color: var(--subtext-dark);">Answer the question to proceed</p>
                            </div>
                            <div id="ai-quiz-content"></div>
                        </div>
                    </div>

                    <!-- Right Sidebar -->
                    <div class="session-sidebar">
                        <h3 class="gradient-text" style="font-size: 1.2em; margin: 0 0 15px 0;">üìã Concepts</h3>
                        
                        <!-- NEW: Linear Progress Bar (The 'Straight' one) -->
                        <div class="linear-progress-wrapper" style="margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.8em; margin-bottom: 8px; color: var(--subtext-dark); font-weight: 600;">
                                <span>Overall Progress</span>
                                <span id="ai-progress-percentage-linear">0%</span>
                            </div>
                            <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.08); border-radius: 10px; overflow: hidden; border: 1px solid rgba(255,255,255,0.1);">
                                <div id="ai-progress-bar-fill" style="width: 0%; height: 100%; background: var(--gradient); transition: width 1.2s cubic-bezier(0.34, 1.56, 0.64, 1); box-shadow: 0 0 15px rgba(0, 114, 255, 0.6);"></div>
                            </div>
                        </div>

                        <div class="concepts-list" id="concepts-list"></div>

                        <hr style="border-color: rgba(255,255,255,0.1); margin: 25px 0;">

                        <div class="progress-circle-container">
                            <div class="circular-progress">
                                <svg width="120" height="120">
                                    <circle cx="60" cy="60" r="50" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="8"></circle>
                                    <circle cx="60" cy="60" r="50" fill="none" stroke="url(#gradient)" stroke-width="8" 
                                        stroke-dasharray="314" stroke-dashoffset="314" id="ai-progress-circle"></circle>
                                    <defs>
                                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:#0072ff" />
                                            <stop offset="100%" style="stop-color:#ff416c" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="progress-text">
                                    <span id="ai-progress-percentage">0%</span>
                                    <span class="progress-label">Complete</span>
                                </div>
                            </div>
                        </div>


                    </div>
                </div>
            `;
        }


        // =================================================================
        // DOM ELEMENT REFERENCES
        // =================================================================
        const body = document.body;
        const mainContent = document.getElementById('self-study-main');
        const modeToggleCheckbox = document.getElementById('mode-toggle-checkbox');
        const sessionsContainer = document.getElementById('sessions-container');
        const timetableBody = document.getElementById('timetable-body');
        const resourcesContainer = document.getElementById('resources-container');

        // Modals
        const confirmModal = document.getElementById('confirm-modal');
        const videoPlayerModal = document.getElementById('video-player-modal');
        const sessionFormModal = document.getElementById('session-form-modal');
        const sessionForm = document.getElementById('session-form');
        const sessionFormTitle = document.getElementById('session-form-title');
        const marksModal = document.getElementById('marks-modal');

        const youtubeIframe = document.getElementById('youtube-iframe');
        const liveSessionPage = document.getElementById('live-session-page');

        // Live Session
        const liveSessionTimer = document.getElementById('live-session-timer');
        const pauseSessionBtn = document.getElementById('pause-session-btn');
        const endSessionBtn = document.getElementById('end-session-btn');
        const liveTakeTestBtn = document.getElementById('live-take-test-btn');
        const liveSearchInput = document.getElementById('liveSearchInput');
        const liveSearchBtn = document.getElementById('liveSearchBtn');
        const liveLoader = document.getElementById('liveLoader');
        const videosSection = document.getElementById('videosSection');

        // Chatbot & PDF Icons
        const pdfIcon = document.getElementById("pdf-icon");
        const chatbotIcon = document.getElementById("chatbot-icon");
        const chatbotContainer = document.getElementById("chatbot-container");
        const chatCloseBtn = document.getElementById("close-btn");
        const sendBtn = document.getElementById("send-btn");
        const chatInput = document.getElementById("chatbot-input");
        const chatbotMessages = document.getElementById("chatbot-messages");

        const pdfContainer = document.getElementById("pdf-container");
        const pdfCloseBtn = document.getElementById("pdf-close-btn");


        // =================================================================
        // LOCAL STORAGE FUNCTIONS
        // =================================================================

        function saveDataToLocalStorage() {
            // ‚≠ê FIX: Don't save temporary AI sessions to localStorage
            const permanentSessions = sessions.filter(s => !s.isTemporary);
            localStorage.setItem('epicScholarSessions', JSON.stringify(permanentSessions));
            localStorage.setItem('epicScholarTimetable', JSON.stringify(examTimetableData));
            localStorage.setItem('epicScholarResources', JSON.stringify(resourcesData));
        }

        function loadDataFromLocalStorage() {
            const savedSessions = localStorage.getItem('epicScholarSessions');
            const savedTimetable = localStorage.getItem('epicScholarTimetable');
            const savedResources = localStorage.getItem('epicScholarResources');

            // ‚≠ê FIX: Migrate old session IDs to timestamp format
            let loadedSessions = savedSessions ? JSON.parse(savedSessions) : defaultSessions;

            // Check if sessions have old-style IDs (small numbers like 1, 2, 3)
            const hasOldIds = loadedSessions.some(s => s.id < 1000000000000); // Timestamps are 13 digits

            if (hasOldIds) {
                console.log('‚öôÔ∏è Migrating old session IDs to timestamp format...');
                loadedSessions = loadedSessions.map((session, index) => ({
                    ...session,
                    id: Date.now() + index // Convert to timestamp
                }));
                // Save migrated sessions
                localStorage.setItem('epicScholarSessions', JSON.stringify(loadedSessions));
                console.log('‚úÖ Session IDs migrated successfully');
            }

            sessions = loadedSessions;
            examTimetableData = savedTimetable ? JSON.parse(savedTimetable) : defaultTimetable;
            resourcesData = savedResources ? JSON.parse(savedResources) : defaultResources;

            // ‚≠ê FIX: Recover temporary AI session if it was paused/active
            const paused = JSON.parse(localStorage.getItem('epicScholarPausedSession') || 'null');
            if (paused && paused.isAISession && paused.id) {
                const exists = sessions.some(s => Number(s.id) === Number(paused.id));
                if (!exists) {
                    sessions.push({
                        id: Number(paused.id),
                        title: paused.sessionTitle,
                        subject: paused.sessionSubject,
                        type: paused.sessionType || 'Session',
                        duration: (paused.totalDuration || 0) / 60,
                        originalSessionId: paused.originalSessionId,
                        isTemporary: true
                    });
                    console.log('‚úÖ Recovered temporary AI session from pause data:', paused.id);
                }
            }
        }

        // =================================================================
        // UTILITY & RENDER FUNCTIONS
        // =================================================================

        const revealCards = (containerSelector) => {
            document.querySelectorAll(`${containerSelector} .floating-card`).forEach((card, index) => {
                card.classList.remove('card-reveal');
                void card.offsetWidth;
                card.style.animationDelay = `${index * 100}ms`;
                card.classList.add('card-reveal');
            });
        };

        const openModal = (modalEl) => {
            modalEl.classList.remove('hidden', 'hiding');
        };

        const closeModal = (modalEl) => {
            modalEl.classList.add('hiding');
            modalEl.addEventListener('animationend', () => {
                modalEl.classList.add('hidden');
                modalEl.classList.remove('hiding');
                if (modalEl.id === 'video-player-modal') {
                    youtubeIframe.src = "";
                    document.getElementById('video-title').textContent = "";
                }
                if (modalEl.id === 'session-form-modal') {
                    sessionForm.reset();
                    sessionToEdit = null;
                    delete sessionForm.dataset.editId;
                }
            }, { once: true });
        };

        const playVideoInModal = (videoId, title) => {
            const embedUrl = `https://www.youtube.com/embed/${videoId}?rel=0`;
            youtubeIframe.src = embedUrl;
            document.getElementById('video-title').textContent = title;
            openModal(videoPlayerModal);
        };

        const parseISODuration = (duration) => {
            if (!duration) return "0:00";

            const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
            if (!match) return "0:00";

            const hours = parseInt(match[1] || 0);
            const minutes = parseInt(match[2] || 0);
            const seconds = parseInt(match[3] || 0);

            let result = "";
            if (hours > 0) {
                result += `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                result += `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            return result;
        };

        // Replace your existing renderSessions function (around line 1450)
        const renderSessions = () => {
            sessionsContainer.innerHTML = '';

            // Filter out temporary AI sessions
            const permanentSessions = sessions.filter(s => !s.isTemporary);
            console.log('üé® Rendering sessions:', {
                total: sessions.length,
                permanent: permanentSessions.length,
                filtered: sessions.filter(s => s.isTemporary).length
            });
            // Empty State Check
            if (permanentSessions.length === 0) {
                sessionsContainer.innerHTML = `
            <div class="empty-state-container">
                <img src="no-sessions.png" alt="No sessions" class="empty-state-image" />
                <div class="empty-state-content">
                    <h2 class="empty-state-title">No Active Sessions</h2>
                    <p class="empty-state-message">Start your learning journey by creating a study session.</p>
                    <button class="empty-state-button" onclick="document.getElementById('add-session-btn').click()">
                        <span>‚ú®</span> Create Session
                    </button>
                </div>
            </div>`;
                return;
            }

            sessions.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));

            // Load states from storage
            let pausedSession = null;
            let activeSession = null;
            try {
                const savedPaused = localStorage.getItem('epicScholarPausedSession');
                if (savedPaused) pausedSession = JSON.parse(savedPaused);

                const savedActive = localStorage.getItem('epicScholarActiveSession');
                if (savedActive) activeSession = JSON.parse(savedActive);
            } catch (e) { console.error("Error loading session states", e); }

            sessions.forEach(session => {
                if (session.isTemporary) return;

                const card = document.createElement('div');
                card.className = 'session-card floating-card glass-effect';
                card.setAttribute('data-id', session.id);

                const sessionDate = new Date(session.datetime);
                const formattedDate = sessionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const formattedTime = sessionDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                // Check if this session is paused or active
                let isPaused = pausedSession && Number(pausedSession.id) === Number(session.id);
                let isActive = activeSession && Number(activeSession.id) === Number(session.id) && !isPaused;

                // ‚≠ê NEW: Check if an AI session linked to THIS session is active or paused
                const linkedAIPaused = pausedSession && Number(pausedSession.originalSessionId) === Number(session.id);
                const linkedAIActive = activeSession && Number(activeSession.originalSessionId) === Number(session.id) && !linkedAIPaused;

                let remainingSeconds = 0;
                let statusBadge = '';
                let resumeTimeStr = '';

                const formatResumeTime = (s) => {
                    const mins = Math.floor(Math.max(0, s) / 60);
                    const secs = Math.floor(Math.max(0, s) % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };

                if (isPaused || linkedAIPaused) {
                    const data = pausedSession;
                    isPaused = true;
                    remainingSeconds = (data.totalDuration || 0) - (data.elapsedSeconds || 0);
                    statusBadge = '<span class="status-badge status-drafting" style="margin-left:8px">‚è∏Ô∏è PAUSED</span>';
                    resumeTimeStr = `(Resume from ${formatResumeTime(remainingSeconds)})`;
                } else if (isActive || linkedAIActive) {
                    const data = activeSession;
                    isActive = true;
                    remainingSeconds = (data.totalDuration || 0) - (data.elapsedSeconds || 0);
                    statusBadge = '<span class="status-badge status-upcoming" style="margin-left:8px">‚ö° ACTIVE</span>';
                    resumeTimeStr = `(Resume from ${formatResumeTime(remainingSeconds)})`;
                }

                const formatRemaining = (secs) => {
                    const m = Math.floor(secs / 60);
                    const s = Math.floor(secs % 60);
                    return `${m}m ${s}s`;
                };

                // ‚≠ê NEW: Check if this is an AI session pause/active
                const isAIState = (isPaused && (pausedSession?.isAISession || linkedAIPaused)) ||
                    (isActive && (activeSession?.isAISession || linkedAIActive));

                // Base Card HTML
                let cardHTML = `
            <div class="card-actions">
                <button class="card-action-btn edit-btn" title="Edit" data-action="edit-session">‚úèÔ∏è</button>
                <button class="card-action-btn cancel-btn" title="Cancel" data-action="cancel-session">‚ùå</button>
            </div>
            <p class="session-title">üéØ ${session.title}</p>
            <p class="session-subject">Subject: ${session.subject || 'General'} ${statusBadge}</p>
            <p class="session-datetime">Scheduled: ${formattedDate} | ${formattedTime}</p>
            <p class="session-duration">Duration: ${session.duration} minutes</p>
        `;

                // ‚≠ê ENHANCED BUTTON LOGIC: Resume vs Start
                if (isPaused || isActive) {
                    // RESUME BUTTON (shows for both regular and AI sessions)
                    const action = (linkedAIPaused || linkedAIActive) ? 'resume-linked-ai' : 'resume-session';
                    cardHTML += `
                <button class="gradient-button" data-action="${action}" 
                        style="margin-top: 15px; width: 100%; background: linear-gradient(135deg, #FFC107 0%, #FF9800 100%); 
                        box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4); text-transform: none;">
                    ‚ñ∂Ô∏è Resume ${isAIState ? 'AI Session' : 'Session'} ${resumeTimeStr}
                </button>`;
                } else if (session.type === 'Test') {
                    // TEST START BUTTON
                    cardHTML += `
                <button class="gradient-button" data-action="start-full-test" 
                        style="margin-top: 15px; width: 100%;">
                    üìù Start Full Test
                </button>`;
                } else {
                    // ‚≠ê AI SESSION START BUTTON (default for Session type)
                    cardHTML += `
                <button class="gradient-button" data-action="start-ai-session" 
                        style="margin-top: 15px; width: 100%;">
                    ü§ñ Start AI Session
                </button>`;
                }

                card.innerHTML = cardHTML;
                sessionsContainer.appendChild(card);
            });

            revealCards('#sessions-container');
        };

        // Enhanced Full Screen Test Logic with Quiz.html styling
        let fsQuestions = [];
        let fsSelected = {};
        let fsCurrent = 0;

        // Update startFullScreenTest error handler (around line 2150)
        async function startFullScreenTest(topic, subject) {
            aiSessionState.active = false;

            const modal = document.getElementById('full-screen-test-modal');
            const loading = document.getElementById('fs-loading');
            const quizSection = document.getElementById('fs-quiz-section');
            const results = document.getElementById('fs-results-container');

            document.body.classList.add('quiz-active');

            modal.classList.remove('hidden');
            loading.classList.remove('hidden');
            quizSection.classList.add('hidden');
            results.classList.add('hidden');

            fsQuestions = [];
            fsSelected = {};
            fsCurrent = 0;

            try {
                const questions = await generateAIQuiz(topic, subject, 10);
                fsQuestions = questions;

                loading.classList.add('hidden');
                quizSection.classList.remove('hidden');
                document.getElementById('fs-quiz-title').textContent = `Test: ${topic}`;

                renderFsQuestion();
                renderFsNav();

            } catch (e) {
                console.error('‚ùå Full Test Error:', e);

                // ‚≠ê NEW: Use error display function
                showQuizError(
                    loading,
                    e.message,
                    `startFullScreenTest('${topic.replace(/'/g, "\\'")}', '${subject.replace(/'/g, "\\'")}')`
                );
            }
        }

        // Update generateQuizForSession error handler (around line 2400)
        async function generateQuizForSession(topic, subject) {
            const quizModal = document.getElementById('quiz-modal');
            const quizLoading = document.getElementById('quiz-loading');
            const quizContent = document.getElementById('quiz-content');

            quizLoading.classList.remove('hidden');
            quizContent.classList.add('hidden');
            document.getElementById('quiz-nav-buttons').style.display = 'none';
            document.getElementById('quiz-questions-wrapper').style.display = 'block';
            document.getElementById('quiz-question-nav').style.display = 'flex';
            document.getElementById('quiz-results-container').style.display = 'none';

            openModal(quizModal);

            quizQuestions = [];
            quizSelectedAnswers = {};
            quizCurrentQuestion = 0;
            quizShowResults = false;

            try {
                const questions = await generateAIQuiz(topic, subject, 10);
                quizQuestions = questions;

                console.log('‚úÖ Quiz Modal Generated:', quizQuestions.length, 'questions');

                document.getElementById('quiz-topic-title').textContent = `Quiz: ${topic} - ${subject}`;
                quizLoading.classList.add('hidden');
                quizContent.classList.remove('hidden');

                renderQuizUI();

            } catch (err) {
                console.error('‚ùå Quiz Modal Error:', err);

                // ‚≠ê NEW: Use error display function
                showQuizError(
                    quizLoading,
                    err.message,
                    `generateQuizForSession('${topic.replace(/'/g, "\\'")}', '${subject.replace(/'/g, "\\'")}')`
                );
            }
        }

        // Update launchConceptQuiz error handler (around line 2700)
        async function launchConceptQuiz(conceptTitle, subject) {
            const modal = document.getElementById('full-screen-test-modal');
            const loading = document.getElementById('fs-loading');
            const quizSection = document.getElementById('fs-quiz-section');
            const results = document.getElementById('fs-results-container');

            document.body.classList.add('quiz-active');

            modal.classList.remove('hidden');
            loading.classList.remove('hidden');
            quizSection.classList.add('hidden');
            results.classList.add('hidden');

            fsQuestions = [];
            fsSelected = {};
            fsCurrent = 0;

            try {
                const questions = await generateAIQuiz(conceptTitle, subject, 5);
                fsQuestions = questions;

                loading.classList.add('hidden');
                quizSection.classList.remove('hidden');
                document.getElementById('fs-quiz-title').textContent = `Quiz: ${conceptTitle}`;

                renderFsQuestion();
                renderFsNav();

            } catch (e) {
                console.error('‚ùå Concept Quiz Error:', e);

                // ‚≠ê NEW: Use error display function
                showQuizError(
                    loading,
                    e.message,
                    `launchConceptQuiz('${conceptTitle.replace(/'/g, "\\'")}', '${subject.replace(/'/g, "\\'")}')`
                );
            }
        }

        function closeFullScreenTest() {
            const modal = document.getElementById('full-screen-test-modal');

            modal.classList.add('hidden');
            document.body.classList.remove('quiz-active');
        }

        function renderFsNav() {
            const nav = document.getElementById('fs-question-nav');
            nav.innerHTML = '';
            fsQuestions.forEach((_, idx) => {
                const dot = document.createElement('div');
                dot.className = 'nav-dot';
                if (idx === fsCurrent) dot.classList.add('active');
                if (fsSelected[idx]) dot.classList.add('answered');
                dot.onclick = () => goToFsQuestion(idx);
                nav.appendChild(dot);
            });
        }

        function goToFsQuestion(idx) {
            fsCurrent = idx;
            renderFsQuestion();
            renderFsNav();
        }

        function renderFsQuestion() {
            const wrapper = document.getElementById('fs-questions-wrapper');
            const q = fsQuestions[fsCurrent];

            let optionsHTML = '';
            Object.entries(q.options).forEach(([key, val]) => {
                const isSelected = fsSelected[fsCurrent] === key;
                const btnClass = isSelected ? 'fs-option-btn selected' : 'fs-option-btn';
                optionsHTML += `
            <button class="${btnClass}" onclick="selectFsAnswer('${key}')">
                <strong>${key}.</strong> ${val}
            </button>
        `;
            });

            wrapper.innerHTML = `
    <div class="fs-question-card active">
        <h3 class="gradient-text" style="font-size: 1.5em; margin-bottom: 20px;">
            Question ${fsCurrent + 1} of ${fsQuestions.length}
        </h3>
        <p style="font-size: 1.2em; margin-bottom: 30px; line-height: 1.6;">${q.question}</p>
        <div class="fs-options">
            ${optionsHTML}
        </div>
    </div>
`;

            // Update button states
            const prevBtn = document.getElementById('fs-prev-btn');
            const nextBtn = document.getElementById('fs-next-btn');
            const submitBtn = document.getElementById('fs-submit-btn');

            prevBtn.disabled = fsCurrent === 0;
            const isLast = fsCurrent === fsQuestions.length - 1;
            nextBtn.style.display = isLast ? 'none' : 'block';
            submitBtn.style.display = isLast ? 'block' : 'none';

            // Add event listeners
            prevBtn.onclick = fsPrevQuestion;
            nextBtn.onclick = fsNextQuestion;
            submitBtn.onclick = fsSubmitQuiz;

            renderFsNav();
        }

        function selectFsAnswer(ans) {
            fsSelected[fsCurrent] = ans;
            renderFsQuestion();
        }

        // In the quiz full screen section, update the button container styling
        // Find the quiz full screen rendering code and update it like this:

        // Update the renderFullScreenQuiz function
        function renderFullScreenQuiz() {
            const quiz = sessionQuizzes[currentSessionIndex];
            if (!quiz) return;

            const questionData = quiz.questions[currentQuestionIndex];

            fullScreenQuizContent.innerHTML = `
        <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
            <div style="margin-bottom: 20px;">
                <span style="color: #64748b; font-size: 14px;">Question ${currentQuestionIndex + 1} of ${quiz.questions.length}</span>
                <div style="width: 100%; height: 4px; background: #e2e8f0; border-radius: 2px; margin-top: 8px;">
                    <div style="width: ${((currentQuestionIndex + 1) / quiz.questions.length) * 100}%; height: 100%; background: #3b82f6; border-radius: 2px; transition: width 0.3s;"></div>
                </div>
            </div>

            <h3 style="color: #1e293b; margin-bottom: 24px; font-size: 20px;">${questionData.question}</h3>

            <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px;">
                ${questionData.options.map((option, index) => `
                    <label style="display: flex; align-items: center; padding: 16px; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                           onmouseover="this.style.borderColor='#3b82f6'; this.style.background='#eff6ff'"
                           onmouseout="this.style.borderColor='#e2e8f0'; this.style.background='white'">
                        <input type="radio" name="quiz-option" value="${index}" 
                               ${userAnswers[currentQuestionIndex] === index ? 'checked' : ''}
                               onchange="handleQuizAnswer(${index})"
                               style="margin-right: 12px; width: 20px; height: 20px; cursor: pointer;">
                        <span style="color: #334155; font-size: 16px;">${option}</span>
                    </label>
                `).join('')}
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 20px; border-top: 2px solid #e2e8f0; position: sticky; bottom: 0; background: white; z-index: 10;">
                <button onclick="previousQuestion()" 
                        ${currentQuestionIndex === 0 ? 'disabled' : ''}
                        style="padding: 12px 24px; border: 2px solid #3b82f6; background: white; color: #3b82f6; border-radius: 8px; font-weight: 600; cursor: pointer; opacity: ${currentQuestionIndex === 0 ? '0.5' : '1'};">
                    Previous
                </button>
                
                ${currentQuestionIndex === quiz.questions.length - 1 ?
                    `<button onclick="submitQuiz()" 
                             style="padding: 12px 32px; border: none; background: #10b981; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">
                        Submit Quiz
                     </button>` :
                    `<button onclick="nextQuestion()" 
                             style="padding: 12px 24px; border: none; background: #3b82f6; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">
                        Next
                     </button>`
                }
            </div>
        </div>
    `;
        }

        function reviewFsAnswers() {
            const results = document.getElementById('fs-results-container');

            let correctCount = 0;
            let reviewHTML = '<div class="review-container">';

            fsQuestions.forEach((q, idx) => {
                const userAnswer = fsSelected[idx];
                const isCorrect = userAnswer === q.correct;
                const cardClass = isCorrect ? 'correct' : 'incorrect';

                if (isCorrect) correctCount++;

                reviewHTML += `
            <div class="review-card ${cardClass}">
                <div class="review-question-header">
                    <div class="review-status-badge ${cardClass}">
                        ${isCorrect ? '‚úì' : '‚úï'}
                    </div>
                    <div class="review-question-text">
                        ${idx + 1}. ${q.question}
                    </div>
                </div>
                
                <div class="review-options">
        `;

                Object.entries(q.options).forEach(([letter, option]) => {
                    const isUserSelected = userAnswer === letter;
                    const isCorrectAnswer = letter === q.correct;

                    let optionClass = 'review-option';
                    let indicator = '';

                    if (isCorrectAnswer) {
                        optionClass += ' correct';
                        indicator = '‚úì Correct Answer';
                    } else if (isUserSelected && !isCorrect) {
                        optionClass += ' incorrect';
                        indicator = '‚úï Your Answer';
                    }

                    if (isUserSelected || isCorrectAnswer) {
                        reviewHTML += `
                    <div class="${optionClass}">
                        <span class="review-option-label">${letter}.</span>
                        <span>${option}</span>
                        <span class="option-indicator">${indicator}</span>
                    </div>
                `;
                    }
                });

                reviewHTML += `
                </div>
                <div class="review-explanation">
                    <div class="explanation-title">üìö Explanation</div>
                    <div class="explanation-text">${q.explanation}</div>
                </div>
            </div>
        `;
            });

            reviewHTML += '</div>';

            results.innerHTML = `
        <div class="results-container" style="flex-direction: column; width: 100%;">
            <div style="width: 100%; text-align: center; margin-bottom: 2rem;">
                <h2 class="gradient-text" style="font-size: 1.8rem; margin-bottom: 1rem;">Review Your Answers</h2>
                <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 1rem;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="font-size: 2rem; color: #10b981; font-weight: 700;">
                            ${correctCount}
                        </div>
                        <div style="color: #aaa; font-size: 0.9rem;">Correct</div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="font-size: 2rem; color: #ef4444; font-weight: 700;">
                            ${fsQuestions.length - correctCount}
                        </div>
                        <div style="color: #aaa; font-size: 0.9rem;">Incorrect</div>
                    </div>
                </div>
            </div>
            ${reviewHTML}
            <div class="review-footer">
                <button class="btn btn-primary" onclick="fsSubmitQuiz()" style="max-width: 200px;">
                    ‚Üê Back to Results
                </button>
                <button class="btn btn-primary" onclick="closeFullScreenTest()" style="max-width: 200px;">
                    Close Test
                </button>
            </div>
        </div>
    `;
        }
        // =================================================================
        // AI SESSION BUTTON HELPERS
        // =================================================================

        // Check if a subject has AI/mock data available
        const hasAIMockData = (subject) => {
            const aiSubjects = ['calculus', 'physics'];
            return aiSubjects.some(s => subject.toLowerCase().includes(s.toLowerCase()));
        };


        // =================================================================
        // CHATBOT & PDF INTEGRATION
        // =================================================================

        chatbotIcon.addEventListener("click", () => {
            pdfContainer.classList.remove("visible");
            chatbotContainer.classList.add("visible");
            chatbotIcon.classList.remove("visible");
            pdfIcon.classList.add("visible");
        });

        chatCloseBtn.addEventListener("click", () => {
            chatbotContainer.classList.remove("visible");
            if (liveSessionPage.classList.contains('open')) {
                chatbotIcon.classList.add("visible");
                pdfIcon.classList.add("visible");
            }
        });

        pdfIcon.addEventListener("click", () => {
            chatbotContainer.classList.remove("visible");
            pdfContainer.classList.add("visible");
            pdfIcon.classList.remove("visible");
            chatbotIcon.classList.add("visible");
        });

        pdfCloseBtn.addEventListener("click", () => {
            pdfContainer.classList.remove("visible");
            if (liveSessionPage.classList.contains('open')) {
                chatbotIcon.classList.add("visible");
                pdfIcon.classList.add("visible");
            }
        });

        sendBtn.addEventListener("click", sendChatMessage);
        chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") sendChatMessage();
        });

        function sendChatMessage() {
            const userMessage = chatInput.value.trim();
            if (userMessage) {
                appendChatMessage("user", userMessage);
                chatInput.value = "";
                getBotResponse(userMessage);
            }
        }

        function appendChatMessage(sender, message) {
            const messageElement = document.createElement("div");
            messageElement.classList.add("message", sender);
            messageElement.textContent = message;
            chatbotMessages.appendChild(messageElement);
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
        }
        // =================================================================
        // ENHANCED CHATBOT WITH MARKDOWN, TTS, AND STREAMING
        // =================================================================

        /* ---------- TTS (Text-to-Speech) Logic ---------- */
        const synth = window.speechSynthesis;
        let currentUtterance = null;
        let currentReadBtn = null;
        let currentHighlightSpan = null;

        function resetReadButton() {
            if (currentReadBtn) {
                currentReadBtn.innerHTML = '<i class="fa-solid fa-volume-up"></i>';
                currentReadBtn.classList.remove('active');
                currentReadBtn = null;
            }
        }

        function stopSpeaking() {
            if (synth.speaking || synth.paused) {
                synth.cancel();
            }
            document.querySelectorAll('.message.reading-active').forEach(el => {
                el.classList.remove('reading-active');
            });
            removeHighlight();
            resetReadButton();
            currentUtterance = null;
        }

        function removeHighlight() {
            if (currentHighlightSpan && currentHighlightSpan.parentNode) {
                const parent = currentHighlightSpan.parentNode;
                while (currentHighlightSpan.firstChild) {
                    parent.insertBefore(currentHighlightSpan.firstChild, currentHighlightSpan);
                }
                parent.removeChild(currentHighlightSpan);
                parent.normalize();
                currentHighlightSpan = null;
            }
        }

        function highlightWord(rootElement, startIndex, wordLength) {
            removeHighlight();
            if (!rootElement || wordLength === 0) return;

            let charCount = 0;
            let startNode = null, startOffset = 0;
            let endNode = null, endOffset = 0;
            let foundStart = false, foundEnd = false;

            function traverse(node) {
                if (foundEnd) return;
                if (node.nodeType === 3) {
                    const nodeLength = node.textContent.length;
                    const nextCharCount = charCount + nodeLength;
                    if (!foundStart && startIndex >= charCount && startIndex < nextCharCount) {
                        startNode = node;
                        startOffset = startIndex - charCount;
                        foundStart = true;
                    }
                    if (foundStart && !foundEnd && (startIndex + wordLength) <= nextCharCount) {
                        endNode = node;
                        endOffset = (startIndex + wordLength) - charCount;
                        foundEnd = true;
                    }
                    charCount = nextCharCount;
                } else if (node.nodeType === 1) {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        traverse(node.childNodes[i]);
                    }
                }
            }

            traverse(rootElement);

            if (startNode && endNode && startNode === endNode) {
                const range = document.createRange();
                range.setStart(startNode, startOffset);
                range.setEnd(endNode, endOffset);
                const span = document.createElement('span');
                span.className = 'highlight-word';
                try {
                    range.surroundContents(span);
                    currentHighlightSpan = span;
                } catch (e) {
                    console.log('Skipping highlight across complex boundaries');
                }
            }
        }

        function readMessage(button) {
            if (synth.paused && currentReadBtn === button) {
                synth.resume();
                button.innerHTML = '<i class="fa-solid fa-pause"></i>';
                button.classList.add('active');
                return;
            }
            if (synth.speaking && currentUtterance && currentReadBtn === button) {
                synth.pause();
                button.innerHTML = '<i class="fa-solid fa-play"></i>';
                return;
            }
            stopSpeaking();

            const messageElement = button.closest('.message');
            const contentArea = messageElement.querySelector('.message-text');
            const messageText = contentArea.textContent;

            const utterance = new SpeechSynthesisUtterance(messageText);
            utterance.pitch = 1;
            utterance.rate = 1.0;

            messageElement.classList.add('reading-active');

            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    const len = event.charLength || ((messageText.substring(event.charIndex).match(/^\S+/) || [''])[0].length);
                    highlightWord(contentArea, event.charIndex, len);
                }
            };

            utterance.onstart = () => {
                button.innerHTML = '<i class="fa-solid fa-pause"></i>';
                button.classList.add('active');
            };

            utterance.onend = () => {
                resetReadButton();
                messageElement.classList.remove('reading-active');
                removeHighlight();
            };

            utterance.onerror = () => {
                resetReadButton();
                messageElement.classList.remove('reading-active');
                removeHighlight();
            };

            currentUtterance = utterance;
            currentReadBtn = button;
            synth.speak(utterance);
        }

        function copyToClipboard(button) {
            const messageElement = button.closest('.message');
            const messageText = messageElement.querySelector('.message-text').textContent;

            if (navigator.clipboard) {
                navigator.clipboard.writeText(messageText).then(() => {
                    showToast('Copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    showToast('Failed to copy', 'fa-circle-xmark');
                });
            }
        }

        // Update your existing showToast function to handle trophy icon
        function showToast(message, icon = 'fa-circle-check') {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                document.body.appendChild(container);
            }

            const toast = document.createElement('div');
            toast.className = 'toast';

            // Add special class for test completion
            if (icon === 'fa-trophy') {
                toast.classList.add('test-complete');
            }

            toast.innerHTML = `<i class="fa-solid ${icon}"></i> <span>${message}</span>`;

            container.appendChild(toast);

            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        /**
 * Safe version with confirmation - Replace fsSubmitQuiz deletion section with this
 */
        function handleTestCompletion(testId) {
            const testIndex = sessions.findIndex(s => Number(s.id) === Number(testId));

            if (testIndex !== -1) {
                const completedTest = sessions[testIndex];

                // Auto-delete without confirmation
                sessions.splice(testIndex, 1);
                saveDataToLocalStorage();

                // Animate card removal on dashboard
                const card = document.querySelector(`.session-card[data-id="${testId}"]`);
                if (card) {
                    card.classList.add('test-completed');
                    setTimeout(() => card.remove(), 600);
                }

                console.log(`‚úÖ Test "${completedTest.title}" auto-deleted after completion`);
                return true;
            }

            return false;
        }
        // Add this function anywhere in your script section (around line 1400):

        function debugAISessionState() {
            console.group('üîç AI Session Debug Info');
            console.log('Active:', aiSessionState.active);
            console.log('Current Concept Index:', aiSessionState.currentConceptIndex);
            console.log('Total Concepts:', aiSessionState.concepts.length);
            console.log('Scores:', aiSessionState.scores);
            console.log('Progress:', aiSessionState.overallProgress);

            if (pausedSessionData) {
                console.log('Paused Data:', {
                    isAI: pausedSessionData.isAISession,
                    savedIndex: pausedSessionData.aiSessionData?.currentConceptIndex,
                    savedScores: pausedSessionData.aiSessionData?.scores
                });
            }
            console.groupEnd();
        }

        // Call this in browser console when debugging: debugAISessionState()
        /* ---------- Markdown Formatter ---------- */
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatMarkdownToHtml(rawText) {
            if (!rawText) return '';
            const text = escapeHtml(rawText);

            const codeBlocks = [];
            let placeholderIndex = 0;
            const codeFenceRe = /```([\s\S]*?)```/g;
            const withPlaceholders = text.replace(codeFenceRe, (m, inner) => {
                const token = `@@CODE_BLOCK_${placeholderIndex}@@`;
                codeBlocks.push(inner);
                placeholderIndex++;
                return token;
            });

            const lines = withPlaceholders.split(/\r?\n/);
            let out = '';
            let inList = false;
            let listType = null;
            let inTable = false;
            let tableRows = [];

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                if (/^\s*\|.*\|\s*$/.test(line)) {
                    inTable = true;
                    tableRows.push(line.trim());
                    continue;
                } else if (inTable) {
                    out += renderTableFromRows(tableRows);
                    tableRows = [];
                    inTable = false;
                }

                const hMatch = line.match(/^\s*(#{1,6})\s+(.*)$/);
                if (hMatch) {
                    if (inList) {
                        out += closeList(listType);
                        inList = false;
                        listType = null;
                    }
                    const level = hMatch[1].length;
                    out += `<h${level}>${inlineFormat(hMatch[2])}</h${level}>`;
                    continue;
                }

                const olMatch = line.match(/^\s*\d+\.\s+(.*)$/);
                const ulMatch = line.match(/^\s*[-*+]\s+(.*)$/);

                if (ulMatch || olMatch) {
                    const thisType = ulMatch ? 'ul' : 'ol';
                    const itemText = (ulMatch ? ulMatch[1] : olMatch[1]).trim();

                    if (!inList) {
                        out += `<${thisType}>`;
                        inList = true;
                        listType = thisType;
                    } else if (listType !== thisType) {
                        out += closeList(listType);
                        out += `<${thisType}>`;
                        listType = thisType;
                    }
                    out += `<li>${inlineFormat(itemText)}</li>`;
                    continue;
                } else {
                    if (inList) {
                        out += closeList(listType);
                        inList = false;
                        listType = null;
                    }
                }

                if (line.trim() === '') {
                    out += '<br/>';
                    continue;
                }

                out += `<p style="margin:0;padding:0;">${inlineFormat(line)}</p>`;
            }

            if (inList) out += closeList(listType);
            if (inTable && tableRows.length) out += renderTableFromRows(tableRows);

            let final = out;
            for (let j = 0; j < codeBlocks.length; j++) {
                const token = `@@CODE_BLOCK_${j}@@`;
                const raw = codeBlocks[j];
                final = final.split(token).join(`<pre class="code-block"><code>${raw.replace(/</g, '&lt;')}`);
            }

            final = final.replace(/(<br\/>\s*){2,}/g, '<br/>');
            return final;
        }

        function inlineFormat(s) {
            if (!s) return '';
            s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
            s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/(^|[^*])\*(?!\*)(.+?)\*(?!\*)/g, (m, p1, p2) => `${p1}<em>${p2}</em>`);
            s = s.replace(/:([a-z0-9_+-]+):/gi, (m, name) => {
                const map = { smile: 'üòä', thumbs_up: 'üëç', heart: '‚ù§Ô∏è', fire: 'üî•', star: '‚≠ê' };
                return map[name] || m;
            });
            s = s.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
            return s;
        }

        function closeList(type) {
            return `</${type}>`;
        }

        function renderTableFromRows(rows) {
            if (!rows.length) return '';
            const parsed = rows.map(r => r.replace(/^\||\|$/g, '').split('|').map(c => c.trim()));
            if (parsed.length < 2) {
                return parsed.map(r => r.join(' | ')).map(cell => `<p>${inlineFormat(cell)}</p>`).join('');
            }
            const header = parsed[0];
            let html = '<table class="markdown-table"><thead><tr>';
            header.forEach(h => html += `<th>${inlineFormat(h)}</th>`);
            html += '</tr></thead><tbody>';
            for (let i = 1; i < parsed.length; i++) {
                const row = parsed[i];
                if (row.every(c => /^-+$/.test(c))) continue;
                html += '<tr>';
                row.forEach(c => html += `<td>${inlineFormat(c)}</td>`);
                html += '</tr>';
            }
            html += '</tbody></table>';
            return html;
        }

        /* ---------- Update existing chatbot send function ---------- */
        // Replace the existing getBotResponse function with this streaming version:

        let isStreamingChat = false;

        async function getBotResponse(userMessage) {
            if (GEMINI_API_KEY === "YOUR_GEMINI_API_KEY_HERE" || !GEMINI_API_KEY) {
                appendChatMessage("bot", "Error: Gemini API Key is missing. Please set your key in the script.");
                return;
            }

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;
            sendBtn.disabled = true;
            chatInput.disabled = true;

            // Show typing indicator
            const typingDiv = document.createElement("div");
            typingDiv.classList.add("message", "bot");
            typingDiv.innerHTML = `
        <div class="typing-container">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
            <span>EduBot is thinking</span>
        </div>
    `;
            chatbotMessages.appendChild(typingDiv);
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight;

            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userMessage }] }],
                    }),
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error?.message || "Unknown API error");
                }
                if (!data.candidates || !data.candidates.length) {
                    if (data.promptFeedback) {
                        console.warn("Prompt blocked:", data.promptFeedback);
                        throw new Error("Prompt was blocked. Please try a different question.");
                    }
                    throw new Error("No response from Gemini API");
                }

                const botMessage = data.candidates[0].content.parts[0].text;

                // Remove typing indicator
                typingDiv.remove();

                // Stream the response
                appendBotMessageStream(botMessage);

            } catch (error) {
                console.error("Error:", error);
                typingDiv.remove();
                appendChatMessage("bot", `Sorry, I'm having trouble responding: ${error.message}`);
            } finally {
                sendBtn.disabled = false;
                chatInput.disabled = false;
            }
        }

        function appendChatMessage(sender, message) {
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const messageElement = document.createElement("div");
            messageElement.classList.add("message", sender);

            const contentArea = document.createElement("div");
            contentArea.className = "message-text";
            contentArea.innerHTML = formatMarkdownToHtml(message);
            messageElement.appendChild(contentArea);

            if (sender === "bot") {
                const actionsBar = document.createElement('div');
                actionsBar.className = 'actions-bar';
                actionsBar.innerHTML = `
            <span class="timestamp-text">${timestamp}</span>
            <button class="action-btn" onclick="copyToClipboard(this)" title="Copy message">
                <i class="fa-solid fa-copy"></i>
            </button>
            <button class="action-btn" onclick="readMessage(this)" title="Read aloud">
                <i class="fa-solid fa-volume-up"></i>
            </button>
        `;
                messageElement.appendChild(actionsBar);
            }

            chatbotMessages.appendChild(messageElement);
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
        }

        function appendBotMessageStream(text) {
            stopSpeaking();

            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const div = document.createElement('div');
            div.className = 'message bot';

            const textContainer = document.createElement('div');
            textContainer.className = 'message-text';
            div.appendChild(textContainer);

            const actionsBar = document.createElement('div');
            actionsBar.className = 'actions-bar';
            div.appendChild(actionsBar);

            chatbotMessages.appendChild(div);
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight;

            const tokens = text.match(/[^.!?]+[.!?]|\s+|\S+/g) || [text];
            let idx = 0;
            let currentText = '';
            isStreamingChat = true;

            const pump = async () => {
                if (!isStreamingChat) {
                    finalizeStream();
                    return;
                }

                if (idx >= tokens.length) {
                    finalizeStream();
                    return;
                }

                const chunk = tokens[idx];
                currentText += chunk;
                idx++;

                const formatted = formatMarkdownToHtml(currentText);
                textContainer.innerHTML = formatted + `<span class="cursor"></span>`;

                chatbotMessages.scrollTop = chatbotMessages.scrollHeight;

                const delay = 35;
                await new Promise(r => setTimeout(r, delay));
                pump();
            };

            const finalizeStream = () => {
                textContainer.innerHTML = formatMarkdownToHtml(currentText);

                actionsBar.innerHTML = `
            <span class="timestamp-text">${timestamp}</span>
            <button class="action-btn" onclick="copyToClipboard(this)" title="Copy message">
                <i class="fa-solid fa-copy"></i>
            </button>
            <button class="action-btn" onclick="readMessage(this)" title="Read aloud">
                <i class="fa-solid fa-volume-up"></i>
            </button>
        `;

                isStreamingChat = false;
                chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
            };

            pump();
        }

        // Add Font Awesome if not already included
        if (!document.querySelector('link[href*="font-awesome"]')) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
            document.head.appendChild(link);
        }

        // =================================================================
        // LIVE SESSION CONTROL & YOUTUBE API HANDLING
        // =================================================================
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        // UPDATE SESSION TIMER - Replace existing function
        function updateSessionTimer() {
            if (sessionPaused) {
                // When paused, show PAUSED indicator
                liveSessionTimer.textContent = `‚è∏ ${formatTime(sessionTotalDuration - sessionElapsedSeconds)}`;
                return;
            }

            // Calculate elapsed time
            sessionElapsedSeconds = Math.floor((Date.now() - sessionStartTime) / 1000);
            const remainingSeconds = Math.max(0, sessionTotalDuration - sessionElapsedSeconds);

            // Update timer display
            liveSessionTimer.textContent = formatTime(remainingSeconds);

            // Visual warning when time is running low (last 5 minutes)
            if (remainingSeconds <= 300 && remainingSeconds > 0) {
                liveSessionTimer.style.color = "var(--warning-color)";
                liveSessionTimer.style.animation = "pulse 1s infinite";
            } else {
                liveSessionTimer.style.color = "";
                liveSessionTimer.style.animation = "";
            }

            // Auto-end session when time runs out
            if (remainingSeconds <= 0) {
                clearInterval(sessionTimerInterval);
                liveSessionTimer.style.color = "var(--secondary-color)";
                showSessionCompletionDialog();
            }
        }
        function showSessionCompletionDialog() {
            const userChoice = confirm("Session time completed! Would you like to add more time?\n\nClick 'OK' to add more time\nClick 'Cancel' to end the session");

            if (userChoice) {
                // Prompt user to enter additional minutes
                const additionalMinutes = prompt("How many additional minutes would you like to add?", "15");

                if (additionalMinutes !== null && additionalMinutes.trim() !== "") {
                    const minutes = parseInt(additionalMinutes);

                    if (!isNaN(minutes) && minutes > 0) {
                        // Add the specified minutes
                        sessionTotalDuration += minutes * 60;
                        sessionStartTime = Date.now() - (sessionElapsedSeconds * 1000);
                        sessionTimerInterval = setInterval(updateSessionTimer, 1000);
                        updateSessionTimer();

                        alert(`${minutes} minutes added to your session!`);
                    } else {
                        alert("Invalid input. Session will end.");
                        endSessionBtn.click();
                    }
                } else {
                    // User cancelled the prompt
                    endSessionBtn.click();
                }
            } else {
                // End the session
                endSessionBtn.click();
            }
        }
        const renderVideoResults = (videoItems) => {
            videosSection.innerHTML = '';
            if (!videoItems || videoItems.length === 0) {
                videosSection.innerHTML = '<h3 style="grid-column: 1 / -1; color: var(--subtext-dark);">No videos found for this search query.</h3>';
                return;
            }
            videoItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'youvideo';
                card.setAttribute('data-videoid', item.id);
                card.setAttribute('data-title', item.snippet.title);
                card.innerHTML = `
                <div class="thumbnail-container">
                    <img src="${item.snippet.thumbnails.high.url}" alt="${item.snippet.title}" />
                    <span class="video-duration">${parseISODuration(item.contentDetails.duration)}</span>
                </div>
                <h3>${item.snippet.title}</h3>
                <p>Channel: ${item.snippet.channelTitle}</p>
            `;
                card.addEventListener('click', () => playVideoInModal(item.id, item.snippet.title));
                videosSection.appendChild(card);
            });
        }

        async function fetchVideoDetails(videoIds) {
            if (YOUTUBE_API_KEY === "YOUR_YOUTUBE_API_KEY_HERE" || !YOUTUBE_API_KEY) {
                videosSection.innerHTML = '<h3 style="grid-column: 1 / -1; color: var(--warning-color);">Error: YouTube API Key is not set. Video search is disabled.</h3>';
                liveLoader.style.display = 'none';
                return;
            }
            const url = `https://www.googleapis.com/youtube/v3/videos?key=${YOUTUBE_API_KEY}&part=snippet,contentDetails&id=${videoIds}`;
            try {
                const res = await fetch(url);
                const data = await res.json();

                if (data.error) throw new Error(data.error.message);

                liveLoader.style.display = 'none';

                // Log to check if we're getting duration data
                console.log("Video details received:", data.items);

                renderVideoResults(data.items);
            } catch (err) {
                liveLoader.style.display = 'none';
                videosSection.innerHTML = `<h3 style="grid-column: 1 / -1; color: var(--secondary-color);">Failed to load video details: ${err.message}</h3>`;
                consoleerror("YouTube Video Details Fetch Error:", err);
            }
        }

        // =================================================================
        // AI SESSION HELPER FUNCTIONS (CONTINUED)
        // =================================================================

        function renderAISessionLayout() {
            const liveSessionContent = document.querySelector('.live-session-content-area');
            if (!liveSessionContent) {
                console.error('Live session content area not found');
                return;
            }

            // Inject the AI session layout (replacing YouTube search interface)
            liveSessionContent.innerHTML = `
                <div class="ai-session-container">
                    <div class="session-main-content">
                        <!-- Video Section -->
                        <div class="ai-video-container" id="ai-video-container">
                            <h3 class="gradient-text">Current Topic: Loading...</h3>
                            <div class="ai-video-wrapper">
                                <div id="ai-youtube-player-placeholder" style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5);">
                                    <div class="theme-loader"></div>
                                </div>
                            </div>
                            <div id="ai-video-controls" style="margin-top: 15px; min-height: 50px;"></div>
                        </div>

                        <!-- Quiz Section -->
                        <div id="ai-quiz-container" class="ai-quiz-container" style="display: none;">
                            <h3 class="gradient-text">üß† Concept Check</h3>
                            <div id="ai-quiz-content"></div>
                        </div>
                    </div>

                    <div class="session-sidebar">
                        <h3 style="margin-bottom: 20px;">Session Plan</h3>
                        <div id="concepts-list" class="concepts-list">
                            <!-- Concepts populated here -->
                        </div>

                        <!-- Progress Circle in Sidebar -->
                        <div class="progress-circle-container">
                            <div class="circular-progress">
                                <svg viewBox="0 0 100 100">
                                    <circle cx="50" cy="50" r="45" class="bg"></circle>
                                    <circle cx="50" cy="50" r="45" class="progress" id="ai-progress-circle"></circle>
                                    <defs>
                                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#00c6ff" />
                                            <stop offset="100%" style="stop-color:#0072ff" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="progress-text">
                                    <span id="ai-progress-percentage">0%</span>
                                    <span class="progress-label">Complete</span>
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px; text-align: center;">
                            <button onclick="endSessionBtn.click()" class="secondary-button" style="font-size: 0.9em; padding: 8px 15px;">
                                End Session
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        async function searchAndPlayVideo(query, conceptTitle) {
            if (YOUTUBE_API_KEY === "YOUR_YOUTUBE_API_KEY_HERE" || !YOUTUBE_API_KEY) {
                const controls = document.getElementById('ai-video-controls');
                if (controls) controls.innerHTML = '<p style="color: var(--warning-color); text-align: center;">YouTube API Key not configured</p>';
                return;
            }

            const videoContainer = document.getElementById('ai-video-container');
            const titleElement = videoContainer.querySelector('h3');
            if (titleElement) titleElement.textContent = `Current Topic: ${conceptTitle}`;

            const searchUrl = `https://www.googleapis.com/youtube/v3/search?key=${YOUTUBE_API_KEY}&q=${encodeURIComponent(query)}&part=snippet&type=video&videoDuration=medium&maxResults=1`;

            try {
                const res = await fetch(searchUrl);
                const data = await res.json();

                if (data.error) throw new Error(data.error.message);

                if (data.items && data.items.length > 0) {
                    const videoId = data.items[0].id.videoId;
                    playAIVideo(videoId);
                } else {
                    const controls = document.getElementById('ai-video-controls');
                    if (controls) controls.innerHTML = '<p style="color: var(--subtext-dark); text-align: center;">No video found for this topic</p>';
                }
            } catch (err) {
                console.error("AI Video Search Error:", err);
                const controls = document.getElementById('ai-video-controls');
                if (controls) controls.innerHTML = `<p style="color: var(--secondary-color); text-align: center;">Error: ${err.message}</p>`;
            }
        }

        // Replace the existing playAIVideo function with this enhanced version
        let aiPlayer = null;
        let videoCompleted = false;

        function playAIVideo(videoId) {
            videoCompleted = false;
            const wrapper = document.querySelector('.ai-video-wrapper');
            wrapper.innerHTML = '<div id="ai-youtube-player"></div>';

            // Initialize YouTube Player with IFrame API
            if (window.YT && window.YT.Player) {
                aiPlayer = new YT.Player('ai-youtube-player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'enablejsapi': 1,
                        'rel': 0,
                        'modestbranding': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });
            } else {
                console.error("YouTube API not loaded");
                wrapper.innerHTML = `<iframe src="https://www.youtube.com/embed/${videoId}?enablejsapi=1" style="width:100%;height:100%;border:none;" allowfullscreen></iframe>`;
            }

            // Update controls
            const controls = document.getElementById('ai-video-controls');
            if (controls) {
                controls.innerHTML = `
            <div style="display: flex; gap: 10px; align-items: center; justify-content: center; width: 100%;">
<button onclick="skipVideoAndGoToQuiz()" 
         style="padding: 10px 20px; background: #f59e0b; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
    Skip Video and Go to Quiz
</button>
                <div id="video-status-msg" style="font-size: 0.9em; opacity: 0.8; white-space: nowrap;">
                    <i class="fa-solid fa-play" style="margin-right: 5px;"></i>Watching...
                </div>
            </div>
        `;
            }
        }

        function onPlayerReady(event) {
            console.log("YouTube player ready");
        }

        function onPlayerStateChange(event) {
            const statusMsg = document.getElementById('video-status-msg');

            if (event.data === YT.PlayerState.PLAYING) {
                if (statusMsg) {
                    statusMsg.innerHTML = '<i class="fa-solid fa-play" style="margin-right: 5px;"></i>Playing...';
                    statusMsg.style.color = "var(--info-color)";
                }
            } else if (event.data === YT.PlayerState.PAUSED) {
                if (statusMsg) {
                    statusMsg.innerHTML = '<i class="fa-solid fa-pause" style="margin-right: 5px;"></i>Paused';
                    statusMsg.style.color = "var(--warning-color)";
                }
            } else if (event.data === YT.PlayerState.ENDED) {
                videoCompleted = true;
                if (statusMsg) {
                    statusMsg.innerHTML = '<i class="fa-solid fa-check-circle" style="margin-right: 5px;"></i>Video Completed!';
                    statusMsg.style.color = "var(--info-color)";
                }

                // Show completion notification
                showToast('Video completed! Generating quiz...', 'fa-circle-check');

                // Get current concept details
                const concept = aiSessionState.concepts[aiSessionState.currentConceptIndex];

                // Auto-trigger full-screen quiz after 2 seconds
                setTimeout(() => {
                    launchConceptQuiz(concept.title, aiSessionState.subject);
                }, 2000);
            }
        }

        // Helper function to check if video was watched sufficiently
        function checkVideoProgress() {
            if (aiPlayer && aiPlayer.getDuration && aiPlayer.getCurrentTime) {
                const duration = aiPlayer.getDuration();
                const currentTime = aiPlayer.getCurrentTime();
                const watchPercentage = (currentTime / duration) * 100;

                // Consider video "watched" if 80% completed or fully ended
                return watchPercentage >= 80 || videoCompleted;
            }
            return videoCompleted;
        }
        async function markVideoAsWatched() {

            const concept = aiSessionState.concepts[aiSessionState.currentConceptIndex];

            // If quiz not yet generated, generate it now
            if (!concept.quiz) {
                const quizContainer = document.getElementById('ai-quiz-container');
                quizContainer.style.display = 'block';
                document.getElementById('ai-quiz-content').innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div class="theme-loader" style="margin: 0 auto;"></div>
                        <p class="gradient-text" style="margin-top: 15px;">ü§ñ AI is crafting a quiz for you...</p>
                    </div>
                `;

                try {
                    const quiz = await generateQuizQuestion(concept.title, aiSessionState.subject);
                    concept.quiz = quiz;
                } catch (e) {
                    console.error("Quiz generation failed", e);
                    concept.quiz = {
                        question: "What was the main topic?",
                        options: ["Topic A", "Topic B", "Topic C", "Topic D"],
                        correctIndex: 0,
                        explanation: "Fallback quiz due to error."
                    };
                }
            }

            showQuiz();
        }

        // Add this function to create and show quiz popup
        function showQuizPopup() {
            // Create popup overlay
            const popup = document.createElement('div');
            popup.id = 'quiz-popup';
            popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
    `;

            // Create popup content
            const popupContent = document.createElement('div');
            popupContent.style.cssText = `
        background: white;
        border-radius: 16px;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        position: relative;
    `;

            // Add close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '‚úï';
            closeButton.style.cssText = `
        position: absolute;
        top: 16px;
        right: 16px;
        background: #ef4444;
        color: white;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
            closeButton.onclick = closeQuizPopup;

            // Add quiz content container
            const quizContainer = document.createElement('div');
            quizContainer.id = 'popup-quiz-content';
            quizContainer.style.cssText = `
        padding: 60px 40px 40px 40px;
    `;

            popupContent.appendChild(closeButton);
            popupContent.appendChild(quizContainer);
            popup.appendChild(popupContent);
            document.body.appendChild(popup);

            // Render quiz in popup
            renderQuizInPopup();
        }

        function closeQuizPopup() {
            const popup = document.getElementById('quiz-popup');
            if (popup) {
                popup.remove();
            }
        }

        function renderQuizInPopup() {
            const quizContainer = document.getElementById('popup-quiz-content');
            if (!quizContainer) return;

            const quiz = sessionQuizzes[currentSessionIndex];
            if (!quiz) return;

            const questionData = quiz.questions[currentQuestionIndex];

            quizContainer.innerHTML = `
        <div style="margin-bottom: 24px;">
            <h2 style="color: #1e293b; margin-bottom: 8px; font-size: 24px;">Session ${currentSessionIndex + 1} Quiz</h2>
            <span style="color: #64748b; font-size: 14px;">Question ${currentQuestionIndex + 1} of ${quiz.questions.length}</span>
            <div style="width: 100%; height: 4px; background: #e2e8f0; border-radius: 2px; margin-top: 8px;">
                <div style="width: ${((currentQuestionIndex + 1) / quiz.questions.length) * 100}%; height: 100%; background: #3b82f6; border-radius: 2px; transition: width 0.3s;"></div>
            </div>
        </div>

        <h3 style="color: #1e293b; margin-bottom: 24px; font-size: 20px;">${questionData.question}</h3>

        <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px;">
            ${questionData.options.map((option, index) => `
                <label style="display: flex; align-items: center; padding: 16px; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                       onmouseover="this.style.borderColor='#3b82f6'; this.style.background='#eff6ff'"
                       onmouseout="this.style.borderColor='#e2e8f0'; this.style.background='white'">
                    <input type="radio" name="popup-quiz-option" value="${index}" 
                           ${userAnswers[currentQuestionIndex] === index ? 'checked' : ''}
                           onchange="handlePopupQuizAnswer(${index})"
                           style="margin-right: 12px; width: 20px; height: 20px; cursor: pointer;">
                    <span style="color: #334155; font-size: 16px;">${option}</span>
                </label>
            `).join('')}
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 20px; border-top: 2px solid #e2e8f0;">
            <button onclick="previousQuestionPopup()" 
                    ${currentQuestionIndex === 0 ? 'disabled' : ''}
                    style="padding: 12px 24px; border: 2px solid #3b82f6; background: white; color: #3b82f6; border-radius: 8px; font-weight: 600; cursor: pointer; opacity: ${currentQuestionIndex === 0 ? '0.5' : '1'};">
                Previous
            </button>
            
            ${currentQuestionIndex === quiz.questions.length - 1 ?
                    `<button onclick="submitPopupQuiz()" 
                         style="padding: 12px 32px; border: none; background: #10b981; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    Submit Quiz
                 </button>` :
                    `<button onclick="nextQuestionPopup()" 
                         style="padding: 12px 24px; border: none; background: #3b82f6; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    Next
                 </button>`
                }
        </div>
    `;
        }

        function handlePopupQuizAnswer(optionIndex) {
            userAnswers[currentQuestionIndex] = optionIndex;
        }

        function nextQuestionPopup() {
            const quiz = sessionQuizzes[currentSessionIndex];
            if (!quiz) return;

            if (currentQuestionIndex < quiz.questions.length - 1) {
                currentQuestionIndex++;
                renderQuizInPopup();
            }
        }

        function previousQuestionPopup() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderQuizInPopup();
            }
        }

        function submitPopupQuiz() {
            const quiz = sessionQuizzes[currentSessionIndex];
            if (!quiz) return;

            let score = 0;
            userAnswers.forEach((answer, index) => {
                if (answer === quiz.questions[index].correctAnswer) {
                    score++;
                }
            });

            const percentage = (score / quiz.questions.length) * 100;

            alert(`Quiz Complete!\n\nYou scored ${score} out of ${quiz.questions.length} (${percentage.toFixed(1)}%)`);

            closeQuizPopup();

            // Reset for next quiz
            currentQuestionIndex = 0;
            userAnswers = [];
        }
        // Update the "Skip Video and Go to Quiz" button click handler
        // Find where you handle the skip video button and replace with:
        /**
         * Skip video and launch full-screen quiz for current concept
         */
        async function skipVideoAndGoToQuiz() {
            const concept = aiSessionState.concepts[aiSessionState.currentConceptIndex];

            console.log('üéØ Skipping video, launching quiz for:', concept.title);

            // Mark video as watched
            aiSessionState.videoWatched = true;

            // Update video controls to show quiz is loading
            const controls = document.getElementById('ai-video-controls');
            if (controls) {
                controls.innerHTML = `
            <div style="display: flex; gap: 10px; align-items: center; justify-content: center; width: 100%;">
                <div class="theme-loader" style="width: 30px; height: 30px;"></div>
                <span style="color: var(--info-color);">Generating Quiz...</span>
            </div>
        `;
            }

            // Launch full-screen quiz modal
            await launchConceptQuiz(concept.title, aiSessionState.subject);
        }
        // Find renderConceptsSidebar (around line 2100) and replace with:

        function renderConceptsSidebar() {
            const conceptsList = document.getElementById('concepts-list');
            if (!conceptsList) return;

            // Calculate the highest unlocked index
            const successfulConcepts = Object.values(aiSessionState.scores).filter(s => s >= 60).length;
            const highestUnlockedIndex = successfulConcepts;

            // ‚≠ê FIX: Get current index from state
            const currentIndex = aiSessionState.currentConceptIndex;

            conceptsList.innerHTML = aiSessionState.concepts.map((concept, idx) => {
                let className = 'concept-item';
                let isLocked = false;
                let icon = '';

                if (idx > highestUnlockedIndex) {
                    className += ' locked';
                    isLocked = true;
                    icon = '<i class="fa-solid fa-lock" style="margin-left: auto; opacity: 0.5; font-size: 0.9em;"></i>';
                } else {
                    if (aiSessionState.scores[idx] !== undefined) {
                        className += ' completed';
                    }
                    // ‚≠ê FIX: Highlight the CURRENT concept, not just index 0
                    if (idx === currentIndex) {
                        className += ' active';
                    }
                }

                const onClick = isLocked ? '' : `onclick="loadConcept(${idx})"`;

                return `<div class="${className}" ${onClick}>
                    <span style="flex-grow: 1;">${concept.title}</span>
                    ${icon}
                </div>`;
            }).join('');

            console.log(`‚úÖ Sidebar updated - Current: ${currentIndex + 1}/${aiSessionState.concepts.length}`);
        }
        /**
         * Launch full-screen quiz for a specific concept (used in AI sessions)
         */
        async function launchConceptQuiz(conceptTitle, subject) {
            // ‚≠ê FIX: Ensure AI session state is TRUE for concept quizzes
            // (It should already be true, but let's be explicit)
            // aiSessionState.active is already set in initAISession, so no need to change it here

            const modal = document.getElementById('full-screen-test-modal');
            const loading = document.getElementById('fs-loading');
            const quizSection = document.getElementById('fs-quiz-section');
            const results = document.getElementById('fs-results-container');

            document.body.classList.add('quiz-active');

            modal.classList.remove('hidden');
            loading.classList.remove('hidden');
            quizSection.classList.add('hidden');
            results.classList.add('hidden');

            fsQuestions = [];
            fsSelected = {};
            fsCurrent = 0;

            try {
                // Generate 5 questions for concept quiz
                const questions = await generateAIQuiz(conceptTitle, subject, 5);
                fsQuestions = questions;

                loading.classList.add('hidden');
                quizSection.classList.remove('hidden');
                document.getElementById('fs-quiz-title').textContent = `Quiz: ${conceptTitle}`;

                renderFsQuestion();
                renderFsNav();

            } catch (e) {
                console.error('‚ùå Concept Quiz Error:', e);
                loading.innerHTML = `
            <div class="error-box" style="text-align: center; padding: 2rem; color: var(--secondary-color);">
                <i class="fa-solid fa-exclamation-triangle" style="font-size: 3em; margin-bottom: 20px;"></i>
                <h3>Failed to generate quiz</h3>
                <p>${e.message}</p>
            </div>
            <button class="gradient-button" onclick="closeFullScreenTest()" style="margin-top: 1rem;">
                Close
            </button>
        `;
            }
        }

        function updateProgress() {
            // Count only passed concepts (score >= 60)
            const completed = Object.values(aiSessionState.scores).filter(s => s >= 60).length;
            const total = aiSessionState.concepts.length;
            const percentage = Math.round((completed / total) * 100);

            aiSessionState.overallProgress = percentage;

            // Update progress circle
            const circle = document.getElementById('ai-progress-circle');
            const text = document.getElementById('ai-progress-percentage');

            if (circle && text) {
                const circumference = 314; // 2 * œÄ * 50
                const offset = circumference - (percentage / 100) * circumference;
                circle.style.strokeDashoffset = offset;
                text.textContent = `${percentage}%`;

                // Update linear progress fill
                const barFill = document.getElementById('ai-progress-bar-fill');
                const linearText = document.getElementById('ai-progress-percentage-linear');
                if (barFill) barFill.style.width = `${percentage}%`;
                if (linearText) linearText.textContent = `${percentage}%`;
            }

            // Update concepts sidebar
            renderConceptsSidebar();
        }

        function showAISessionCompletion() {
            const liveSessionContent = document.querySelector('.live-session-content-area');
            if (!liveSessionContent) return;

            const correctAnswers = Object.values(aiSessionState.scores).filter(s => s === 100).length;
            const totalQuestions = aiSessionState.concepts.length;
            const percentage = Math.round((correctAnswers / totalQuestions) * 100);

            let message, emoji;
            if (percentage === 100) {
                emoji = 'üéâ';
                message = 'Perfect Score! You\'ve mastered this topic!';
            } else if (percentage >= 70) {
                emoji = '‚≠ê';
                message = 'Excellent work! You have a strong understanding!';
            } else if (percentage >= 50) {
                emoji = 'üëç';
                message = 'Good job! Keep practicing to improve further!';
            } else {
                emoji = 'üìö';
                message = 'Keep learning! Review the concepts and try again.';
            }

            liveSessionContent.innerHTML = `
                <div style="text-align: center; padding: 60px 20px;">
                    <div style="font-size: 6em; margin-bottom: 20px;">${emoji}</div>
                    <h1 class="gradient-text" style="font-size: 2.5em; margin-bottom: 15px;">Session Complete!</h1>
                    <p style="font-size: 1.3em; color: var(--subtext-dark); margin-bottom: 30px;">${message}</p>
                    
                    <div style="display: inline-block; background: var(--card-dark); padding: 30px 50px; border-radius: 20px; margin-bottom: 40px;">
                        <div class="quiz-score-circle" style="width: 180px; height: 180px; margin: 0 auto;">
                            <div class="quiz-score-number">${correctAnswers}/${totalQuestions}</div>
                            <div class="quiz-score-label">${percentage}% Correct</div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="restartAISession()" class="gradient-button">
                            ‚Ü∫ Restart Session
                        </button>
                        <button onclick="endSessionBtn.click()" class="secondary-button">
                            ‚Üê Back to Dashboard
                        </button>
                    </div>

                    <div style="margin-top: 40px; padding: 20px; background: rgba(0, 114, 255, 0.1); border-radius: 12px; border: 1px solid var(--primary-color);">
                        <h3 style="margin-top: 0;">üìä Summary</h3>
                        <p>Topic: <strong>${aiSessionState.topic}</strong></p>
                        <p>Concepts Covered: <strong>${totalQuestions}</strong></p>
                        <p>Correct Answers: <strong>${correctAnswers}</strong></p>
                    </div>
                </div>
            `;

            aiSessionState.active = false;
        }

        async function performYouTubeSearch(query, pageToken = null) {
            if (YOUTUBE_API_KEY === "YOUR_YOUTUBE_API_KEY_HERE" || !YOUTUBE_API_KEY) {
                videosSection.innerHTML = '<h3 style="grid-column: 1 / -1; color: var(--warning-color);">Error: YouTube API Key is not set. Video search is disabled.</h3>';
                liveLoader.style.display = 'none';
                return;
            }

            if (!query) return;
            videosSection.innerHTML = '';
            liveLoader.style.display = 'flex';

            let searchUrl = `https://www.googleapis.com/youtube/v3/search?key=${YOUTUBE_API_KEY}&q=${encodeURIComponent(query)}&part=snippet&type=video&videoDuration=medium&maxResults=12`;
            if (pageToken) {
                searchUrl += `&pageToken=${pageToken}`;
            }

            try {
                const res = await fetch(searchUrl);
                const data = await res.json();

                if (data.error) throw new Error(data.error.message);

                currentNextPageToken = data.nextPageToken;
                liveSearchBtn.disabled = !currentNextPageToken;

                if (data.items && data.items.length > 0) {
                    const videoIds = data.items.map(item => item.id.videoId).join(',');
                    await fetchVideoDetails(videoIds);
                } else {
                    liveLoader.style.display = 'none';
                    videosSection.innerHTML = '<h3 style="grid-column: 1 / -1; color: var(--subtext-dark);">No more videos found.</h3>';
                }

            } catch (err) {
                liveLoader.style.display = 'none';
                videosSection.innerHTML = `<h3 style="grid-column: 1 / -1; color: var(--secondary-color);">Failed to load videos: ${err.message}</h3>`;
                console.error("YouTube Search Fetch Error:", err);
            }
        }

        function restartAISession() {
            initAISession(aiSessionState.topic, aiSessionState.subject);
        }

        // ============================================
        // 3. UPDATED OPEN LIVE SESSION FUNCTION
        // Replace your existing openLiveSession() function
        // ============================================
        const openLiveSession = (session, forceResume = false) => {
            currentSessionId = Number(session.id);

            // UI Setup
            document.getElementById('live-session-title').textContent = session.title;
            liveSessionPage.classList.remove('hidden', 'hiding');
            void liveSessionPage.offsetWidth;
            liveSessionPage.classList.add('open');
            mainContent.classList.add('hiding');

            // Check localStorage for paused data
            let storedPausedData = null;
            try {
                const stored = localStorage.getItem('epicScholarPausedSession');
                if (stored) storedPausedData = JSON.parse(stored);
            } catch (e) { }

            // DETERMINE IF RESUMING
            // We resume if forceResume is true AND we have matching data
            const isResuming = forceResume &&
                storedPausedData &&
                Number(storedPausedData.id) === currentSessionId;

            if (isResuming) {
                // --- RESUME LOGIC ---
                console.log("‚ôªÔ∏è Resuming session...");
                pausedSessionData = storedPausedData; // Update global state

                sessionTotalDuration = pausedSessionData.totalDuration;
                sessionElapsedSeconds = pausedSessionData.elapsedSeconds;

                // CRITICAL: Back-calculate start time so timer continues correctly
                // If 10 mins elapsed, pretend we started 10 mins ago
                sessionStartTime = Date.now() - (sessionElapsedSeconds * 1000);

                // ‚≠ê FIX: Preserve the ACTUAL start time for display (Started at 10:45 AM)
                sessionActualStartTime = pausedSessionData.actualStartTime || pausedSessionData.startedAt || sessionStartTime;

                // Restore Chat & Search
                if (pausedSessionData.chatHistory) chatbotMessages.innerHTML = pausedSessionData.chatHistory;
                if (pausedSessionData.videoSearchQuery) {
                    liveSearchInput.value = pausedSessionData.videoSearchQuery;
                    performYouTubeSearch(pausedSessionData.videoSearchQuery);
                }

                pauseSessionBtn.textContent = "Pause Session";
                showToast("Session Resumed!");
            } else {
                // --- NEW START LOGIC ---
                console.log("üÜï Starting new session...");
                sessionTotalDuration = session.duration * 60;
                sessionElapsedSeconds = 0;
                sessionStartTime = Date.now();
                sessionActualStartTime = sessionStartTime; // NEW: Mark first start time

                // Reset Chat
                chatbotMessages.innerHTML = '';
                appendChatMessage("bot", "Welcome! Edubot is ready.");

                // Default Search
                liveSearchInput.value = `${session.title} ${session.subject} tutorial`;
                performYouTubeSearch(liveSearchInput.value);
            }

            // Start Timer
            sessionPaused = false;
            updateSessionTimer(); // Run once immediately
            if (sessionTimerInterval) clearInterval(sessionTimerInterval);
            sessionTimerInterval = setInterval(updateSessionTimer, 1000);

            // Save as Active Session (so if browser crashes, we know it was running)
            const activeData = {
                id: currentSessionId,
                sessionTitle: session.title,
                totalDuration: sessionTotalDuration,
                elapsedSeconds: sessionElapsedSeconds,
                startedAt: sessionStartTime, // Reference for timer
                actualStartTime: sessionActualStartTime, // For display
                originalSessionId: session.originalSessionId || null
            };
            localStorage.setItem('epicScholarActiveSession', JSON.stringify(activeData));
        };

        // CLOSE LIVE SESSION - Don't clear paused session data
        const closeLiveSession = () => {
            liveSessionPage.classList.remove('open');
            liveSessionPage.classList.add('hiding');
            mainContent.classList.remove('hiding');

            // Don't clear timer if session is paused (it's already cleared)
            if (!sessionPaused && sessionTimerInterval) {
                clearInterval(sessionTimerInterval);
                sessionTimerInterval = null;
            }

            // ‚≠ê FIX: Clear active session state when closing (not pausing)
            if (!sessionPaused) {
                localStorage.removeItem('epicScholarActiveSession');
                sessionElapsedSeconds = 0;
                sessionTotalDuration = 0;
                currentSessionId = null;
            }

            // Hide floating icons
            pdfIcon.classList.remove('visible');
            chatbotIcon.classList.remove('visible');
            chatbotContainer.classList.remove('visible');
            pdfContainer.classList.remove('visible');

            // Reset chat input
            chatInput.disabled = false;
            chatInput.value = "";

            // Clear video section
            videosSection.innerHTML = '';
            liveLoader.style.display = 'none';
            liveSearchBtn.onclick = null;
            currentNextPageToken = null;

            liveSessionPage.addEventListener('transitionend', () => {
                liveSessionPage.classList.add('hidden');
                liveSessionPage.classList.remove('hiding');
            }, { once: true });
        };


        // =================================================================
        // MASTER EVENT HANDLERS & INITIALIZATION
        // =================================================================

        const openSessionForm = (type, sessionId = null) => {
            if (sessionId) {
                const session = sessions.find(s => s.id === sessionId);
                if (!session) return;

                sessionFormTitle.textContent = `Edit ${session.type}`;
                sessionForm.dataset.type = session.type;
                sessionForm.dataset.editId = sessionId;

                document.getElementById('session-title').value = session.title;
                document.getElementById('session-subject').value = session.subject;

                const sessionDate = new Date(session.datetime);
                const localDate = new Date(sessionDate.getTime() - sessionDate.getTimezoneOffset() * 60000).toISOString().split('T')[0];
                const localTime = sessionDate.toTimeString().split(' ')[0].substring(0, 5);

                document.getElementById('session-date').value = localDate;
                document.getElementById('session-time').value = localTime;
                document.getElementById('session-duration').value = session.duration.toString();
            } else {
                sessionFormTitle.textContent = `Add New ${type}`;
                sessionForm.dataset.type = type;
                delete sessionForm.dataset.editId;

                const now = new Date();
                const localDate = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().split('T')[0];
                const localTime = now.toTimeString().split(' ')[0].substring(0, 5);
                document.getElementById('session-date').value = localDate;
                document.getElementById('session-time').value = localTime;
            }

            openModal(sessionFormModal);
        };

        sessionForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(sessionForm);
            const editId = sessionForm.dataset.editId;

            if (editId) {
                const sessionIndex = sessions.findIndex(s => s.id === parseInt(editId));
                if (sessionIndex !== -1) {
                    sessions[sessionIndex] = {
                        ...sessions[sessionIndex],
                        title: formData.get('title'),
                        subject: formData.get('subject'),
                        duration: parseInt(formData.get('duration')),
                        datetime: new Date(`${formData.get('date')}T${formData.get('time')}`).toISOString()
                    };
                }
            } else {
                const newSession = {
                    id: Date.now(),
                    title: formData.get('title'),
                    type: sessionForm.dataset.type,
                    subject: formData.get('subject'),
                    duration: parseInt(formData.get('duration')),
                    datetime: new Date(`${formData.get('date')}T${formData.get('time')}`).toISOString()
                };
                sessions.push(newSession);
            }

            saveDataToLocalStorage();
            renderSessions();
            closeModal(sessionFormModal);
        });

        // Find pauseSessionBtn.addEventListener (around line 2890) and add logging:

        pauseSessionBtn.addEventListener('click', () => {
            clearInterval(sessionTimerInterval);
            sessionPaused = true;
            sessionElapsedSeconds = Math.floor((Date.now() - sessionStartTime) / 1000);

            const currentSession = sessions.find(s => Number(s.id) === Number(currentSessionId));

            if (!currentSession) {
                showToast('Error: Could not save session state.', 'fa-circle-xmark');
                closeLiveSession();
                return;
            }

            // Create pause data
            pausedSessionData = {
                id: Number(currentSession.id),
                sessionTitle: currentSession.title,
                sessionSubject: currentSession.subject,
                sessionType: currentSession.type,
                elapsedSeconds: sessionElapsedSeconds,
                totalDuration: sessionTotalDuration,
                chatHistory: chatbotMessages.innerHTML,
                videoSearchQuery: liveSearchInput.value,
                pausedAt: Date.now(),
                startedAt: sessionStartTime, // For timer math
                actualStartTime: sessionActualStartTime, // For display
                originalSessionId: currentSession.originalSessionId || null,
                isAISession: aiSessionState.active,
                aiSessionData: aiSessionState.active ? {
                    topic: aiSessionState.topic,
                    subject: aiSessionState.subject,
                    concepts: aiSessionState.concepts,
                    currentConceptIndex: aiSessionState.currentConceptIndex,
                    videoWatched: aiSessionState.videoWatched,
                    quizAnswered: aiSessionState.quizAnswered,
                    scores: aiSessionState.scores,
                    overallProgress: aiSessionState.overallProgress
                } : null
            };

            // ‚≠ê DEBUG LOGGING
            console.log('üíæ Saving paused session:', {
                isAI: pausedSessionData.isAISession,
                currentConcept: pausedSessionData.aiSessionData?.currentConceptIndex,
                scores: pausedSessionData.aiSessionData?.scores
            });

            localStorage.setItem('epicScholarPausedSession', JSON.stringify(pausedSessionData));
            localStorage.removeItem('epicScholarActiveSession');

            showToast(`Session Paused. ${formatTime(sessionTotalDuration - sessionElapsedSeconds)} remaining.`);

            closeLiveSession();
            setTimeout(() => {
                renderSessions();
            }, 100);
        });
        // ============================================
        // UPDATED END SESSION HANDLER
        // Replace the endSessionBtn event listener section
        // ============================================
        endSessionBtn.addEventListener('click', () => {
            const sessionIdNum = Number(currentSessionId);
            const currentSession = sessions.find(s => Number(s.id) === sessionIdNum);
            const sessionTitle = currentSession ? currentSession.title : 'this session';
            const sessionDuration = currentSession ? `${currentSession.duration} minutes` : '- minutes';

            // Show custom modal
            const endModal = document.getElementById('end-session-modal');
            const endConfirmBtn = document.getElementById('end-session-confirm-btn');
            const endCancelBtn = document.getElementById('end-session-cancel-btn');

            document.getElementById('end-session-name').textContent = sessionTitle;
            document.getElementById('end-session-duration').textContent = sessionDuration;

            endModal.classList.remove('hidden');

            const onConfirm = () => {
                endModal.classList.add('hidden');

                if (currentSessionId) {
                    const sessionIndex = sessions.findIndex(s => Number(s.id) === sessionIdNum);

                    if (sessionIndex !== -1) {
                        const endedSession = sessions[sessionIndex];
                        const isTemporary = endedSession.isTemporary;
                        const originalId = isTemporary ? Number(endedSession.originalSessionId) : null;

                        // Animate card removal (only if not temporary)
                        if (!isTemporary) {
                            const card = document.querySelector(`.session-card[data-id="${sessionIdNum}"]`);
                            if (card) {
                                card.style.transition = 'all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                                card.style.opacity = '0';
                                card.style.transform = 'scale(0.8) translateY(-20px)';
                                setTimeout(() => {
                                    card.style.maxHeight = '0';
                                    card.style.margin = '0';
                                    card.style.padding = '0';
                                    setTimeout(() => card.remove(), 400);
                                }, 200);
                            }
                        }

                        // Remove active session
                        sessions.splice(sessionIndex, 1);

                        // ‚≠ê FIX: If ending an AI session, also delete the parent session
                        if (originalId) {
                            const parentIndex = sessions.findIndex(s => Number(s.id) === originalId);
                            if (parentIndex !== -1) {
                                console.log(`üóëÔ∏è Removing parent session ID: ${originalId}`);
                                sessions.splice(parentIndex, 1);

                                // Also remove parent card from DOM if it exists on the dashboard
                                const parentCard = document.querySelector(`.session-card[data-id="${originalId}"]`);
                                if (parentCard) {
                                    parentCard.style.transition = 'all 0.4s ease';
                                    parentCard.style.opacity = '0';
                                    parentCard.style.transform = 'scale(0.8)';
                                    setTimeout(() => parentCard.remove(), 400);
                                }
                            }
                        }

                        // Always save since we modified the sessions array
                        saveDataToLocalStorage();

                        console.log(`‚úÖ Session "${endedSession.title}" ended and removed`);
                        showToast(`Session "${endedSession.title}" completed!`, 'fa-check-circle');

                        // Clear paused session data
                        if (pausedSessionData && (Number(pausedSessionData.id) === sessionIdNum || Number(pausedSessionData.originalSessionId) === originalId)) {
                            pausedSessionData = null;
                            localStorage.removeItem('epicScholarPausedSession');
                        }

                        // ‚≠ê Reset AI session state if active
                        if (aiSessionState.active) {
                            aiSessionState.active = false;
                            aiSessionState.concepts = [];
                            aiSessionState.scores = {};
                        }
                    }
                }

                // Clear timer and reset state
                clearInterval(sessionTimerInterval);
                sessionTimerInterval = null;
                sessionPaused = false;
                sessionElapsedSeconds = 0;
                sessionTotalDuration = 0;
                currentSessionId = null;

                pauseSessionBtn.textContent = "Pause Session";
                liveSessionTimer.style.color = "";

                closeLiveSession();
                setTimeout(() => renderSessions(), 800);

                endConfirmBtn.removeEventListener('click', onConfirm);
                endCancelBtn.removeEventListener('click', onCancel);
            };

            const onCancel = () => {
                endModal.classList.add('hidden');
                endConfirmBtn.removeEventListener('click', onConfirm);
                endCancelBtn.removeEventListener('click', onCancel);
            };

            endConfirmBtn.addEventListener('click', onConfirm);
            endCancelBtn.addEventListener('click', onCancel);
            endModal.addEventListener('click', (e) => {
                if (e.target === endModal) onCancel();
            }, { once: true });
        });

        // Global Click Handler
        document.addEventListener('click', (e) => {
            const target = e.target;
            let action = target.closest('[data-action]')?.dataset.action;

            // Modal Close
            if (target.classList.contains('modal')) {
                closeModal(target.closest('.modal'));
            }
            if (target.closest('.modal-close-btn')) {
                const modalId = target.closest('.modal-close-btn').getAttribute('data-modal-id');
                if (modalId) {
                    if (modalId === 'marks-modal') {
                        closeMarksModal();
                    } else {
                        closeModal(document.getElementById(modalId));
                    }
                }
            }

            // Header Buttons
            if (target.closest('#add-session-btn')) {
                openSessionForm('Session');
            }
            if (target.closest('#add-test-btn')) {
                openSessionForm('Test');
            }

            // ‚ú® Toggle Marks - Show popup with test history
            if (action === 'toggle-marks') {
                const box = target.closest('.subject-score-box');
                const subject = box.dataset.subject;
                const marks = previousMarksData[subject] || [];
                const marksContent = document.getElementById('marks-modal-content');
                const marksModal = document.getElementById('marks-modal');
                const modalContent = marksModal.querySelector('.marks-modal-content');

                // Store the origin position (center of the clicked box)
                const boxRect = box.getBoundingClientRect();
                marksModalOrigin = {
                    x: boxRect.left + boxRect.width / 2,
                    y: boxRect.top + boxRect.height / 2
                };

                document.getElementById('marks-modal-title').textContent = `${subject} - Test History`;
                marksContent.innerHTML = '';

                if (marks.length > 0) {
                    marks.forEach(mark => {
                        marksContent.innerHTML += `
                    <div class="mark-item">
                        <span class="mark-name">${mark.name}</span>
                        <span class="mark-score">${mark.score}</span>
                    </div>
                `;
                    });
                } else {
                    marksContent.innerHTML = `<p style="padding: 12px; text-align: center; color: var(--subtext-dark);">No test history found for ${subject}.</p>`;
                }

                marksModal.classList.remove('hidden');
                void marksModal.offsetWidth;

                const modalRect = modalContent.getBoundingClientRect();
                const deltaX = marksModalOrigin.x - (modalRect.left + modalRect.width / 2);
                const deltaY = marksModalOrigin.y - (modalRect.top + modalRect.height / 2);

                modalContent.style.transformOrigin = `calc(50% + ${deltaX}px) calc(50% + ${deltaY}px)`;

                setTimeout(() => {
                    marksModal.classList.add('visible');
                }, 10);
            }

            // ==================== SESSION CARD ACTIONS ====================

            // AI Session Start
            if (action === 'start-ai-session') {
                const card = target.closest('.session-card');
                const sessionId = parseInt(card.getAttribute('data-id'));
                const session = sessions.find(s => s.id === sessionId);

                if (session) {
                    // ‚≠ê TIME RESTRICTION: Check if session time has arrived
                    const sessionTime = new Date(session.datetime).getTime();
                    const now = Date.now();

                    if (now < sessionTime) {
                        const timeDiff = Math.ceil((sessionTime - now) / 60000); // minutes
                        showToast(`Session starts in ${timeDiff} minutes! Please wait.`, 'fa-clock');
                        return;
                    }

                    console.log('ü§ñ Starting AI session:', session.title);
                    initAISession(session.title, session.subject || 'General', session.duration, session.id);
                } else {
                    console.error('‚ùå Session not found for AI start');
                }
            }

            // Full Screen Test Start
            if (action === 'start-full-test') {
                const card = target.closest('.session-card');
                const sessionId = parseInt(card.getAttribute('data-id'));
                const session = sessions.find(s => s.id === sessionId);

                if (session) {
                    // ‚≠ê TIME RESTRICTION
                    const sessionTime = new Date(session.datetime).getTime();
                    const now = Date.now();

                    if (now < sessionTime) {
                        const timeDiff = Math.ceil((sessionTime - now) / 60000);
                        showToast(`Test available in ${timeDiff} minutes.`, 'fa-clock');
                        return;
                    }

                    // ‚≠ê FIX: Set currentSessionId BEFORE starting the test
                    currentSessionId = sessionId;

                    console.log('üìù Starting full test:', session.title, 'ID:', currentSessionId);
                    startFullScreenTest(session.title, session.subject);
                } else {
                    console.error('‚ùå Session not found for test start');
                }
            }
            // Find "if (action === 'resume-session')" around line 3150 and replace with:

            // NEW: Resume Linked AI Session
            if (action === 'resume-linked-ai') {
                const card = target.closest('.session-card');
                const originalSessionId = parseInt(card.getAttribute('data-id'));

                // Get paused/active data to find the temporary session ID
                let paused = JSON.parse(localStorage.getItem('epicScholarPausedSession') || 'null');
                let active = JSON.parse(localStorage.getItem('epicScholarActiveSession') || 'null');

                let targetId = null;
                if (paused && Number(paused.originalSessionId) === originalSessionId) targetId = paused.id;
                else if (active && Number(active.originalSessionId) === originalSessionId) targetId = active.id;

                if (targetId) {
                    let tempSession = sessions.find(s => Number(s.id) === Number(targetId));

                    // IF MISSING: Reconstruct from paused data
                    if (!tempSession && paused && Number(paused.id) === Number(targetId)) {
                        tempSession = {
                            id: Number(paused.id),
                            title: paused.sessionTitle,
                            subject: paused.sessionSubject,
                            type: paused.sessionType || 'Session',
                            duration: (paused.totalDuration || 0) / 60,
                            originalSessionId: originalSessionId,
                            isTemporary: true
                        };
                        sessions.push(tempSession);
                    }

                    if (tempSession) {
                        // Switch to regular resume logic using the temp session ID
                        target.closest('.session-card').setAttribute('data-id', targetId);
                        action = 'resume-session';
                    }
                }
            }

            if (action === 'resume-session') {
                const card = target.closest('.session-card');
                const sessionId = parseInt(card.getAttribute('data-id'));
                const session = sessions.find(s => Number(s.id) === sessionId);

                if (session) {
                    // ‚≠ê FAILSAFE: Load from LocalStorage if variable is missing
                    if (!pausedSessionData) {
                        const stored = localStorage.getItem('epicScholarPausedSession');
                        if (stored) {
                            try {
                                pausedSessionData = JSON.parse(stored);
                                console.log('‚úÖ Recovered paused session data from storage');
                            } catch (e) {
                                console.error('Failed to parse paused session data', e);
                            }
                        }
                    }

                    if (pausedSessionData && Number(pausedSessionData.id) === sessionId) {
                        console.log(`‚úÖ Resuming session: ${session.title}`);

                        // ‚≠ê CRITICAL FIX: Restore AI session state BEFORE opening live session
                        const isAISession = pausedSessionData.isAISession && pausedSessionData.aiSessionData;

                        if (isAISession) {
                            // Restore the FULL AI session state
                            aiSessionState.active = true;
                            aiSessionState.topic = pausedSessionData.aiSessionData.topic;
                            aiSessionState.subject = pausedSessionData.aiSessionData.subject;
                            aiSessionState.concepts = pausedSessionData.aiSessionData.concepts;
                            aiSessionState.currentConceptIndex = pausedSessionData.aiSessionData.currentConceptIndex;
                            aiSessionState.videoWatched = pausedSessionData.aiSessionData.videoWatched || false;
                            aiSessionState.quizAnswered = pausedSessionData.aiSessionData.quizAnswered || false;
                            aiSessionState.scores = pausedSessionData.aiSessionData.scores || {};
                            aiSessionState.overallProgress = pausedSessionData.aiSessionData.overallProgress || 0;

                            console.log('‚úÖ Restored AI session state:', {
                                currentConcept: aiSessionState.currentConceptIndex,
                                totalConcepts: aiSessionState.concepts.length,
                                scores: aiSessionState.scores,
                                progress: aiSessionState.overallProgress
                            });
                        }

                        // Open live session (timer restoration happens here)
                        openLiveSession(session, true);

                        // ‚≠ê CRITICAL FIX: Restore AI UI AFTER live session opens
                        if (isAISession) {
                            setTimeout(() => {
                                // Render AI layout
                                renderAISessionLayout();

                                // Update progress circle FIRST
                                updateProgress();

                                // Then load the CORRECT concept (not 0)
                                const conceptIndex = aiSessionState.currentConceptIndex;
                                console.log(`üîÑ Loading concept ${conceptIndex + 1}/${aiSessionState.concepts.length}`);
                                loadConcept(conceptIndex);

                                showToast(`Resumed at Concept ${conceptIndex + 1}: ${aiSessionState.concepts[conceptIndex].title}`);
                            }, 800); // Increased delay to ensure DOM is ready
                        }
                    } else {
                        console.error('‚ùå Could not find matching paused session data');
                        showToast('Error: Paused session data not found', 'fa-circle-xmark');
                        localStorage.removeItem('epicScholarPausedSession');
                        pausedSessionData = null;
                        renderSessions();
                    }
                }
            }

            // Regular Session Actions (start/edit/cancel)
            if (action === 'start-session' || action === 'cancel-session' || action === 'edit-session') {
                const card = target.closest('.session-card');
                const sessionId = parseInt(card.getAttribute('data-id'));
                const session = sessions.find(s => s.id === sessionId);

                if (action === 'start-session' && session) {
                    // ‚≠ê TIME RESTRICTION
                    const sessionTime = new Date(session.datetime).getTime();
                    const now = Date.now();

                    if (now < sessionTime) {
                        const timeDiff = Math.ceil((sessionTime - now) / 60000);
                        showToast(`Session starts in ${timeDiff} minutes.`, 'fa-clock');
                        return;
                    }

                    if (session.type === 'Test') {
                        console.log('üìù Starting test session:', session.title);
                        generateQuizForSession(session.title, session.subject);
                    } else {
                        console.log('üìñ Starting regular session:', session.title);
                        openLiveSession(session);
                    }
                }

                if (action === 'edit-session' && session) {
                    console.log('‚úèÔ∏è Editing session:', session.title);
                    openSessionForm(session.type, sessionId);
                }

                if (action === 'cancel-session' && session) {
                    sessionToCancel = sessionId;
                    document.getElementById('confirm-modal-message').textContent = `Do you really want to cancel "${session.title}"?`;
                    openModal(confirmModal);
                }
            }

            // Confirmation Modal Buttons
            if (target.closest('#confirm-btn-yes')) {
                if (sessionToCancel) {
                    // Animate card removal
                    const card = document.querySelector(`.session-card[data-id="${sessionToCancel}"]`);
                    if (card) {
                        card.style.transition = 'all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.8) translateY(-20px)';

                        setTimeout(() => {
                            card.remove();
                        }, 400);
                    }

                    sessions = sessions.filter(s => s.id !== sessionToCancel);
                    saveDataToLocalStorage();

                    setTimeout(() => {
                        renderSessions();
                    }, 500);

                    sessionToCancel = null;
                }
                closeModal(confirmModal);
            }

            if (target.closest('#confirm-btn-no')) {
                closeModal(confirmModal);
                sessionToCancel = null;
            }

            // Close marks modal when clicking outside
            if (target.id === 'marks-modal' && marksModal.classList.contains('visible')) {
                const modalContent = marksModal.querySelector('.marks-modal-content');
                if (!modalContent.contains(e.target)) {
                    closeMarksModal();
                }
            }
        });
        // Prevent clicks inside marks modal content from closing the modal
        document.querySelector('.marks-modal-content').addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Function to close marks modal with animation back to origin
        function closeMarksModal() {
            const marksModal = document.getElementById('marks-modal');
            const modalContent = marksModal.querySelector('.marks-modal-content');

            // Calculate the scale and position to animate back to origin
            const modalRect = modalContent.getBoundingClientRect();
            const deltaX = marksModalOrigin.x - (modalRect.left + modalRect.width / 2);
            const deltaY = marksModalOrigin.y - (modalRect.top + modalRect.height / 2);

            // Set transform origin to the clicked box position
            modalContent.style.transformOrigin = `calc(50% + ${deltaX}px) calc(50% + ${deltaY}px)`;

            // Add closing class for animation
            marksModal.classList.add('closing');

            setTimeout(() => {
                marksModal.classList.remove('visible', 'closing');
                marksModal.classList.add('hidden');
                modalContent.style.transformOrigin = 'center';
            }, 400);
        }
        // Prevent clicks inside modal content from closing the modal

        // Theme Toggle Logic
        modeToggleCheckbox.addEventListener('change', () => {
            const isDarkMode = body.classList.contains('dark-mode');
            const newTheme = isDarkMode ? 'light' : 'dark';

            if (newTheme === 'light') {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                document.documentElement.setAttribute('data-theme', 'light');
            } else {
                body.classList.remove('light-mode');
                body.classList.add('dark-mode');
                document.documentElement.removeAttribute('data-theme');
            }

            localStorage.setItem('theme', newTheme);
        });

        // Circular Progress Update
        function updateCircularProgress(percentage) {
            const circle = document.getElementById('progress-circle');
            const percentageText = document.getElementById('overall-percentage');

            if (!circle || !percentageText) return;

            const radius = 80;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (percentage / 100) * circumference;

            circle.style.strokeDasharray = circumference;
            circle.style.strokeDashoffset = offset;

            circle.classList.remove('excellent', 'good', 'average', 'poor');
            if (percentage >= 85) {
                circle.classList.add('excellent');
            } else if (percentage >= 70) {
                circle.classList.add('good');
            } else if (percentage >= 50) {
                circle.classList.add('average');
            } else {
                circle.classList.add('poor');
            }

            percentageText.textContent = `${percentage}%`;
        }
        function renderResources() {
            resourcesContainer.innerHTML = '';

            if (!resourcesData || resourcesData.length === 0) {
                resourcesContainer.innerHTML = '<p style="color: var(--subtext-dark); text-align: center; padding: 20px;">No shared resources available yet.</p>';
                return;
            }

            resourcesData.forEach(resource => {
                const card = document.createElement('div');
                card.className = 'resource-card floating-card glass-effect';
                card.style.transition = 'transform 0.3s, box-shadow 0.3s';

                // Determine icon and color based on type
                let icon = 'üìÑ';
                let iconBg = 'var(--primary-gradient)';

                if (resource.type === 'video') {
                    icon = 'üé•';
                    iconBg = 'linear-gradient(135deg, #FF416C 0%, #FF4B2B 100%)';
                } else if (resource.type === 'photo') {
                    icon = 'üì∑';
                    iconBg = 'linear-gradient(135deg, #FDC830 0%, #F37335 100%)';
                }

                card.innerHTML = `
                    <div style="display: flex; align-items: start; gap: 15px;">
                        <div style="width: 50px; height: 50px; border-radius: 12px; background: ${iconBg}; display: flex; align-items: center; justify-content: center; font-size: 1.5em; color: white; flex-shrink: 0;">
                            ${icon}
                        </div>
                        <div style="flex-grow: 1;">
                            <h4 style="margin: 0 0 5px 0; font-size: 1.1em;">${resource.title}</h4>
                            <p style="margin: 0; font-size: 0.9em; color: var(--subtext-dark);">${resource.subject}</p>
                        </div>
                        <button class="action-btn" title="Download" style="width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.1);">
                            ‚¨áÔ∏è
                        </button>
                    </div>
                `;

                // Add hover effect via JS for cleaner inline styles
                card.onmouseenter = () => { card.style.transform = 'translateY(-5px)'; card.style.boxShadow = '0 10px 25px rgba(0,0,0,0.2)'; };
                card.onmouseleave = () => { card.style.transform = 'translateY(0)'; card.style.boxShadow = 'none'; };

                resourcesContainer.appendChild(card);
            });

            revealCards('#resources-container');
        }
        // INITIALIZATION BLOCK - Replace existing DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // ‚≠ê REMOVED LOADING SCREEN - Content loads instantly
            // document.body.classList.add('loading'); // REMOVED

            // Set theme before content loads
            const savedTheme = localStorage.getItem('theme') || 'dark';
            if (savedTheme === 'light') {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                document.documentElement.setAttribute('data-theme', 'light');
                modeToggleCheckbox.checked = true;
            } else {
                body.classList.add('dark-mode');
                body.classList.remove('light-mode');
                document.documentElement.removeAttribute('data-theme');
                modeToggleCheckbox.checked = false;
            }

            // Load data
            loadDataFromLocalStorage();

            // Render content in sequence
            renderSessions();
            renderTimetable();
            renderResources();

            // Update progress
            const overallPercentage = 88.5;
            updateCircularProgress(overallPercentage);

            // ‚≠ê INSTANT DISPLAY - No loading delay
            document.body.classList.add('loaded');
            // Trigger card animations immediately
            revealCards('.dashboard-grid');

            // Start periodic session status checks
            setInterval(checkSessionStatus, 10000);
        });

        // Add this function to check session status
        function checkSessionStatus() {
            // Your existing session status checking logic
            // This prevents layout shifts during status updates
            const now = new Date();
            sessions.forEach(session => {
                const sessionTime = new Date(session.datetime);
                const card = document.querySelector(`.session-card[data-id="${session.id}"]`);
                if (card && sessionTime <= now) {
                    card.classList.add('ready-to-start');
                }
            });
        }
        // Function to close marks modal
        // Function to close marks modal with animation back to origin
        // Initialize Quiz Variables
        let quizQuestions = [];
        let quizSelectedAnswers = {};
        let quizCurrentQuestion = 0;
        let quizShowResults = false;
        const QUIZ_API_KEY = "AIzaSyAVmuy_bEGikeYncyr4Y0gPA_hv3DiCP5U"; // Your quiz API key
        const QUIZ_MODEL_NAME = "gemini-2.5-flash";
        const QUIZ_NUM_QUESTIONS = 10;
        const QUIZ_DIFFICULTY = "medium";
        function renderTimetable() {
            const timetableBody = document.getElementById('timetable-body');
            if (!timetableBody) return;

            timetableBody.innerHTML = '';

            if (!examTimetableData || examTimetableData.length === 0) {
                timetableBody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding: 20px; color: var(--subtext-dark);">No exams scheduled yet.</td></tr>';
                return;
            }

            examTimetableData.forEach((item, index) => {
                const row = document.createElement('tr');
                // Staggered animation for rows
                row.style.animation = `fadeInUp 0.4s ease forwards ${index * 0.1}s`;
                row.style.opacity = '0';

                const statusClass = item.status.toLowerCase().replace(/\s+/g, '-');

                row.innerHTML = `
                    <td><strong>${item.title}</strong></td>
                    <td>${item.subject}</td>
                    <td>${item.date}</td>
                    <td>${item.time}</td>
                    <td><span class="status-badge status-${statusClass}">${item.status}</span></td>
                `;
                timetableBody.appendChild(row);
            });
            console.log('‚úÖ Timetable rendered with', examTimetableData.length, 'entries');
        }
        // Quiz Functions - Add these functions to your script section
        async function generateQuizForSession(topic, subject) {
            const quizModal = document.getElementById('quiz-modal');
            const quizLoading = document.getElementById('quiz-loading');
            const quizContent = document.getElementById('quiz-content');

            quizLoading.classList.remove('hidden');
            quizContent.classList.add('hidden');
            document.getElementById('quiz-nav-buttons').style.display = 'none';
            document.getElementById('quiz-questions-wrapper').style.display = 'block';
            document.getElementById('quiz-question-nav').style.display = 'flex';
            document.getElementById('quiz-results-container').style.display = 'none';

            openModal(quizModal);

            quizQuestions = [];
            quizSelectedAnswers = {};
            quizCurrentQuestion = 0;
            quizShowResults = false;

            try {
                // Generate 10 questions for modal quiz
                const questions = await generateAIQuiz(topic, subject, 10);

                // Convert format to match quiz modal structure
                quizQuestions = questions;

                console.log('‚úÖ Quiz Modal Generated:', quizQuestions.length, 'questions');

                document.getElementById('quiz-topic-title').textContent = `Quiz: ${topic} - ${subject}`;
                quizLoading.classList.add('hidden');
                quizContent.classList.remove('hidden');

                renderQuizUI();

            } catch (err) {
                console.error('‚ùå Quiz Modal Error:', err);
                quizLoading.innerHTML = `
            <div class="error-box" style="text-align: center; padding: 2rem; color: var(--secondary-color);">
                <i class="fa-solid fa-exclamation-triangle" style="font-size: 2em; margin-bottom: 15px;"></i>
                <h3>Failed to generate quiz</h3>
                <p>${err.message}</p>
            </div>
            <button class="gradient-button" onclick="closeQuizModal()" style="margin-top: 1rem;">
                Close
            </button>
        `;
            }
        }
        function renderQuizUI() {
            renderQuizNavDots();
            renderQuizQuestions();
            document.getElementById('quiz-nav-buttons').style.display = 'flex';
            document.getElementById('quiz-results-container').style.display = 'none';
        }

        function renderQuizNavDots() {
            const nav = document.getElementById('quiz-question-nav');
            nav.innerHTML = '';
            quizQuestions.forEach((_, idx) => {
                const dot = document.createElement('div');
                dot.className = 'quiz-nav-dot';
                if (idx === quizCurrentQuestion) dot.classList.add('active');
                if (quizSelectedAnswers[idx]) dot.classList.add('answered');
                dot.onclick = () => goToQuizQuestion(idx);
                nav.appendChild(dot);
            });
        }

        function renderQuizQuestions() {
            const wrapper = document.getElementById('quiz-questions-wrapper');
            if (!wrapper) return;

            wrapper.innerHTML = '';

            quizQuestions.forEach((q, idx) => {
                const card = document.createElement('div');
                card.className = 'quiz-question-card';
                if (idx === quizCurrentQuestion) card.classList.add('active');
                else if (idx < quizCurrentQuestion) card.classList.add('prev');

                let optionsHTML = '';
                Object.entries(q.options).forEach(([letter, option]) => {
                    const isSelected = quizSelectedAnswers[idx] === letter;
                    const btnClass = isSelected ? 'quiz-option-btn selected' : 'quiz-option-btn';
                    optionsHTML += `
                <button class="${btnClass}" onclick="selectQuizAnswer(${idx}, '${letter}')">
                    <strong>${letter}.</strong> ${option}
                </button>
            `;
                });

                card.innerHTML = `
            <div class="quiz-question-title gradient-text">
                Question ${idx + 1} of ${quizQuestions.length}
            </div>
            <p style="font-size: 1.2em; margin-bottom: 25px; line-height: 1.6; color: var(--text-dark);">
                ${q.question}
            </p>
            ${optionsHTML}
        `;

                wrapper.appendChild(card);
            });

            updateQuizNavigationButtons();
        }

        function selectQuizAnswer(questionIndex, answer) {
            if (!quizShowResults) {
                quizSelectedAnswers[questionIndex] = answer;
                renderQuizNavDots();
                renderQuizQuestions();
            }
        }

        function goToQuizQuestion(idx) {
            quizCurrentQuestion = idx;
            renderQuizQuestions();
            renderQuizNavDots();
        }

        function quizPrevQuestion() {
            if (quizCurrentQuestion > 0) {
                quizCurrentQuestion--;
                renderQuizQuestions();
                renderQuizNavDots();
            }
        }

        function quizNextQuestion() {
            if (quizCurrentQuestion < quizQuestions.length - 1) {
                quizCurrentQuestion++;
                renderQuizQuestions();
                renderQuizNavDots();
            }
        }

        function updateQuizNavigationButtons() {
            document.getElementById('quiz-prev-btn').disabled = quizCurrentQuestion === 0;
            document.getElementById('quiz-next-btn').style.display =
                quizCurrentQuestion === quizQuestions.length - 1 ? 'none' : 'block';
            document.getElementById('quiz-submit-btn').style.display =
                Object.keys(quizSelectedAnswers).length === quizQuestions.length &&
                    quizCurrentQuestion === quizQuestions.length - 1 ? 'block' : 'none';
        }

        function submitQuizAnswers() {
            quizShowResults = true;
            const score = calculateQuizScore();
            const percentage = (score / quizQuestions.length) * 100;

            // ‚≠ê NEW: Delete the test after completion
            if (currentSessionId) {
                const testIndex = sessions.findIndex(s => Number(s.id) === Number(currentSessionId));

                if (testIndex !== -1) {
                    const completedTest = sessions[testIndex];

                    // Only delete if it's a Test type (not a regular Session)
                    if (completedTest.type === 'Test') {
                        console.log(`‚úÖ Test "${completedTest.title}" completed. Removing from dashboard...`);
                        sessions.splice(testIndex, 1);
                        saveDataToLocalStorage();
                    }
                }
            }

            let commentary, detail;
            if (percentage === 100) {
                commentary = "üéâ Perfect Score! Incredible!";
                detail = "You've mastered this topic completely. Outstanding performance!";
            } else if (percentage >= 80) {
                commentary = "üåü Excellent Work!";
                detail = "You have a strong understanding of this topic. Keep it up!";
            } else if (percentage >= 60) {
                commentary = "üëç Good Job!";
                detail = "You're on the right track. A bit more practice will make you excel!";
            } else if (percentage >= 40) {
                commentary = "üìö Keep Learning!";
                detail = "You've got the basics down. Review the material and try again!";
            } else {
                commentary = "üí™ Don't Give Up!";
                detail = "Learning takes time. Review the explanations and practice more!";
            }

            document.getElementById('quiz-nav-buttons').style.display = 'none';
            document.getElementById('quiz-question-nav').style.display = 'none';
            document.getElementById('quiz-questions-wrapper').style.display = 'none';

            const resultsContainer = document.getElementById('quiz-results-container');
            resultsContainer.style.display = 'flex';
            resultsContainer.innerHTML = `
        <div class="quiz-results-container">
            <div class="quiz-score-circle">
                <div class="quiz-score-number">${score}/${quizQuestions.length}</div>
                <div class="quiz-score-label">${percentage.toFixed(0)}%</div>
            </div>
            <div class="quiz-commentary gradient-text">${commentary}</div>
            <div class="quiz-commentary-detail">${detail}</div>
            <div style="display: flex; gap: 1rem; width: 100%; max-width: 500px;">
                <button class="gradient-button" onclick="reviewQuizAnswers()" style="flex: 1;">
                    Review Answers
                </button>
                <button class="secondary-button" onclick="closeQuizModalAndRefresh()" style="flex: 1;">
                    Close Quiz
                </button>
            </div>
        </div>
    `;
        }
        /**
 * Close quiz modal and refresh dashboard
 */
        function closeQuizModalAndRefresh() {
            closeQuizModal();

            // Wait for modal close animation
            setTimeout(() => {
                renderSessions();
                showToast('Quiz completed!', 'fa-check-circle');

                // Close live session if open
                if (liveSessionPage.classList.contains('open')) {
                    closeLiveSession();
                }
            }, 400);
        }

        function calculateQuizScore() {
            let correct = 0;
            quizQuestions.forEach((q, idx) => {
                if (quizSelectedAnswers[idx] === q.correct) correct++;
            });
            return correct;
        }

        function reviewQuizAnswers() {
            document.getElementById('quiz-results-container').style.display = 'none';
            document.getElementById('quiz-question-nav').style.display = 'none';
            document.getElementById('quiz-questions-wrapper').style.display = 'none';

            let correctCount = 0;
            let reviewHTML = '<div class="quiz-review-container">';

            quizQuestions.forEach((q, idx) => {
                const userAnswer = quizSelectedAnswers[idx];
                const isCorrect = userAnswer === q.correct;
                const cardClass = isCorrect ? 'correct' : 'incorrect';

                if (isCorrect) correctCount++;

                reviewHTML += `
            <div class="quiz-review-card ${cardClass}">
                <div class="quiz-review-question-header">
                    <div class="quiz-review-status-badge ${cardClass}">
                        ${isCorrect ? '‚úì' : '‚úï'}
                    </div>
                    <div class="quiz-review-question-text">
                        ${idx + 1}. ${q.question}
                    </div>
                </div>
                
                <div class="quiz-review-options">
        `;

                Object.entries(q.options).forEach(([letter, option]) => {
                    const isUserSelected = userAnswer === letter;
                    const isCorrectAnswer = letter === q.correct;

                    let optionClass = 'quiz-review-option';
                    let indicator = '';

                    if (isCorrectAnswer) {
                        optionClass += ' correct';
                        indicator = '‚úì Correct Answer';
                    } else if (isUserSelected && !isCorrect) {
                        optionClass += ' incorrect';
                        indicator = '‚úï Your Answer';
                    }

                    if (isUserSelected || isCorrectAnswer) {
                        reviewHTML += `
                    <div class="${optionClass}">
                        <span class="quiz-review-option-label">${letter}.</span>
                        <span>${option}</span>
                        <span class="quiz-option-indicator">${indicator}</span>
                    </div>
                `;
                    }
                });

                reviewHTML += `
                </div>
                <div class="quiz-review-explanation">
                    <div class="quiz-explanation-title">üìö Explanation</div>
                    <div class="quiz-explanation-text">${q.explanation}</div>
                </div>
            </div>
        `;
            });

            reviewHTML += '</div>';

            const resultsContainer = document.getElementById('quiz-results-container');
            resultsContainer.innerHTML = `
        <div class="quiz-results-container" style="flex-direction: column; width: 100%;">
            <div style="width: 100%; text-align: center; margin-bottom: 2rem;">
                <h2 class="gradient-text" style="font-size: 1.8rem; margin-bottom: 1rem;">Review Your Answers</h2>
                <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 1rem;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="font-size: 2rem; color: #10b981; font-weight: 700;">
                            ${correctCount}
                        </div>
                        <div style="color: var(--subtext-dark); font-size: 0.9rem;">Correct</div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="font-size: 2rem; color: #ef4444; font-weight: 700;">
                            ${quizQuestions.length - correctCount}
                        </div>
                        <div style="color: var(--subtext-dark); font-size: 0.9rem;">Incorrect</div>
                    </div>
                </div>
            </div>
            ${reviewHTML}
            <div style="display: flex; gap: 1rem; margin-top: 1rem; justify-content: center;">
                <button class="secondary-button" onclick="backToQuizResults()" style="max-width: 200px;">
                    ‚Üê Back to Results
                </button>
                <button class="gradient-button" onclick="closeQuizModal()" style="max-width: 200px;">
                    Close Quiz
                </button>
            </div>
        </div>
    `;

            resultsContainer.style.display = 'flex';
        }

        function backToQuizResults() {
            submitQuizAnswers();
        }

        function closeQuizModal() {
            const quizModal = document.getElementById('quiz-modal');
            closeModal(quizModal);

            // Complete reset of quiz state
            quizQuestions = [];
            quizSelectedAnswers = {};
            quizCurrentQuestion = 0;
            quizShowResults = false;

            // Reset all UI elements
            document.getElementById('quiz-loading').classList.remove('hidden');
            document.getElementById('quiz-content').classList.add('hidden');
            document.getElementById('quiz-nav-buttons').style.display = 'none';
            document.getElementById('quiz-questions-wrapper').style.display = 'block';
            document.getElementById('quiz-questions-wrapper').innerHTML = '';
            document.getElementById('quiz-question-nav').style.display = 'flex';
            document.getElementById('quiz-question-nav').innerHTML = '';
            document.getElementById('quiz-results-container').style.display = 'none';
            document.getElementById('quiz-results-container').innerHTML = '';
        }
        // Function to generate quiz for current session
        async function generateSessionQuiz(sessionIndex, sessionData) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Generate 5 multiple choice questions based on this content: "${sessionData.topic}". 
                        
                        Return ONLY a valid JSON array with this exact structure, no markdown, no backticks:
                        [
                          {
                            "question": "Question text here?",
                            "options": ["Option A", "Option B", "Option C", "Option D"],
                            "correctAnswer": 0
                          }
                        ]
                        
                        Make sure correctAnswer is the index (0-3) of the correct option.`
                            }]
                        }]
                    })
                });

                const data = await response.json();
                let quizText = data.candidates[0].content.parts[0].text.trim();

                // Clean up the response
                quizText = quizText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                const questions = JSON.parse(quizText);

                // Store the quiz
                sessionQuizzes[sessionIndex] = {
                    questions: questions,
                    sessionTopic: sessionData.topic
                };

                console.log(`Quiz generated for session ${sessionIndex + 1}`);
                return questions;

            } catch (error) {
                console.error('Error generating quiz:', error);
                // Fallback quiz
                sessionQuizzes[sessionIndex] = {
                    questions: [{
                        question: `What did you learn about ${sessionData.topic}?`,
                        options: ["Concept A", "Concept B", "Concept C", "All of the above"],
                        correctAnswer: 3
                    }],
                    sessionTopic: sessionData.topic
                };
                return sessionQuizzes[sessionIndex].questions;
            }
        }
        function showQuiz() {
            const concept = aiSessionState.concepts[aiSessionState.currentConceptIndex];
            const quiz = concept.quiz;

            if (!quiz) return;

            const quizContainer = document.getElementById('ai-quiz-container');
            const quizContent = document.getElementById('ai-quiz-content');

            quizContainer.style.display = 'block';

            // Render the quiz question
            let optionsHTML = '';
            quiz.options.forEach((option, idx) => {
                optionsHTML += `
            <div class="quiz-option" onclick="answerAIQuiz(${idx})" style="cursor: pointer;">
                <strong>${String.fromCharCode(65 + idx)}.</strong> ${option}
            </div>
        `;
            });

            quizContent.innerHTML = `
        <div class="quiz-question">${quiz.question}</div>
        <div class="quiz-options">
            ${optionsHTML}
        </div>
    `;
        }
        function answerAIQuiz(selectedIndex) {
            const concept = aiSessionState.concepts[aiSessionState.currentConceptIndex];
            const quiz = concept.quiz;
            const isCorrect = selectedIndex === quiz.correctIndex;

            // Disable further clicks
            document.querySelectorAll('.quiz-option').forEach(opt => {
                opt.style.pointerEvents = 'none';
            });

            // Highlight selected and correct answers
            const options = document.querySelectorAll('.quiz-option');
            options[selectedIndex].classList.add(isCorrect ? 'correct' : 'incorrect');
            if (!isCorrect) {
                options[quiz.correctIndex].classList.add('correct');
            }

            // Show feedback
            const quizContent = document.getElementById('ai-quiz-content');
            const feedbackClass = isCorrect ? 'correct' : 'incorrect';
            const feedbackHTML = `
        <div class="quiz-feedback ${feedbackClass}" style="margin-top: 20px; animation: fadeInUp 0.4s ease;">
            <strong>${isCorrect ? '‚úì Correct!' : '‚úó Incorrect'}</strong>
            <p style="margin: 10px 0 0 0;">${quiz.explanation}</p>
        </div>
    `;

            quizContent.insertAdjacentHTML('beforeend', feedbackHTML);

            // Store score (100 for correct, 0 for incorrect)
            const score = isCorrect ? 100 : 0;
            aiSessionState.scores[aiSessionState.currentConceptIndex] = score;

            // Determine next action
            const nextAction = determineNextConcept(isCorrect);

            // Add continue button
            setTimeout(() => {
                quizContent.insertAdjacentHTML('beforeend', `
            <button class="gradient-button" onclick="${nextAction.action}" 
                    style="margin-top: 20px; width: 100%; animation: fadeInUp 0.4s ease 0.2s both;">
                ${nextAction.label}
            </button>
        `);
            }, 1000);

            // Update progress
            updateProgress();
        }

        function fsSubmitQuiz() {
            const total = fsQuestions.length;
            let correct = 0;

            fsQuestions.forEach((q, i) => {
                if (fsSelected[i] === q.correct) correct++;
            });

            const percentage = Math.round((correct / total) * 100);

            const isFromAISession = aiSessionState.active;
            const isStandaloneTest = !isFromAISession && currentSessionId;

            console.log('üìä Quiz Results:', {
                correct,
                total,
                percentage,
                isAISession: isFromAISession,
                isStandaloneTest: isStandaloneTest,
                currentSessionId: currentSessionId
            });

            // If this is from an AI session, update session state
            if (isFromAISession) {
                const currentIndex = aiSessionState.currentConceptIndex;
                aiSessionState.scores[currentIndex] = percentage;
                aiSessionState.quizAnswered = true;
                console.log(`‚úÖ Concept ${currentIndex + 1} completed with ${percentage}%`);
            }

            // ‚≠ê ENHANCED: If this is a standalone test, delete it after completion
            if (isStandaloneTest) {
                const testIndex = sessions.findIndex(s => Number(s.id) === Number(currentSessionId));

                console.log('üîç Looking for test to delete:', {
                    searchingForId: currentSessionId,
                    foundIndex: testIndex,
                    totalSessions: sessions.length
                });

                if (testIndex !== -1) {
                    const completedTest = sessions[testIndex];
                    console.log(`‚úÖ Test "${completedTest.title}" completed. Removing from dashboard...`);

                    // ‚≠ê Animate card removal if it exists on page
                    const card = document.querySelector(`.session-card[data-id="${currentSessionId}"]`);
                    if (card) {
                        console.log('üé¨ Animating card removal...');
                        card.classList.add('test-completed');

                        // Wait for animation before removing from DOM
                        setTimeout(() => {
                            card.remove();
                            console.log('‚úÖ Card removed from DOM');
                        }, 600);
                    }

                    // Remove from sessions array
                    sessions.splice(testIndex, 1);

                    // Save to localStorage
                    saveDataToLocalStorage();

                    console.log('‚úÖ Test deleted from sessions array and saved to localStorage');
                    console.log('üìä Remaining sessions:', sessions.length);

                    // Show completion toast
                    showToast(`Test "${completedTest.title}" completed and removed!`, 'fa-check-circle');
                } else {
                    console.error('‚ùå Could not find test to delete!', {
                        currentSessionId: currentSessionId,
                        availableIds: sessions.map(s => s.id)
                    });
                }
            }

            const results = document.getElementById('fs-results-container');
            const quizSection = document.getElementById('fs-quiz-section');

            quizSection.classList.add('hidden');
            results.classList.remove('hidden');

            let commentary, emoji;
            if (percentage === 100) {
                emoji = 'üéâ';
                commentary = 'Perfect Score!';
            } else if (percentage >= 80) {
                emoji = '‚≠ê';
                commentary = 'Excellent Work!';
            } else if (percentage >= 60) {
                emoji = 'üëç';
                commentary = 'Good Job!';
            } else if (percentage >= 40) {
                emoji = 'üìö';
                commentary = 'Keep Learning!';
            } else {
                emoji = 'üí™';
                commentary = "Don't Give Up!";
            }

            let actionButtons = '';

            if (isFromAISession) {
                const nextAction = determineNextConceptAction(percentage >= 60);
                actionButtons = `
            <button class="btn btn-primary" onclick="reviewFsAnswers()">
                Review Answers
            </button>
            <button class="btn btn-primary" onclick="${nextAction}">
                ${percentage >= 60 ? '‚Üí Continue to Next Concept' : '‚Ü∫ Review This Concept'}
            </button>
        `;
            } else {
                actionButtons = `
            <button class="btn btn-primary" onclick="reviewFsAnswers()">
                Review Answers
            </button>
            <button class="btn btn-primary" onclick="closeFullScreenTestAndRefresh()">
                Close Test
            </button>
        `;
            }

            results.innerHTML = `
        <div class="results-container">
            <div class="score-circle">
                <div class="score-number">${correct}/${total}</div>
                <div class="score-label">${percentage}%</div>
            </div>
            <div class="commentary gradient-text">${emoji} ${commentary}</div>
            <div class="commentary-detail">You got ${correct} out of ${total} questions correct</div>
            
            <div class="button-group">
                ${actionButtons}
            </div>
        </div>
    `;

            if (isFromAISession) {
                updateProgress();
            }
        }
        // ============================================
        // CLOSE FULL SCREEN TEST WITH DASHBOARD REFRESH
        // Add after your existing closeFullScreenTest() function
        // ============================================

        /**
         * Close full-screen test and refresh dashboard to show deleted test
         */
        function closeFullScreenTestAndRefresh() {
            console.log('üîÑ Closing test and refreshing dashboard...');

            // Close the modal
            const modal = document.getElementById('full-screen-test-modal');
            modal.classList.add('hidden');
            document.body.classList.remove('quiz-active');

            // ‚≠ê NOW reset currentSessionId after deletion is complete
            currentSessionId = null;

            // Wait for modal animation to complete, then refresh dashboard
            setTimeout(() => {
                // Re-render sessions to update the UI
                renderSessions();

                // Show success message
                showToast('Test completed successfully!', 'fa-trophy');

                // If live session page is open, close it too
                if (liveSessionPage.classList.contains('open')) {
                    closeLiveSession();
                }
            }, 400);
        }
        /**
 * Determine next action after concept quiz based on score
 */
        function determineNextConceptAction(passed) {
            const currentIndex = aiSessionState.currentConceptIndex;
            const totalConcepts = aiSessionState.concepts.length;

            if (passed) {
                // Move to next concept or complete session
                if (currentIndex + 1 < totalConcepts) {
                    return `closeFullScreenTest(); loadConcept(${currentIndex + 1});`;
                } else {
                    return `closeFullScreenTest(); showAISessionCompletion();`;
                }
            } else {
                // Review current concept again
                return `closeFullScreenTest(); loadConcept(${currentIndex});`;
            }
        }
    </script>
</body>

</html>
