<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EpicScholar | Cinematic Reveal</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #loader {
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="loader">Waiting...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            startDelay: 3.0, // Seconds to wait before starting
            particleCount: 35000, // Increased for denser text
            pixelSize: 8.0, // Larger pixels
            floorSize: 100,
            // Gradients
            textTop: new THREE.Color('#00c6ff'),
            textBot: new THREE.Color('#0072ff'),
            particleA: new THREE.Color('#ff0099'),
            particleB: new THREE.Color('#493240')
        };

        let scene, camera, renderer, composer;
        let mainText, particles;
        let clock = new THREE.Clock();
        let animationStarted = false;

        const STATE = {
            impacted: false,
            morphing: false,
        };

        let cameraShake = 0;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Initial Camera pos: High up, looking down (looks 2D)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 80, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            // Strong bloom for solid looking particles
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.5, 0.9);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            const loader = new FontLoader();
            loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                createSceneObjects(font);
                renderer.setAnimationLoop(animate);
            });
            window.addEventListener('resize', onResize);
        }

        function createSceneObjects(font) {
            // --- 1. THE PERSISTENT GRADIENT TEXT ---
            const textGeo = new TextGeometry('EPICSCHOLAR', {
                font: font, size: 5, height: 1.5, // slightly thicker for 3D effect
                bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.1, bevelSegments: 5
            });
            textGeo.center();

            // Custom Gradient Shader Material
            const gradientMat = new THREE.ShaderMaterial({
                uniforms: {
                    cTop: { value: CONFIG.textTop },
                    cBot: { value: CONFIG.textBot },
                    uHeight: { value: 6.0 } // Approximate height of text for gradient mapping
                },
                vertexShader: `
                    varying float vY;
                    void main() {
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vY = worldPos.y; // Pass world height to fragment
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,
                fragmentShader: `
                    uniform vec3 cTop; uniform vec3 cBot; uniform float uHeight;
                    varying float vY;
                    void main() {
                        // Map Y position to 0-1 range relative to text height
                        float t = clamp((vY) / uHeight, 0.0, 1.0); 
                        gl_FragColor = vec4(mix(cBot, cTop, t), 1.0);
                    }
                `
            });

            mainText = new THREE.Mesh(textGeo, gradientMat);
            mainText.position.y = 100; // Start high
            scene.add(mainText);


            // --- 2. THE PARTICLES ---
            // Define target shape
            const finalTextGeo = new TextGeometry('COMING\nMAY 2026', {
                font: font, size: 3, height: 0
            });
            finalTextGeo.center();

            const count = CONFIG.particleCount;
            const posArray = finalTextGeo.attributes.position;
            const startPos = new Float32Array(count * 3);
            const endPos = new Float32Array(count * 3);
            const randoms = new Float32Array(count);

            const gridSize = Math.ceil(Math.sqrt(count));
            const spacing = CONFIG.floorSize / gridSize;

            for (let i = 0; i < count; i++) {
                // Floor Grid Positions
                const r = Math.floor(i / gridSize); const c = i % gridSize;
                startPos[i * 3] = (c * spacing) - (CONFIG.floorSize / 2) + (Math.random() - 0.5);
                startPos[i * 3 + 1] = 0;
                startPos[i * 3 + 2] = (r * spacing) - (CONFIG.floorSize / 2) + (Math.random() - 0.5);

                // Text Target Positions (Cyclic sampling of vertices)
                const vIndex = i % posArray.count;
                // Scale up and lift target
                endPos[i * 3] = posArray.getX(vIndex) * 1.8 + (Math.random() - 0.5) * 0.2;
                endPos[i * 3 + 1] = posArray.getY(vIndex) * 1.8 + 6;
                endPos[i * 3 + 2] = posArray.getZ(vIndex) + (Math.random() - 0.5) * 0.5; // Add depth noise for solidity

                randoms[i] = Math.random();
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(startPos, 3));
            geometry.setAttribute('aStart', new THREE.BufferAttribute(startPos, 3));
            geometry.setAttribute('aEnd', new THREE.BufferAttribute(endPos, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 }, uMorphProgress: { value: 0 }, uImpactTime: { value: -99.0 },
                    uColor1: { value: CONFIG.particleA }, uColor2: { value: CONFIG.particleB },
                    uSize: { value: CONFIG.pixelSize }
                },
                vertexShader: `
                    uniform float uTime, uMorphProgress, uImpactTime, uSize;
                    attribute vec3 aStart, aEnd; attribute float aRandom;
                    varying vec3 vColor; varying float vAlpha;

                    void main() {
                        // 1. RIPPLE
                        float dist = length(aStart.xz);
                        float rippleAge = uTime - uImpactTime;
                        float rippleH = 0.0; float brightness = 0.0;
                        if (uImpactTime > 0.0 && rippleAge > 0.0) {
                            float waveLoc = rippleAge * 40.0; // Faster ripple
                            float waveWidth = 15.0;
                            float d = abs(dist - waveLoc);
                            if (d < waveWidth) {
                                float norm = 1.0 - (d / waveWidth);
                                rippleH = sin(norm * 3.14) * 5.0 * exp(-rippleAge * 1.5);
                                brightness = norm; 
                            }
                            // Trail
                             if (dist < waveLoc) brightness = max(brightness, exp(-(waveLoc-dist)*0.02)*0.3);
                        }

                        // 2. MORPH
                        float morphDelay = aRandom * 0.5; // Random delay
                        float effectiveMorph = smoothstep(morphDelay, 1.0 + morphDelay, uMorphProgress * 1.5);
                        vec3 pos = mix(aStart, aEnd, effectiveMorph);
                        pos.y += rippleH * (1.0 - effectiveMorph); // Ripple only on floor state

                        // 3. COLOR & SIZE
                        float activeState = brightness + effectiveMorph;
                        vColor = mix(uColor2, uColor1, aRandom + brightness * 0.5);
                        // Make particles fully bright when morphed to look solid
                        vColor = mix(vColor, vec3(1.0, 0.9, 1.0), effectiveMorph * 0.6); 
                        vAlpha = smoothstep(0.01, 0.1, activeState);

                        gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);
                        // Adjust point size by distance for pseudo-perspective
                        gl_PointSize = uSize * (30.0 / gl_Position.z); 
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor; varying float vAlpha;
                    void main() {
                         if (vAlpha < 0.1) discard;
                         // Circular points
                         vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                         if (dot(cxy, cxy) > 1.0) discard;
                         gl_FragColor = vec4(vColor, 1.0);
                    }
                `,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function animate() {
            const totalElapsedTime = clock.getElapsedTime();

            // --- 3-SECOND WAIT LOGIC ---
            if (totalElapsedTime < CONFIG.startDelay) {
                let remaining = Math.ceil(CONFIG.startDelay - totalElapsedTime);
                document.getElementById('loader').innerText = `Starting in ${remaining}...`;
                composer.render();
                return; // Skip animation frames
            } else if (!animationStarted) {
                animationStarted = true;
                document.getElementById('loader').style.opacity = 0;
                clock.start(); // Restart clock for animation timing
            }

            // --- MAIN ANIMATION LOOP ---
            const time = clock.getElapsedTime();
            const dt = clock.getDelta();

            if (particles) particles.material.uniforms.uTime.value = time;

            // Phase 1: The Drop & Camera Shift (2D -> 3D reveal)
            if (!STATE.impacted) {
                // Drop speed increases
                mainText.position.y -= (5.0 + time * 35.0) * dt;

                // Camera Move: Arc down and tilt up
                // Interpolate from (0,80,10) looking at (0,0,0) 
                // to roughly (0, 20, 60) looking at (0, 10, 0)
                const t = smoothstep(0, 1.8, time); // Normalize drop time roughly
                camera.position.y = THREE.MathUtils.lerp(80, 15, t);
                camera.position.z = THREE.MathUtils.lerp(10, 60, t);
                camera.lookAt(0, THREE.MathUtils.lerp(0, 5, t), 0);

                // Impact Check
                if (mainText.position.y <= 2.5) {
                    mainText.position.y = 2.5; // Hover just above floor
                    STATE.impacted = true;
                    cameraShake = 1.0;
                    particles.material.uniforms.uImpactTime.value = time;
                    // Start morph after ripple settles
                    setTimeout(() => { STATE.morphing = true; }, 2500);
                }
            }
            // Phase 2: Post-Impact Hover & Shake
            else {
                // Slight hover bob
                mainText.position.y = 2.5 + Math.sin(time * 2) * 0.5;

                // Camera Shake decay
                if (cameraShake > 0) {
                    camera.position.x += (Math.random() - 0.5) * cameraShake;
                    camera.position.y += (Math.random() - 0.5) * cameraShake * 0.5;
                    cameraShake *= 0.9; // rapid decay
                }
                // Slow camera drift after impact
                camera.position.z += 0.01;
                camera.lookAt(0, 5, 0);
            }

            // Phase 3: Morphing
            if (STATE.morphing) {
                particles.material.uniforms.uMorphProgress.value += dt * 0.4; // Slow morph
            }

            composer.render();
        }

        // Helper for smoother animation transitions
        function smoothstep(min, max, value) {
            var x = Math.max(0, Math.min(1, (value - min) / (max - min)));
            return x * x * (3 - 2 * x);
        };

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>
